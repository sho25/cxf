begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements. See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|systest
operator|.
name|type_test
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|namespace
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|ws
operator|.
name|Holder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types1
operator|.
name|AnonymousType
import|;
end_import

begin_comment
comment|//importorg.apache.type_test.types1.ComplexArray;
end_comment

begin_comment
comment|//importorg.apache.type_test.types1.ComplexChoice;
end_comment

begin_comment
comment|//importorg.apache.type_test.types1.ComplexStruct;
end_comment

begin_comment
comment|//importorg.apache.type_test.types1.DerivedAllBaseAll;
end_comment

begin_comment
comment|//importorg.apache.type_test.types1.DerivedAllBaseChoice;
end_comment

begin_comment
comment|//importorg.apache.type_test.types1.DerivedAllBaseStruct;
end_comment

begin_comment
comment|//importorg.apache.type_test.types1.DerivedChoiceBaseAll;
end_comment

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types1
operator|.
name|DerivedChoiceBaseArray
import|;
end_import

begin_comment
comment|//importorg.apache.type_test.types1.DerivedChoiceBaseComplex;
end_comment

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types1
operator|.
name|DerivedEmptyBaseEmptyAll
import|;
end_import

begin_comment
comment|//importorg.apache.type_test.types1.DerivedStructBaseAll;
end_comment

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types1
operator|.
name|DerivedStructBaseChoice
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types1
operator|.
name|DerivedStructBaseStruct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types1
operator|.
name|EmptyAll
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types1
operator|.
name|EmptyStruct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types1
operator|.
name|NestedStruct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types1
operator|.
name|OccuringAll
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types1
operator|.
name|RecSeqB6918
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types1
operator|.
name|RestrictedAllBaseAll
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types1
operator|.
name|RestrictedStructBaseStruct
import|;
end_import

begin_comment
comment|//importorg.apache.type_test.types1.SimpleAll;
end_comment

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types1
operator|.
name|SimpleChoice
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types1
operator|.
name|SimpleStruct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types1
operator|.
name|UnboundedArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types2
operator|.
name|OccuringChoiceWithAnyAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types2
operator|.
name|OccuringStructWithAnyAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types2
operator|.
name|SimpleContentExtWithAnyAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types3
operator|.
name|ArrayOfMRecSeqD
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types3
operator|.
name|MRecSeqA
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types3
operator|.
name|MRecSeqB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types3
operator|.
name|MRecSeqC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types3
operator|.
name|MRecSeqD
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types3
operator|.
name|StructWithNillableChoice
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types3
operator|.
name|StructWithNillableStruct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types3
operator|.
name|StructWithOccuringChoice
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|type_test
operator|.
name|types3
operator|.
name|StructWithOccuringStruct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_class
specifier|public
specifier|abstract
class|class
name|AbstractTypeTestClient4
extends|extends
name|AbstractTypeTestClient3
block|{
comment|//org.apache.type_test.types2.SimpleContentExtWithAnyAttribute;
specifier|protected
name|boolean
name|equals
parameter_list|(
name|SimpleContentExtWithAnyAttribute
name|x
parameter_list|,
name|SimpleContentExtWithAnyAttribute
name|y
parameter_list|)
block|{
if|if
condition|(
operator|!
name|x
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|y
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|equalsNilable
argument_list|(
name|x
operator|.
name|getAttrib
argument_list|()
argument_list|,
name|y
operator|.
name|getAttrib
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|equalsQNameStringPairs
argument_list|(
name|x
operator|.
name|getOtherAttributes
argument_list|()
argument_list|,
name|y
operator|.
name|getOtherAttributes
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimpleContentExtWithAnyAttribute
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"SimpleContentExtWithAnyAttribute"
argument_list|)
condition|)
block|{
return|return;
block|}
name|QName
name|xAt1Name
init|=
operator|new
name|QName
argument_list|(
literal|"http://apache.org/type_test"
argument_list|,
literal|"at_one"
argument_list|)
decl_stmt|;
name|QName
name|xAt2Name
init|=
operator|new
name|QName
argument_list|(
literal|"http://apache.org/type_test"
argument_list|,
literal|"at_two"
argument_list|)
decl_stmt|;
name|QName
name|yAt3Name
init|=
operator|new
name|QName
argument_list|(
literal|"http://apache.org/type_test"
argument_list|,
literal|"at_thr"
argument_list|)
decl_stmt|;
name|QName
name|yAt4Name
init|=
operator|new
name|QName
argument_list|(
literal|"http://apache.org/type_test"
argument_list|,
literal|"at_fou"
argument_list|)
decl_stmt|;
name|SimpleContentExtWithAnyAttribute
name|x
init|=
operator|new
name|SimpleContentExtWithAnyAttribute
argument_list|()
decl_stmt|;
name|x
operator|.
name|setValue
argument_list|(
literal|"foo"
argument_list|)
expr_stmt|;
name|x
operator|.
name|setAttrib
argument_list|(
operator|new
name|Integer
argument_list|(
literal|2000
argument_list|)
argument_list|)
expr_stmt|;
name|SimpleContentExtWithAnyAttribute
name|y
init|=
operator|new
name|SimpleContentExtWithAnyAttribute
argument_list|()
decl_stmt|;
name|y
operator|.
name|setValue
argument_list|(
literal|"bar"
argument_list|)
expr_stmt|;
name|y
operator|.
name|setAttrib
argument_list|(
operator|new
name|Integer
argument_list|(
literal|2001
argument_list|)
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|QName
argument_list|,
name|String
argument_list|>
name|xAttrMap
init|=
name|x
operator|.
name|getOtherAttributes
argument_list|()
decl_stmt|;
name|xAttrMap
operator|.
name|put
argument_list|(
name|xAt1Name
argument_list|,
literal|"one"
argument_list|)
expr_stmt|;
name|xAttrMap
operator|.
name|put
argument_list|(
name|xAt2Name
argument_list|,
literal|"two"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|QName
argument_list|,
name|String
argument_list|>
name|yAttrMap
init|=
name|y
operator|.
name|getOtherAttributes
argument_list|()
decl_stmt|;
name|yAttrMap
operator|.
name|put
argument_list|(
name|yAt3Name
argument_list|,
literal|"three"
argument_list|)
expr_stmt|;
name|yAttrMap
operator|.
name|put
argument_list|(
name|yAt4Name
argument_list|,
literal|"four"
argument_list|)
expr_stmt|;
name|Holder
argument_list|<
name|SimpleContentExtWithAnyAttribute
argument_list|>
name|yh
init|=
operator|new
name|Holder
argument_list|<
name|SimpleContentExtWithAnyAttribute
argument_list|>
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|SimpleContentExtWithAnyAttribute
argument_list|>
name|zh
init|=
operator|new
name|Holder
argument_list|<
name|SimpleContentExtWithAnyAttribute
argument_list|>
argument_list|()
decl_stmt|;
name|SimpleContentExtWithAnyAttribute
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testSimpleContentExtWithAnyAttribute
argument_list|(
name|x
argument_list|,
name|yh
argument_list|,
name|zh
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testSimpleContentExtWithAnyAttribute
argument_list|(
name|x
argument_list|,
name|yh
argument_list|,
name|zh
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testSimpleContentExtWithAnyAttribute
argument_list|(
name|x
argument_list|,
name|yh
argument_list|,
name|zh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testSimpleContentExtWithAnyAttribute(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|yh
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testSimpleContentExtWithAnyAttribute(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|y
argument_list|,
name|zh
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testSimpleContentExtWithAnyAttribute(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|ret
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//org.apache.type_test.types3.OccuringAll;
specifier|protected
name|boolean
name|equals
parameter_list|(
name|OccuringAll
name|x
parameter_list|,
name|OccuringAll
name|y
parameter_list|)
block|{
if|if
condition|(
name|x
operator|.
name|getVarAttrString
argument_list|()
operator|==
literal|null
operator|&&
name|y
operator|.
name|getVarAttrString
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
name|x
operator|.
name|getVarInt
argument_list|()
operator|==
literal|null
operator|&&
name|y
operator|.
name|getVarInt
argument_list|()
operator|==
literal|null
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|equalsNilable
argument_list|(
name|x
operator|.
name|getVarAttrString
argument_list|()
argument_list|,
name|y
operator|.
name|getVarAttrString
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|x
operator|.
name|getVarInt
argument_list|()
operator|.
name|compareTo
argument_list|(
name|y
operator|.
name|getVarInt
argument_list|()
argument_list|)
operator|==
literal|0
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOccuringAll
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"OccuringAll"
argument_list|)
condition|)
block|{
return|return;
block|}
name|OccuringAll
name|x
init|=
operator|new
name|OccuringAll
argument_list|()
decl_stmt|;
name|x
operator|.
name|setVarInt
argument_list|(
operator|new
name|Integer
argument_list|(
literal|42
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|.
name|setVarAttrString
argument_list|(
literal|"x_attr"
argument_list|)
expr_stmt|;
name|OccuringAll
name|yOrig
init|=
operator|new
name|OccuringAll
argument_list|()
decl_stmt|;
name|Holder
argument_list|<
name|OccuringAll
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|OccuringAll
argument_list|>
argument_list|(
name|yOrig
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|OccuringAll
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|OccuringAll
argument_list|>
argument_list|()
decl_stmt|;
name|OccuringAll
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testOccuringAll
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testOccuringAll
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testOccuringAll
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testOccuringAll(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testOccuringAll(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOrig
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testOccuringAll(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//org.apache.type_test.types2.OccuringStructWithAnyAttribute;
specifier|protected
name|boolean
name|equals
parameter_list|(
name|OccuringStructWithAnyAttribute
name|x
parameter_list|,
name|OccuringStructWithAnyAttribute
name|y
parameter_list|)
block|{
if|if
condition|(
operator|!
name|equalsNilable
argument_list|(
name|x
operator|.
name|getAtString
argument_list|()
argument_list|,
name|y
operator|.
name|getAtString
argument_list|()
argument_list|)
operator|||
operator|!
name|equalsNilable
argument_list|(
name|x
operator|.
name|getAtInt
argument_list|()
argument_list|,
name|y
operator|.
name|getAtInt
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|Serializable
argument_list|>
name|xList
init|=
name|x
operator|.
name|getVarStringAndVarInt
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Serializable
argument_list|>
name|yList
init|=
name|y
operator|.
name|getVarStringAndVarInt
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|equalsStringIntList
argument_list|(
name|xList
argument_list|,
name|yList
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|equalsQNameStringPairs
argument_list|(
name|x
operator|.
name|getOtherAttributes
argument_list|()
argument_list|,
name|y
operator|.
name|getOtherAttributes
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|equalsStringIntList
parameter_list|(
name|List
argument_list|<
name|Serializable
argument_list|>
name|xList
parameter_list|,
name|List
argument_list|<
name|Serializable
argument_list|>
name|yList
parameter_list|)
block|{
name|int
name|size
init|=
name|xList
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|!=
name|yList
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|String
operator|&&
name|yList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|String
condition|)
block|{
if|if
condition|(
operator|!
name|xList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|equals
argument_list|(
name|yList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|xList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|Integer
operator|&&
name|yList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|Integer
condition|)
block|{
name|Integer
name|ix
init|=
operator|(
name|Integer
operator|)
name|xList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Integer
name|iy
init|=
operator|(
name|Integer
operator|)
name|yList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|iy
operator|.
name|compareTo
argument_list|(
name|ix
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOccuringStructWithAnyAttribute
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"OccuringStructWithAnyAttribute"
argument_list|)
condition|)
block|{
return|return;
block|}
name|QName
name|xAt1Name
init|=
operator|new
name|QName
argument_list|(
literal|"http://apache.org/type_test"
argument_list|,
literal|"at_one"
argument_list|)
decl_stmt|;
name|QName
name|xAt2Name
init|=
operator|new
name|QName
argument_list|(
literal|"http://apache.org/type_test"
argument_list|,
literal|"at_two"
argument_list|)
decl_stmt|;
name|QName
name|yAt3Name
init|=
operator|new
name|QName
argument_list|(
literal|"http://apache.org/type_test"
argument_list|,
literal|"at_thr"
argument_list|)
decl_stmt|;
name|QName
name|yAt4Name
init|=
operator|new
name|QName
argument_list|(
literal|"http://apache.org/type_test"
argument_list|,
literal|"at_fou"
argument_list|)
decl_stmt|;
name|OccuringStructWithAnyAttribute
name|x
init|=
operator|new
name|OccuringStructWithAnyAttribute
argument_list|()
decl_stmt|;
name|OccuringStructWithAnyAttribute
name|y
init|=
operator|new
name|OccuringStructWithAnyAttribute
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Serializable
argument_list|>
name|xVarStringAndVarInt
init|=
name|x
operator|.
name|getVarStringAndVarInt
argument_list|()
decl_stmt|;
name|xVarStringAndVarInt
operator|.
name|add
argument_list|(
literal|"x1"
argument_list|)
expr_stmt|;
name|xVarStringAndVarInt
operator|.
name|add
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|xVarStringAndVarInt
operator|.
name|add
argument_list|(
literal|"x2"
argument_list|)
expr_stmt|;
name|xVarStringAndVarInt
operator|.
name|add
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|x
operator|.
name|setAtString
argument_list|(
literal|"attribute"
argument_list|)
expr_stmt|;
name|x
operator|.
name|setAtInt
argument_list|(
operator|new
name|Integer
argument_list|(
literal|2000
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Serializable
argument_list|>
name|yVarStringAndVarInt
init|=
name|y
operator|.
name|getVarStringAndVarInt
argument_list|()
decl_stmt|;
name|yVarStringAndVarInt
operator|.
name|add
argument_list|(
literal|"there"
argument_list|)
expr_stmt|;
name|yVarStringAndVarInt
operator|.
name|add
argument_list|(
literal|1001
argument_list|)
expr_stmt|;
name|y
operator|.
name|setAtString
argument_list|(
literal|"another attribute"
argument_list|)
expr_stmt|;
name|y
operator|.
name|setAtInt
argument_list|(
operator|new
name|Integer
argument_list|(
literal|2002
argument_list|)
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|QName
argument_list|,
name|String
argument_list|>
name|xAttrMap
init|=
name|x
operator|.
name|getOtherAttributes
argument_list|()
decl_stmt|;
name|xAttrMap
operator|.
name|put
argument_list|(
name|xAt1Name
argument_list|,
literal|"one"
argument_list|)
expr_stmt|;
name|xAttrMap
operator|.
name|put
argument_list|(
name|xAt2Name
argument_list|,
literal|"two"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|QName
argument_list|,
name|String
argument_list|>
name|yAttrMap
init|=
name|y
operator|.
name|getOtherAttributes
argument_list|()
decl_stmt|;
name|yAttrMap
operator|.
name|put
argument_list|(
name|yAt3Name
argument_list|,
literal|"three"
argument_list|)
expr_stmt|;
name|yAttrMap
operator|.
name|put
argument_list|(
name|yAt4Name
argument_list|,
literal|"four"
argument_list|)
expr_stmt|;
name|Holder
argument_list|<
name|OccuringStructWithAnyAttribute
argument_list|>
name|yh
init|=
operator|new
name|Holder
argument_list|<
name|OccuringStructWithAnyAttribute
argument_list|>
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|OccuringStructWithAnyAttribute
argument_list|>
name|zh
init|=
operator|new
name|Holder
argument_list|<
name|OccuringStructWithAnyAttribute
argument_list|>
argument_list|()
decl_stmt|;
name|OccuringStructWithAnyAttribute
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testOccuringStructWithAnyAttribute
argument_list|(
name|x
argument_list|,
name|yh
argument_list|,
name|zh
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testOccuringStructWithAnyAttribute
argument_list|(
name|x
argument_list|,
name|yh
argument_list|,
name|zh
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testOccuringStructWithAnyAttribute
argument_list|(
name|x
argument_list|,
name|yh
argument_list|,
name|zh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testOccuringStructWithAnyAttribute(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|yh
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testOccuringStructWithAnyAttribute(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|y
argument_list|,
name|zh
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testOccuringStructWithAnyAttribute(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|ret
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//org.apache.type_test.types2.OccuringChoiceWithAnyAttribute;
specifier|protected
name|boolean
name|equals
parameter_list|(
name|OccuringChoiceWithAnyAttribute
name|x
parameter_list|,
name|OccuringChoiceWithAnyAttribute
name|y
parameter_list|)
block|{
if|if
condition|(
operator|!
name|equalsNilable
argument_list|(
name|x
operator|.
name|getAtString
argument_list|()
argument_list|,
name|y
operator|.
name|getAtString
argument_list|()
argument_list|)
operator|||
operator|!
name|equalsNilable
argument_list|(
name|x
operator|.
name|getAtInt
argument_list|()
argument_list|,
name|y
operator|.
name|getAtInt
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|Serializable
argument_list|>
name|xList
init|=
name|x
operator|.
name|getVarStringOrVarInt
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Serializable
argument_list|>
name|yList
init|=
name|y
operator|.
name|getVarStringOrVarInt
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|equalsStringIntList
argument_list|(
name|xList
argument_list|,
name|yList
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|equalsQNameStringPairs
argument_list|(
name|x
operator|.
name|getOtherAttributes
argument_list|()
argument_list|,
name|y
operator|.
name|getOtherAttributes
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOccuringChoiceWithAnyAttribute
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"OccuringChoiceWithAnyAttribute"
argument_list|)
condition|)
block|{
return|return;
block|}
name|QName
name|xAt1Name
init|=
operator|new
name|QName
argument_list|(
literal|"http://schemas.iona.com/type_test"
argument_list|,
literal|"at_one"
argument_list|)
decl_stmt|;
name|QName
name|xAt2Name
init|=
operator|new
name|QName
argument_list|(
literal|"http://schemas.iona.com/type_test"
argument_list|,
literal|"at_two"
argument_list|)
decl_stmt|;
name|QName
name|yAt3Name
init|=
operator|new
name|QName
argument_list|(
literal|"http://apache.org/type_test"
argument_list|,
literal|"at_thr"
argument_list|)
decl_stmt|;
name|QName
name|yAt4Name
init|=
operator|new
name|QName
argument_list|(
literal|"http://apache.org/type_test"
argument_list|,
literal|"at_fou"
argument_list|)
decl_stmt|;
name|OccuringChoiceWithAnyAttribute
name|x
init|=
operator|new
name|OccuringChoiceWithAnyAttribute
argument_list|()
decl_stmt|;
name|OccuringChoiceWithAnyAttribute
name|y
init|=
operator|new
name|OccuringChoiceWithAnyAttribute
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Serializable
argument_list|>
name|xVarStringOrVarInt
init|=
name|x
operator|.
name|getVarStringOrVarInt
argument_list|()
decl_stmt|;
name|xVarStringOrVarInt
operator|.
name|add
argument_list|(
literal|"hello"
argument_list|)
expr_stmt|;
name|xVarStringOrVarInt
operator|.
name|add
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|x
operator|.
name|setAtString
argument_list|(
literal|"attribute"
argument_list|)
expr_stmt|;
name|x
operator|.
name|setAtInt
argument_list|(
operator|new
name|Integer
argument_list|(
literal|2000
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Serializable
argument_list|>
name|yVarStringOrVarInt
init|=
name|y
operator|.
name|getVarStringOrVarInt
argument_list|()
decl_stmt|;
name|yVarStringOrVarInt
operator|.
name|add
argument_list|(
literal|1001
argument_list|)
expr_stmt|;
name|y
operator|.
name|setAtString
argument_list|(
literal|"the attribute"
argument_list|)
expr_stmt|;
name|y
operator|.
name|setAtInt
argument_list|(
operator|new
name|Integer
argument_list|(
literal|2002
argument_list|)
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|QName
argument_list|,
name|String
argument_list|>
name|xAttrMap
init|=
name|x
operator|.
name|getOtherAttributes
argument_list|()
decl_stmt|;
name|xAttrMap
operator|.
name|put
argument_list|(
name|xAt1Name
argument_list|,
literal|"one"
argument_list|)
expr_stmt|;
name|xAttrMap
operator|.
name|put
argument_list|(
name|xAt2Name
argument_list|,
literal|"two"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|QName
argument_list|,
name|String
argument_list|>
name|yAttrMap
init|=
name|y
operator|.
name|getOtherAttributes
argument_list|()
decl_stmt|;
name|yAttrMap
operator|.
name|put
argument_list|(
name|yAt3Name
argument_list|,
literal|"three"
argument_list|)
expr_stmt|;
name|yAttrMap
operator|.
name|put
argument_list|(
name|yAt4Name
argument_list|,
literal|"four"
argument_list|)
expr_stmt|;
name|Holder
argument_list|<
name|OccuringChoiceWithAnyAttribute
argument_list|>
name|yh
init|=
operator|new
name|Holder
argument_list|<
name|OccuringChoiceWithAnyAttribute
argument_list|>
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|OccuringChoiceWithAnyAttribute
argument_list|>
name|zh
init|=
operator|new
name|Holder
argument_list|<
name|OccuringChoiceWithAnyAttribute
argument_list|>
argument_list|()
decl_stmt|;
name|OccuringChoiceWithAnyAttribute
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testOccuringChoiceWithAnyAttribute
argument_list|(
name|x
argument_list|,
name|yh
argument_list|,
name|zh
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testOccuringChoiceWithAnyAttribute
argument_list|(
name|x
argument_list|,
name|yh
argument_list|,
name|zh
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testOccuringChoiceWithAnyAttribute
argument_list|(
name|x
argument_list|,
name|yh
argument_list|,
name|zh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testOccuringChoiceWithAnyAttribute(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|yh
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testOccuringChoiceWithAnyAttribute(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|y
argument_list|,
name|zh
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testOccuringChoiceWithAnyAttribute(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|ret
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//org.apache.type_test.types3.MRecSeqA;
specifier|protected
name|boolean
name|equals
parameter_list|(
name|MRecSeqA
name|x
parameter_list|,
name|MRecSeqA
name|y
parameter_list|)
block|{
name|List
argument_list|<
name|MRecSeqB
argument_list|>
name|xList
init|=
name|x
operator|.
name|getSeqB
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|MRecSeqB
argument_list|>
name|yList
init|=
name|y
operator|.
name|getSeqB
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|xList
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|!=
name|yList
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|equals
argument_list|(
name|xList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|yList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
name|x
operator|.
name|getVarIntA
argument_list|()
operator|==
name|y
operator|.
name|getVarIntA
argument_list|()
return|;
block|}
specifier|protected
name|boolean
name|equals
parameter_list|(
name|MRecSeqB
name|x
parameter_list|,
name|MRecSeqB
name|y
parameter_list|)
block|{
return|return
name|x
operator|.
name|getVarIntB
argument_list|()
operator|==
name|y
operator|.
name|getVarIntB
argument_list|()
operator|&&
name|equals
argument_list|(
name|x
operator|.
name|getSeqA
argument_list|()
argument_list|,
name|y
operator|.
name|getSeqA
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMRecSeqA
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"MRecSeqA"
argument_list|)
condition|)
block|{
return|return;
block|}
name|MRecSeqA
name|xA
init|=
operator|new
name|MRecSeqA
argument_list|()
decl_stmt|;
name|MRecSeqA
name|yA
init|=
operator|new
name|MRecSeqA
argument_list|()
decl_stmt|;
name|MRecSeqA
name|zA
init|=
operator|new
name|MRecSeqA
argument_list|()
decl_stmt|;
name|MRecSeqB
name|xB
init|=
operator|new
name|MRecSeqB
argument_list|()
decl_stmt|;
name|MRecSeqB
name|yB
init|=
operator|new
name|MRecSeqB
argument_list|()
decl_stmt|;
name|xA
operator|.
name|setVarIntA
argument_list|(
literal|11
argument_list|)
expr_stmt|;
name|yA
operator|.
name|setVarIntA
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|zA
operator|.
name|setVarIntA
argument_list|(
literal|13
argument_list|)
expr_stmt|;
name|xB
operator|.
name|setVarIntB
argument_list|(
literal|21
argument_list|)
expr_stmt|;
name|yB
operator|.
name|setVarIntB
argument_list|(
literal|22
argument_list|)
expr_stmt|;
name|xB
operator|.
name|setSeqA
argument_list|(
name|yA
argument_list|)
expr_stmt|;
name|yB
operator|.
name|setSeqA
argument_list|(
name|zA
argument_list|)
expr_stmt|;
name|xA
operator|.
name|getSeqB
argument_list|()
operator|.
name|add
argument_list|(
name|xB
argument_list|)
expr_stmt|;
name|yA
operator|.
name|getSeqB
argument_list|()
operator|.
name|add
argument_list|(
name|yB
argument_list|)
expr_stmt|;
name|Holder
argument_list|<
name|MRecSeqA
argument_list|>
name|yh
init|=
operator|new
name|Holder
argument_list|<
name|MRecSeqA
argument_list|>
argument_list|(
name|yA
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|MRecSeqA
argument_list|>
name|zh
init|=
operator|new
name|Holder
argument_list|<
name|MRecSeqA
argument_list|>
argument_list|()
decl_stmt|;
name|MRecSeqA
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testMRecSeqA
argument_list|(
name|xA
argument_list|,
name|yh
argument_list|,
name|zh
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testMRecSeqA
argument_list|(
name|xA
argument_list|,
name|yh
argument_list|,
name|zh
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testMRecSeqA
argument_list|(
name|xA
argument_list|,
name|yh
argument_list|,
name|zh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"test_MRecSeqA(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|xA
argument_list|,
name|yh
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"test_MRecSeqA(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yA
argument_list|,
name|zh
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"test_MRecSeqA(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|ret
argument_list|,
name|xA
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//org.apache.type_test.types3.MRecSeqC;
specifier|protected
name|boolean
name|equals
parameter_list|(
name|MRecSeqC
name|x
parameter_list|,
name|MRecSeqC
name|y
parameter_list|)
block|{
return|return
name|x
operator|.
name|getVarIntC
argument_list|()
operator|==
name|y
operator|.
name|getVarIntC
argument_list|()
operator|&&
name|equals
argument_list|(
name|x
operator|.
name|getSeqDs
argument_list|()
argument_list|,
name|y
operator|.
name|getSeqDs
argument_list|()
argument_list|)
return|;
block|}
specifier|protected
name|boolean
name|equals
parameter_list|(
name|ArrayOfMRecSeqD
name|x
parameter_list|,
name|ArrayOfMRecSeqD
name|y
parameter_list|)
block|{
name|List
argument_list|<
name|MRecSeqD
argument_list|>
name|xList
init|=
name|x
operator|.
name|getSeqD
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|MRecSeqD
argument_list|>
name|yList
init|=
name|y
operator|.
name|getSeqD
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|xList
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|!=
name|yList
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|equals
argument_list|(
name|xList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|yList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|protected
name|boolean
name|equals
parameter_list|(
name|MRecSeqD
name|x
parameter_list|,
name|MRecSeqD
name|y
parameter_list|)
block|{
return|return
name|x
operator|.
name|getVarIntD
argument_list|()
operator|==
name|y
operator|.
name|getVarIntD
argument_list|()
operator|&&
name|equals
argument_list|(
name|x
operator|.
name|getSeqC
argument_list|()
argument_list|,
name|y
operator|.
name|getSeqC
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMRecSeqC
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"MRecSeqC"
argument_list|)
condition|)
block|{
return|return;
block|}
name|MRecSeqC
name|xC
init|=
operator|new
name|MRecSeqC
argument_list|()
decl_stmt|;
name|MRecSeqC
name|yC
init|=
operator|new
name|MRecSeqC
argument_list|()
decl_stmt|;
name|MRecSeqC
name|zC
init|=
operator|new
name|MRecSeqC
argument_list|()
decl_stmt|;
name|ArrayOfMRecSeqD
name|xDs
init|=
operator|new
name|ArrayOfMRecSeqD
argument_list|()
decl_stmt|;
name|ArrayOfMRecSeqD
name|yDs
init|=
operator|new
name|ArrayOfMRecSeqD
argument_list|()
decl_stmt|;
name|ArrayOfMRecSeqD
name|zDs
init|=
operator|new
name|ArrayOfMRecSeqD
argument_list|()
decl_stmt|;
name|MRecSeqD
name|xD
init|=
operator|new
name|MRecSeqD
argument_list|()
decl_stmt|;
name|MRecSeqD
name|yD
init|=
operator|new
name|MRecSeqD
argument_list|()
decl_stmt|;
name|xC
operator|.
name|setVarIntC
argument_list|(
literal|11
argument_list|)
expr_stmt|;
name|yC
operator|.
name|setVarIntC
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|zC
operator|.
name|setVarIntC
argument_list|(
literal|13
argument_list|)
expr_stmt|;
name|xD
operator|.
name|setVarIntD
argument_list|(
literal|21
argument_list|)
expr_stmt|;
name|yD
operator|.
name|setVarIntD
argument_list|(
literal|22
argument_list|)
expr_stmt|;
name|xDs
operator|.
name|getSeqD
argument_list|()
operator|.
name|add
argument_list|(
name|xD
argument_list|)
expr_stmt|;
name|yDs
operator|.
name|getSeqD
argument_list|()
operator|.
name|add
argument_list|(
name|yD
argument_list|)
expr_stmt|;
name|xC
operator|.
name|setSeqDs
argument_list|(
name|xDs
argument_list|)
expr_stmt|;
name|yC
operator|.
name|setSeqDs
argument_list|(
name|yDs
argument_list|)
expr_stmt|;
name|zC
operator|.
name|setSeqDs
argument_list|(
name|zDs
argument_list|)
expr_stmt|;
name|xD
operator|.
name|setSeqC
argument_list|(
name|yC
argument_list|)
expr_stmt|;
name|yD
operator|.
name|setSeqC
argument_list|(
name|zC
argument_list|)
expr_stmt|;
name|Holder
argument_list|<
name|MRecSeqC
argument_list|>
name|yh
init|=
operator|new
name|Holder
argument_list|<
name|MRecSeqC
argument_list|>
argument_list|(
name|yC
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|MRecSeqC
argument_list|>
name|zh
init|=
operator|new
name|Holder
argument_list|<
name|MRecSeqC
argument_list|>
argument_list|()
decl_stmt|;
name|MRecSeqC
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testMRecSeqC
argument_list|(
name|xC
argument_list|,
name|yh
argument_list|,
name|zh
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testMRecSeqC
argument_list|(
name|xC
argument_list|,
name|yh
argument_list|,
name|zh
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testMRecSeqC
argument_list|(
name|xC
argument_list|,
name|yh
argument_list|,
name|zh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"test_MRecSeqC(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|xC
argument_list|,
name|yh
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"test_MRecSeqC(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yC
argument_list|,
name|zh
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"test_MRecSeqC(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|ret
argument_list|,
name|xC
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//org.apache.type_test.types3.StructWithNillableChoice;
specifier|protected
name|boolean
name|equals
parameter_list|(
name|StructWithNillableChoice
name|x
parameter_list|,
name|StructWithNillableChoice
name|y
parameter_list|)
block|{
if|if
condition|(
name|x
operator|.
name|getVarInteger
argument_list|()
operator|!=
name|y
operator|.
name|getVarInteger
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|x
operator|.
name|getVarString
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|x
operator|.
name|getVarString
argument_list|()
operator|.
name|equals
argument_list|(
name|y
operator|.
name|getVarString
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|x
operator|.
name|getVarInt
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|x
operator|.
name|getVarInt
argument_list|()
operator|==
name|y
operator|.
name|getVarInt
argument_list|()
return|;
block|}
return|return
name|y
operator|.
name|getVarInt
argument_list|()
operator|==
literal|null
operator|&&
name|y
operator|.
name|getVarString
argument_list|()
operator|==
literal|null
return|;
block|}
specifier|protected
name|boolean
name|isNormalized
parameter_list|(
name|StructWithNillableChoice
name|x
parameter_list|)
block|{
return|return
name|x
operator|==
literal|null
operator|||
name|x
operator|.
name|getVarInt
argument_list|()
operator|==
literal|null
operator|&&
name|x
operator|.
name|getVarString
argument_list|()
operator|==
literal|null
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testStructWithNillableChoice
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"StructWithNillableChoice"
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Test 1
comment|//
comment|// x: non-nil choice
comment|// y: nil choice
comment|//
name|StructWithNillableChoice
name|x
init|=
operator|new
name|StructWithNillableChoice
argument_list|()
decl_stmt|;
name|x
operator|.
name|setVarInteger
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|x
operator|.
name|setVarInt
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|StructWithNillableChoice
name|yOriginal
init|=
operator|new
name|StructWithNillableChoice
argument_list|()
decl_stmt|;
name|yOriginal
operator|.
name|setVarInteger
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|Holder
argument_list|<
name|StructWithNillableChoice
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|StructWithNillableChoice
argument_list|>
argument_list|(
name|yOriginal
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|StructWithNillableChoice
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|StructWithNillableChoice
argument_list|>
argument_list|()
decl_stmt|;
name|StructWithNillableChoice
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testStructWithNillableChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testStructWithNillableChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testStructWithNillableChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testStructWithNillableChoice(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithNillableChoice(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOriginal
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithNillableChoice(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithNillableChoice(): Incorrect form for out param"
argument_list|,
name|isNormalized
argument_list|(
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Test 2
comment|//
comment|// x: nil choice
comment|// y: non-nil choice
comment|//
name|y
operator|=
operator|new
name|Holder
argument_list|<
name|StructWithNillableChoice
argument_list|>
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|yOriginal
expr_stmt|;
name|yOriginal
operator|=
name|y
operator|.
name|value
expr_stmt|;
name|z
operator|=
operator|new
name|Holder
argument_list|<
name|StructWithNillableChoice
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testStructWithNillableChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testStructWithNillableChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testStructWithNillableChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testStructWithNillableChoice(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithNillableChoice(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOriginal
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithNillableChoice(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithNillableChoice(): Incorrect form for inout param"
argument_list|,
name|isNormalized
argument_list|(
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithNillableChoice(): Incorrect return form"
argument_list|,
name|isNormalized
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//org.apache.type_test.types3.StructWithOccuringChoice;
specifier|protected
name|boolean
name|equals
parameter_list|(
name|StructWithOccuringChoice
name|x
parameter_list|,
name|StructWithOccuringChoice
name|y
parameter_list|)
block|{
if|if
condition|(
name|x
operator|.
name|getVarInteger
argument_list|()
operator|!=
name|y
operator|.
name|getVarInteger
argument_list|()
condition|)
block|{
name|fail
argument_list|(
name|x
operator|.
name|getVarInteger
argument_list|()
operator|+
literal|" != "
operator|+
name|y
operator|.
name|getVarInteger
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|Serializable
argument_list|>
name|xList
init|=
name|x
operator|.
name|getVarIntOrVarString
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Serializable
argument_list|>
name|yList
init|=
name|y
operator|.
name|getVarIntOrVarString
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|xList
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|!=
name|yList
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|Integer
operator|&&
name|yList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|Integer
condition|)
block|{
name|Integer
name|ix
init|=
operator|(
name|Integer
operator|)
name|xList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Integer
name|iy
init|=
operator|(
name|Integer
operator|)
name|yList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|iy
operator|.
name|compareTo
argument_list|(
name|ix
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|xList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|String
operator|&&
name|yList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|String
condition|)
block|{
name|String
name|sx
init|=
operator|(
name|String
operator|)
name|xList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|sy
init|=
operator|(
name|String
operator|)
name|yList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sx
operator|.
name|equals
argument_list|(
name|sy
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|protected
name|boolean
name|isNormalized
parameter_list|(
name|StructWithOccuringChoice
name|x
parameter_list|)
block|{
return|return
name|x
operator|==
literal|null
operator|||
name|x
operator|.
name|getVarIntOrVarString
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testStructWithOccuringChoice
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"StructWithOccuringChoice"
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Test 1
comment|//
comment|// x: choice occurs twice
comment|// y: choice doesn't occur
comment|//
name|StructWithOccuringChoice
name|x
init|=
operator|new
name|StructWithOccuringChoice
argument_list|()
decl_stmt|;
name|x
operator|.
name|setVarInteger
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|x
operator|.
name|getVarIntOrVarString
argument_list|()
operator|.
name|add
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|x
operator|.
name|getVarIntOrVarString
argument_list|()
operator|.
name|add
argument_list|(
literal|"hello"
argument_list|)
expr_stmt|;
name|StructWithOccuringChoice
name|yOriginal
init|=
operator|new
name|StructWithOccuringChoice
argument_list|()
decl_stmt|;
name|yOriginal
operator|.
name|setVarInteger
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|Holder
argument_list|<
name|StructWithOccuringChoice
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|StructWithOccuringChoice
argument_list|>
argument_list|(
name|yOriginal
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|StructWithOccuringChoice
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|StructWithOccuringChoice
argument_list|>
argument_list|()
decl_stmt|;
name|StructWithOccuringChoice
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testStructWithOccuringChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testStructWithOccuringChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testStructWithOccuringChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testStructWithOccuringChoice(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringChoice(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOriginal
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringChoice(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringChoice(): Incorrect form for out param"
argument_list|,
name|isNormalized
argument_list|(
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Test 2
comment|//
comment|// x: choice occurs twice
comment|// y: choice occurs once
comment|//
name|yOriginal
operator|.
name|getVarIntOrVarString
argument_list|()
operator|.
name|add
argument_list|(
literal|"world"
argument_list|)
expr_stmt|;
name|y
operator|=
operator|new
name|Holder
argument_list|<
name|StructWithOccuringChoice
argument_list|>
argument_list|(
name|yOriginal
argument_list|)
expr_stmt|;
name|z
operator|=
operator|new
name|Holder
argument_list|<
name|StructWithOccuringChoice
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testStructWithOccuringChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testStructWithOccuringChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testStructWithOccuringChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testStructWithOccuringChoice(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringChoice(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOriginal
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringChoice(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Test 3
comment|//
comment|// x: choice occurs once
comment|// y: choice occurs twice
comment|//
name|y
operator|=
operator|new
name|Holder
argument_list|<
name|StructWithOccuringChoice
argument_list|>
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|yOriginal
expr_stmt|;
name|yOriginal
operator|=
name|y
operator|.
name|value
expr_stmt|;
name|z
operator|=
operator|new
name|Holder
argument_list|<
name|StructWithOccuringChoice
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testStructWithOccuringChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testStructWithOccuringChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testStructWithOccuringChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testStructWithOccuringChoice(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringChoice(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOriginal
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringChoice(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Test 4
comment|//
comment|// x: choice doesn't occur
comment|// y: choice occurs twice
comment|//
name|x
operator|.
name|getVarIntOrVarString
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|y
operator|=
operator|new
name|Holder
argument_list|<
name|StructWithOccuringChoice
argument_list|>
argument_list|(
name|yOriginal
argument_list|)
expr_stmt|;
name|z
operator|=
operator|new
name|Holder
argument_list|<
name|StructWithOccuringChoice
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testStructWithOccuringChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testStructWithOccuringChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testStructWithOccuringChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testStructWithOccuringChoice(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringChoice(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOriginal
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringChoice(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringChoice(): Incorrect form for inout param"
argument_list|,
name|isNormalized
argument_list|(
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringChoice(): Incorrect return form"
argument_list|,
name|isNormalized
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//org.apache.type_test.types3.StructWithNillableStruct;
specifier|protected
name|boolean
name|equals
parameter_list|(
name|StructWithNillableStruct
name|x
parameter_list|,
name|StructWithNillableStruct
name|y
parameter_list|)
block|{
if|if
condition|(
name|x
operator|.
name|getVarInteger
argument_list|()
operator|!=
name|y
operator|.
name|getVarInteger
argument_list|()
condition|)
block|{
name|fail
argument_list|(
name|x
operator|.
name|getVarInteger
argument_list|()
operator|+
literal|" != "
operator|+
name|y
operator|.
name|getVarInteger
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|x
operator|.
name|getVarInt
argument_list|()
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|x
operator|.
name|getVarFloat
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
name|y
operator|.
name|getVarInt
argument_list|()
operator|==
literal|null
operator|&&
name|y
operator|.
name|getVarFloat
argument_list|()
operator|==
literal|null
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|x
operator|.
name|getVarFloat
argument_list|()
operator|==
literal|null
operator|||
name|y
operator|.
name|getVarInt
argument_list|()
operator|==
literal|null
operator|||
name|y
operator|.
name|getVarFloat
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
name|x
operator|.
name|getVarFloat
argument_list|()
operator|.
name|compareTo
argument_list|(
name|y
operator|.
name|getVarFloat
argument_list|()
argument_list|)
operator|==
literal|0
operator|&&
name|x
operator|.
name|getVarInt
argument_list|()
operator|==
name|y
operator|.
name|getVarInt
argument_list|()
return|;
block|}
specifier|protected
name|boolean
name|isNormalized
parameter_list|(
name|StructWithNillableStruct
name|x
parameter_list|)
block|{
return|return
name|x
operator|.
name|getVarInt
argument_list|()
operator|==
literal|null
operator|&&
name|x
operator|.
name|getVarFloat
argument_list|()
operator|==
literal|null
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testStructWithNillableStruct
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"StructWithNillableStruct"
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Test 1
comment|//
comment|// x: non-nil sequence
comment|// y: nil sequence (non-null holder object)
comment|//
name|StructWithNillableStruct
name|x
init|=
operator|new
name|StructWithNillableStruct
argument_list|()
decl_stmt|;
name|x
operator|.
name|setVarInteger
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|x
operator|.
name|setVarInt
argument_list|(
literal|101
argument_list|)
expr_stmt|;
name|x
operator|.
name|setVarFloat
argument_list|(
literal|101.5f
argument_list|)
expr_stmt|;
name|StructWithNillableStruct
name|yOriginal
init|=
operator|new
name|StructWithNillableStruct
argument_list|()
decl_stmt|;
name|yOriginal
operator|.
name|setVarInteger
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|Holder
argument_list|<
name|StructWithNillableStruct
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|StructWithNillableStruct
argument_list|>
argument_list|(
name|yOriginal
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|StructWithNillableStruct
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|StructWithNillableStruct
argument_list|>
argument_list|()
decl_stmt|;
name|StructWithNillableStruct
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testStructWithNillableStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testStructWithNillableStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testStructWithNillableStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testStructWithNillableStruct(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithNillableStruct(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOriginal
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithNillableStruct(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithNillableStruct(): Incorrect form for out param"
argument_list|,
name|isNormalized
argument_list|(
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Test 2
comment|//
comment|// x: non-nil sequence
comment|// y: nil sequence (null holder object)
comment|//
name|yOriginal
operator|.
name|setVarInt
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|yOriginal
operator|.
name|setVarFloat
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|y
operator|=
operator|new
name|Holder
argument_list|<
name|StructWithNillableStruct
argument_list|>
argument_list|(
name|yOriginal
argument_list|)
expr_stmt|;
name|z
operator|=
operator|new
name|Holder
argument_list|<
name|StructWithNillableStruct
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testStructWithNillableStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testStructWithNillableStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testStructWithNillableStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testStructWithNillableStruct(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithNillableStruct(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOriginal
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithNillableStruct(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithNillableStruct(): Incorrect form for out param"
argument_list|,
name|isNormalized
argument_list|(
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Test 3
comment|//
comment|// x: nil sequence (null holder object)
comment|// y: non-nil sequence
comment|//
name|y
operator|=
operator|new
name|Holder
argument_list|<
name|StructWithNillableStruct
argument_list|>
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|yOriginal
expr_stmt|;
name|yOriginal
operator|=
name|y
operator|.
name|value
expr_stmt|;
name|z
operator|=
operator|new
name|Holder
argument_list|<
name|StructWithNillableStruct
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testStructWithNillableStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testStructWithNillableStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testStructWithNillableStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testStructWithNillableStruct(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithNillableStruct(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOriginal
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithNillableStruct(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithNillableStruct(): Incorrect form for inout param"
argument_list|,
name|isNormalized
argument_list|(
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithNillableStruct(): Incorrect return form"
argument_list|,
name|isNormalized
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//org.apache.type_test.types3.StructWithOccuringStruct;
specifier|protected
name|boolean
name|equals
parameter_list|(
name|StructWithOccuringStruct
name|x
parameter_list|,
name|StructWithOccuringStruct
name|y
parameter_list|)
block|{
if|if
condition|(
name|x
operator|.
name|getVarInteger
argument_list|()
operator|!=
name|y
operator|.
name|getVarInteger
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|Comparable
argument_list|>
name|xList
init|=
name|x
operator|.
name|getVarIntAndVarFloat
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Comparable
argument_list|>
name|yList
init|=
name|y
operator|.
name|getVarIntAndVarFloat
argument_list|()
decl_stmt|;
name|int
name|xSize
init|=
operator|(
name|xList
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|xList
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|ySize
init|=
operator|(
name|yList
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|yList
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|xSize
operator|!=
name|ySize
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|xSize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|xList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|Integer
operator|&&
name|yList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|Integer
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|Integer
operator|)
name|xList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|compareTo
argument_list|(
operator|(
name|Integer
operator|)
name|yList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|xList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|Float
operator|&&
name|yList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|Float
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|Float
operator|)
name|xList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|compareTo
argument_list|(
operator|(
name|Float
operator|)
name|yList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|protected
name|boolean
name|isNormalized
parameter_list|(
name|StructWithOccuringStruct
name|x
parameter_list|)
block|{
return|return
name|x
operator|.
name|getVarIntAndVarFloat
argument_list|()
operator|!=
literal|null
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testStructWithOccuringStruct
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"StructWithOccuringStruct"
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Test 1
comment|//
comment|// x: sequence occurs twice
comment|// y: sequence doesn't occur (null holder object)
comment|//
name|StructWithOccuringStruct
name|x
init|=
operator|new
name|StructWithOccuringStruct
argument_list|()
decl_stmt|;
name|x
operator|.
name|setVarInteger
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|x
operator|.
name|getVarIntAndVarFloat
argument_list|()
operator|.
name|add
argument_list|(
literal|101
argument_list|)
expr_stmt|;
name|x
operator|.
name|getVarIntAndVarFloat
argument_list|()
operator|.
name|add
argument_list|(
literal|101.5f
argument_list|)
expr_stmt|;
name|x
operator|.
name|getVarIntAndVarFloat
argument_list|()
operator|.
name|add
argument_list|(
literal|102
argument_list|)
expr_stmt|;
name|x
operator|.
name|getVarIntAndVarFloat
argument_list|()
operator|.
name|add
argument_list|(
literal|102.5f
argument_list|)
expr_stmt|;
name|StructWithOccuringStruct
name|yOriginal
init|=
operator|new
name|StructWithOccuringStruct
argument_list|()
decl_stmt|;
name|yOriginal
operator|.
name|setVarInteger
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|Holder
argument_list|<
name|StructWithOccuringStruct
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|StructWithOccuringStruct
argument_list|>
argument_list|(
name|yOriginal
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|StructWithOccuringStruct
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|StructWithOccuringStruct
argument_list|>
argument_list|()
decl_stmt|;
name|StructWithOccuringStruct
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testStructWithOccuringStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testStructWithOccuringStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testStructWithOccuringStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testStructWithOccuringStruct(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringStruct(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOriginal
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringStruct(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringStruct(): Incorrect form for out param"
argument_list|,
name|isNormalized
argument_list|(
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Test 2
comment|//
comment|// x: sequence occurs twice
comment|// y: sequence occurs once
comment|//
name|yOriginal
operator|.
name|getVarIntAndVarFloat
argument_list|()
operator|.
name|add
argument_list|(
literal|201
argument_list|)
expr_stmt|;
name|yOriginal
operator|.
name|getVarIntAndVarFloat
argument_list|()
operator|.
name|add
argument_list|(
literal|202.5f
argument_list|)
expr_stmt|;
name|y
operator|=
operator|new
name|Holder
argument_list|<
name|StructWithOccuringStruct
argument_list|>
argument_list|(
name|yOriginal
argument_list|)
expr_stmt|;
name|z
operator|=
operator|new
name|Holder
argument_list|<
name|StructWithOccuringStruct
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testStructWithOccuringStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testStructWithOccuringStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testStructWithOccuringStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testStructWithOccuringStruct(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringStruct(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOriginal
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringStruct(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testStructWithOccuringStruct2
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"StructWithOccuringStruct2"
argument_list|)
condition|)
block|{
return|return;
block|}
name|StructWithOccuringStruct
name|x
init|=
operator|new
name|StructWithOccuringStruct
argument_list|()
decl_stmt|;
name|x
operator|.
name|setVarInteger
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|x
operator|.
name|getVarIntAndVarFloat
argument_list|()
operator|.
name|add
argument_list|(
literal|101
argument_list|)
expr_stmt|;
name|x
operator|.
name|getVarIntAndVarFloat
argument_list|()
operator|.
name|add
argument_list|(
literal|101.5f
argument_list|)
expr_stmt|;
name|x
operator|.
name|getVarIntAndVarFloat
argument_list|()
operator|.
name|add
argument_list|(
literal|102
argument_list|)
expr_stmt|;
name|x
operator|.
name|getVarIntAndVarFloat
argument_list|()
operator|.
name|add
argument_list|(
literal|102.5f
argument_list|)
expr_stmt|;
name|StructWithOccuringStruct
name|yOriginal
init|=
operator|new
name|StructWithOccuringStruct
argument_list|()
decl_stmt|;
name|yOriginal
operator|.
name|setVarInteger
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|Holder
argument_list|<
name|StructWithOccuringStruct
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|StructWithOccuringStruct
argument_list|>
argument_list|(
name|yOriginal
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|StructWithOccuringStruct
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|StructWithOccuringStruct
argument_list|>
argument_list|()
decl_stmt|;
name|StructWithOccuringStruct
name|ret
decl_stmt|;
comment|// Test 3
comment|//
comment|// x: sequence occurs once
comment|// y: sequence occurs twice
comment|//
name|y
operator|=
operator|new
name|Holder
argument_list|<
name|StructWithOccuringStruct
argument_list|>
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|yOriginal
expr_stmt|;
name|yOriginal
operator|=
name|y
operator|.
name|value
expr_stmt|;
name|z
operator|=
operator|new
name|Holder
argument_list|<
name|StructWithOccuringStruct
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testStructWithOccuringStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testStructWithOccuringStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testStructWithOccuringStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testStructWithOccuringStruct(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringStruct(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOriginal
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringStruct(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Test 4
comment|//
comment|// x: sequence doesn't occur (array of size 0)
comment|// y: sequence occurs twice
comment|//
name|x
operator|.
name|getVarIntAndVarFloat
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|y
operator|=
operator|new
name|Holder
argument_list|<
name|StructWithOccuringStruct
argument_list|>
argument_list|(
name|yOriginal
argument_list|)
expr_stmt|;
name|z
operator|=
operator|new
name|Holder
argument_list|<
name|StructWithOccuringStruct
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testStructWithOccuringStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testStructWithOccuringStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testStructWithOccuringStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testStructWithOccuringStruct(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringStruct(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOriginal
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringStruct(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringStruct(): Incorrect form for inout param"
argument_list|,
name|isNormalized
argument_list|(
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testStructWithOccuringStruct(): Incorrect return form"
argument_list|,
name|isNormalized
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//org.apache.type_test.types1.AnonymousType;
specifier|protected
name|boolean
name|equals
parameter_list|(
name|AnonymousType
name|x
parameter_list|,
name|AnonymousType
name|y
parameter_list|)
block|{
return|return
name|x
operator|.
name|getFoo
argument_list|()
operator|.
name|getFoo
argument_list|()
operator|.
name|equals
argument_list|(
name|y
operator|.
name|getFoo
argument_list|()
operator|.
name|getFoo
argument_list|()
argument_list|)
operator|&&
name|x
operator|.
name|getFoo
argument_list|()
operator|.
name|getBar
argument_list|()
operator|.
name|equals
argument_list|(
name|y
operator|.
name|getFoo
argument_list|()
operator|.
name|getBar
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAnonymousType
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"AnonymousType"
argument_list|)
condition|)
block|{
return|return;
block|}
name|AnonymousType
name|x
init|=
operator|new
name|AnonymousType
argument_list|()
decl_stmt|;
name|AnonymousType
operator|.
name|Foo
name|fx
init|=
operator|new
name|AnonymousType
operator|.
name|Foo
argument_list|()
decl_stmt|;
name|fx
operator|.
name|setFoo
argument_list|(
literal|"hello"
argument_list|)
expr_stmt|;
name|fx
operator|.
name|setBar
argument_list|(
literal|"there"
argument_list|)
expr_stmt|;
name|x
operator|.
name|setFoo
argument_list|(
name|fx
argument_list|)
expr_stmt|;
name|AnonymousType
name|yOrig
init|=
operator|new
name|AnonymousType
argument_list|()
decl_stmt|;
name|AnonymousType
operator|.
name|Foo
name|fy
init|=
operator|new
name|AnonymousType
operator|.
name|Foo
argument_list|()
decl_stmt|;
name|fy
operator|.
name|setFoo
argument_list|(
literal|"good"
argument_list|)
expr_stmt|;
name|fy
operator|.
name|setBar
argument_list|(
literal|"bye"
argument_list|)
expr_stmt|;
name|yOrig
operator|.
name|setFoo
argument_list|(
name|fy
argument_list|)
expr_stmt|;
name|Holder
argument_list|<
name|AnonymousType
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|AnonymousType
argument_list|>
argument_list|(
name|yOrig
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|AnonymousType
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|AnonymousType
argument_list|>
argument_list|()
decl_stmt|;
name|AnonymousType
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testAnonymousType
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testAnonymousType
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testAnonymousType
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testAnonymousType(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testAnonymousType(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOrig
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testAnonymousType(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//org.apache.type_test.types1.RecSeqB6918;
specifier|protected
name|boolean
name|equals
parameter_list|(
name|RecSeqB6918
name|x
parameter_list|,
name|RecSeqB6918
name|y
parameter_list|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|xList
init|=
name|x
operator|.
name|getNextSeqAndVarInt
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|yList
init|=
name|y
operator|.
name|getNextSeqAndVarInt
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|xList
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|!=
name|yList
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|xo
init|=
name|xList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Object
name|yo
init|=
name|yList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|xo
operator|instanceof
name|Integer
condition|)
block|{
if|if
condition|(
name|yo
operator|instanceof
name|Integer
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|Integer
operator|)
name|xo
operator|)
operator|.
name|compareTo
argument_list|(
operator|(
name|Integer
operator|)
name|yo
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|xo
operator|instanceof
name|RecSeqB6918
condition|)
block|{
if|if
condition|(
name|yo
operator|instanceof
name|RecSeqB6918
condition|)
block|{
return|return
name|equals
argument_list|(
operator|(
name|RecSeqB6918
operator|)
name|xo
argument_list|,
operator|(
name|RecSeqB6918
operator|)
name|yo
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRecSeqB6918
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"RecSeqB6918"
argument_list|)
condition|)
block|{
return|return;
block|}
name|RecSeqB6918
name|x
init|=
operator|new
name|RecSeqB6918
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|theList
init|=
name|x
operator|.
name|getNextSeqAndVarInt
argument_list|()
decl_stmt|;
name|theList
operator|.
name|add
argument_list|(
operator|new
name|Integer
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|theList
operator|.
name|add
argument_list|(
operator|new
name|RecSeqB6918
argument_list|()
argument_list|)
expr_stmt|;
name|theList
operator|.
name|add
argument_list|(
operator|new
name|Integer
argument_list|(
literal|42
argument_list|)
argument_list|)
expr_stmt|;
name|RecSeqB6918
name|yOrig
init|=
operator|new
name|RecSeqB6918
argument_list|()
decl_stmt|;
name|theList
operator|=
name|yOrig
operator|.
name|getNextSeqAndVarInt
argument_list|()
expr_stmt|;
name|theList
operator|.
name|add
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|theList
operator|.
name|add
argument_list|(
operator|new
name|Integer
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|Holder
argument_list|<
name|RecSeqB6918
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|RecSeqB6918
argument_list|>
argument_list|(
name|yOrig
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|RecSeqB6918
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|RecSeqB6918
argument_list|>
argument_list|()
decl_stmt|;
name|RecSeqB6918
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testRecSeqB6918
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testRecSeqB6918
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testRecSeqB6918
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testRecSeqB6918(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testRecSeqB6918(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOrig
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testRecSeqB6918(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* XXX - The DerivedChoiceBaseAll, DerivedStructBaseAll, DerivedAll* types      *  result in an error creating the Schema object:      *  cos-all-limited.1.2: An 'all' model group must appear in a particle with      *  {min occurs} = {max occurs} = 1, and that particle must be part of a      *  pair which constitutes the {content type} of a complex type definition.      *           //org.apache.type_test.types1.ComplexArray           protected boolean equals(ComplexArray x, ComplexArray y) {         List<DerivedAllBaseStruct> xx = x.getVarDerivedItem();         List<DerivedAllBaseStruct> yy = y.getVarDerivedItem();         if (xx.size() != yy.size()) {             return false;         }         for (int i = 0; i< xx.size(); i++) {             if (!equals(xx.get(i), yy.get(i))) {                 return false;             }         }         return true;     }      @Test     @Ignore     public void testComplexArray() throws Exception {         if (!shouldRunTest("ComplexArray")) {             return;         }         DerivedChoiceBaseStruct xx = new DerivedChoiceBaseStruct();         //Base         xx.setVarFloat(3.14f);         xx.setVarInt(new BigInteger("42"));         xx.setVarString("BaseStruct-x");         xx.setVarAttrString("BaseStructAttr-x");         //Derived         xx.setVarFloatExt(-3.14f);         xx.setVarStringExt("DerivedAll-x");         xx.setAttrString("DerivedAttr-x");          DerivedAllBaseStruct yy = new DerivedAllBaseStruct();         //Base         yy.setVarFloat(-9.14f);         yy.setVarInt(new BigInteger("10"));         yy.setVarString("BaseStruct-y");         yy.setVarAttrString("BaseStructAttr-y");         //Derived         yy.setVarFloatExt(1.414f);         yy.setVarStringExt("DerivedAll-y");         yy.setAttrString("DerivedAttr-y");          ComplexArray x = new ComplexArray();         x.getVarDerivedItem().add(xx);         x.getVarDerivedItem().add(yy);          ComplexArray yOrig = new ComplexArray();         yOrig.getVarDerivedItem().add(yy);          Holder<ComplexArray> y = new Holder<ComplexArray>(yOrig);         Holder<ComplexArray> z = new Holder<ComplexArray>();         ComplexArray ret;         if (testDocLiteral) {             ret = docClient.testComplexArray(x, y, z);         } else {             ret = rpcClient.testComplexArray(x, y, z);         }          if (!perfTestOnly) {             assertTrue("testComplexArray(): Incorrect value for inout param",                        equals(x, y.value));             assertTrue("testComplexArray(): Incorrect value for out param",                        equals(yOrig, z.value));             assertTrue("testComplexArray(): Incorrect return value", equals(ret, x));         }     }          //org.apache.type_test.types1.ComplexChoice      protected boolean equals(ComplexChoice x, ComplexChoice y) {         DerivedChoiceBaseComplex xx = x.getVarDerivedStruct();         DerivedChoiceBaseComplex yy = y.getVarDerivedStruct();         return (xx != null&& yy != null&& equals(xx, yy))             || (x.getVarFloat() != null&& y.getVarFloat() != null&& x.getVarFloat().compareTo(y.getVarFloat()) == 0);     }      public void testComplexChoice() throws Exception {         if (!shouldRunTest("ComplexChoice")) {             return;         }         DerivedChoiceBaseComplex xx = new DerivedChoiceBaseComplex();         //Base (Sequence)         xx.setVarFloat(3.14f);         xx.setVarInt(new BigInteger("42"));         xx.setVarString("BaseSequence-x");         xx.setVarAttrString("BaseStructAttr-x");         //Derived (All)         xx.setVarFloatExt(-3.14f);         xx.setVarStringExt("DerivedAll-x");         xx.setAttrString("DerivedAttr-x");         //Most Derived (Choice)         xx.setVarStringExtExt("MostDerivedChoice-x");         xx.setAttrStringExtExt("MostDerivedAttr-x");          ComplexChoice x = new ComplexChoice();         x.setVarDerivedStruct(xx);          ComplexChoice yOrig = new ComplexChoice();         yOrig.setVarFloat(10.14f);          Holder<ComplexChoice> y = new Holder<ComplexChoice>(yOrig);         Holder<ComplexChoice> z = new Holder<ComplexChoice>();         ComplexChoice ret;         if (testDocLiteral) {             ret = docClient.testComplexChoice(x, y, z);         } else {             ret = rpcClient.testComplexChoice(x, y, z);         }          if (!perfTestOnly) {             assertTrue("testComplexChoice(): Incorrect value for inout param",                        equals(x, y.value));             assertTrue("testComplexChoice(): Incorrect value for out param",                        equals(yOrig, z.value));             assertTrue("testComplexChoice(): Incorrect return value", equals(ret, x));         }     }      //org.apache.type_test.types1.ComplexStruct      protected boolean equals(ComplexStruct x, ComplexStruct y) {         return equals(x.getVarDerivedStruct(), y.getVarDerivedStruct())&& Float.compare(x.getVarFloat(), y.getVarFloat()) == 0;     }      public void testComplexStruct() throws Exception {         if (!shouldRunTest("ComplexStruct")) {             return;         }         DerivedChoiceBaseComplex xx = new DerivedChoiceBaseComplex();         //Base (Sequence)         xx.setVarFloat(3.14f);         xx.setVarInt(new BigInteger("42"));         xx.setVarString("BaseSequence-x");         xx.setVarAttrString("BaseStructAttr-x");         //Derived (All)         xx.setVarFloatExt(-3.14f);         xx.setVarStringExt("DerivedAll-x");         xx.setAttrString("DerivedAttr-x");         //Most Derived (Choice)         xx.setVarStringExtExt("MostDerivedChoice-x");         xx.setAttrStringExtExt("MostDerivedAttr-x");          ComplexStruct x = new ComplexStruct();         x.setVarFloat(30.14f);         x.setVarDerivedStruct(xx);          DerivedChoiceBaseComplex yy = new DerivedChoiceBaseComplex();         //Base         yy.setVarFloat(-9.14f);         yy.setVarInt(new BigInteger("10"));         yy.setVarString("BaseSequence-y");         yy.setVarAttrString("BaseStructAttr-y");         //Derived         yy.setVarFloatExt(1.414f);         yy.setVarStringExt("DerivedAll-y");         yy.setAttrString("DerivedAttr-y");         //Most Derived         yy.setVarFloatExtExt(19.144f);         yy.setAttrStringExtExt("MostDerivedAttr-y");          ComplexStruct yOrig = new ComplexStruct();         yOrig.setVarFloat(10.14f);         yOrig.setVarDerivedStruct(yy);          Holder<ComplexStruct> y = new Holder<ComplexStruct>(yOrig);         Holder<ComplexStruct> z = new Holder<ComplexStruct>();         ComplexStruct ret;         if (testDocLiteral) {             ret = docClient.testComplexStruct(x, y, z);         } else {             ret = rpcClient.testComplexStruct(x, y, z);         }          if (!perfTestOnly) {             assertTrue("testComplexStruct(): Incorrect value for inout param",                        equals(x, y.value));             assertTrue("testComplexStruct(): Incorrect value for out param",                        equals(yOrig, z.value));             assertTrue("testComplexStruct(): Incorrect return value", equals(ret, x));         }     }          //org.apache.type_test.types1.DerivedChoiceBaseComplex      protected boolean equals(DerivedChoiceBaseComplex x, DerivedChoiceBaseComplex y) {         return equals((DerivedAllBaseStruct)x, (DerivedAllBaseStruct)y)&& ((x.getVarStringExtExt() != null&& y.getVarStringExtExt() != null&& x.getVarStringExtExt().equals(y.getVarStringExtExt()))             || (x.getVarFloatExtExt() != null&& y.getVarFloatExtExt() != null&& x.getVarFloatExtExt().compareTo(y.getVarFloatExtExt()) == 0));     }      public void testDerivedChoiceBaseComplex() throws Exception {         if (!shouldRunTest("DerivedChoiceBaseComplex")) {             return;         }         DerivedChoiceBaseComplex x = new DerivedChoiceBaseComplex();         //Base (Sequence)         x.setVarFloat(3.14f);         x.setVarInt(new BigInteger("42"));         x.setVarString("BaseSequence-x");         x.setVarAttrString("BaseStructAttr-x");         //Derived (All)         x.setVarFloatExt(-3.14f);         x.setVarStringExt("DerivedAll-x");         x.setAttrString("DerivedAttr-x");         //Most Derived (Choice)         x.setVarStringExtExt("MostDerivedChoice-x");         x.setAttrStringExtExt("MostDerivedAttr-x");          DerivedChoiceBaseComplex yOrig = new DerivedChoiceBaseComplex();         //Base         yOrig.setVarFloat(-9.14f);         yOrig.setVarInt(new BigInteger("10"));         yOrig.setVarString("BaseSequence-y");         yOrig.setVarAttrString("BaseStructAttr-y");         //Derived         yOrig.setVarFloatExt(1.414f);         yOrig.setVarStringExt("DerivedAll-y");         yOrig.setAttrString("DerivedAttr-y");         //Most Derived         yOrig.setVarFloatExtExt(19.144f);         yOrig.setAttrStringExtExt("MostDerivedAttr-y");          Holder<DerivedChoiceBaseComplex> y = new Holder<DerivedChoiceBaseComplex>(yOrig);         Holder<DerivedChoiceBaseComplex> z = new Holder<DerivedChoiceBaseComplex>();         DerivedChoiceBaseComplex ret;         if (testDocLiteral) {             ret = docClient.testDerivedChoiceBaseComplex(x, y, z);         } else {             ret = rpcClient.testDerivedChoiceBaseComplex(x, y, z);         }          if (!perfTestOnly) {             assertTrue("testDerivedChoiceBaseComplex(): Incorrect value for inout param",                        equals(x, y.value));             assertTrue("testDerivedChoiceBaseComplex(): Incorrect value for out param",                        equals(yOrig, z.value));             assertTrue("testDerivedChoiceBaseComplex(): Incorrect return value", equals(x, ret));         }     }          //org.apache.type_test.types1.DerivedAllBaseAll      protected boolean equals(DerivedAllBaseAll x, DerivedAllBaseAll y) {         return equals((SimpleAll)x, (SimpleAll)y)&& (Float.compare(x.getVarFloatExt(), y.getVarFloatExt()) == 0)&& (x.getVarStringExt().equals(y.getVarStringExt()))&& (x.getAttrString().equals(y.getAttrString()));     }      public void testDerivedAllBaseAll() throws Exception {         if (!shouldRunTest("DerivedAllBaseAll")) {             return;         }         DerivedAllBaseAll x = new DerivedAllBaseAll();         //Base         x.setVarFloat(3.14f);         x.setVarInt(42);         x.setVarString("BaseAll-x");         x.setVarAttrString("BaseAllAttr-x");         //Derived         x.setVarFloatExt(-3.14f);         x.setVarStringExt("DerivedAll-x");         x.setAttrString("DerivedAttr-x");          DerivedAllBaseAll yOrig = new DerivedAllBaseAll();         //Base         yOrig.setVarFloat(-9.14f);         yOrig.setVarInt(10);         yOrig.setVarString("BaseAll-y");         yOrig.setVarAttrString("BaseAllAttr-y");         //Derived         yOrig.setVarFloatExt(1.414f);         yOrig.setVarStringExt("DerivedAll-y");         yOrig.setAttrString("DerivedAttr-y");          Holder<DerivedAllBaseAll> y = new Holder<DerivedAllBaseAll>(yOrig);         Holder<DerivedAllBaseAll> z = new Holder<DerivedAllBaseAll>();          DerivedAllBaseAll ret;         if (testDocLiteral) {             ret = docClient.testDerivedAllBaseAll(x, y, z);         } else {             ret = rpcClient.testDerivedAllBaseAll(x, y, z);         }         if (!perfTestOnly) {             assertTrue("testDerivedAllBaseAll(): Incorrect value for inout param",                        equals(x, y.value));             assertTrue("testDerivedAllBaseAll(): Incorrect value for out param",                        equals(yOrig, z.value));             assertTrue("testDerivedAllBaseAll(): Incorrect return value", equals(x, ret));         }     }          //org.apache.type_test.types1.DerivedAllBaseChoice      protected boolean equals(DerivedAllBaseChoice x, DerivedAllBaseChoice y) {         return equals((SimpleChoice)x, (SimpleChoice)y)&& Float.compare(x.getVarFloatExt(), y.getVarFloatExt()) == 0&& x.getVarStringExt().equals(y.getVarStringExt())&& x.getAttrString().equals(y.getAttrString());     }      public void testDerivedAllBaseChoice() throws Exception {         if (!shouldRunTest("DerivedAllBaseChoice")) {             return;         }         DerivedAllBaseChoice x = new DerivedAllBaseChoice();         //Base         x.setVarString("BaseChoice-x");         //Derived         x.setVarFloatExt(-3.14f);         x.setVarStringExt("DerivedAll-x");         x.setAttrString("DerivedAttr-x");          DerivedAllBaseChoice yOrig = new DerivedAllBaseChoice();         //Base         yOrig.setVarFloat(-9.14f);         //Derived         yOrig.setVarFloatExt(1.414f);         yOrig.setVarStringExt("DerivedAll-y");         yOrig.setAttrString("DerivedAttr-y");          Holder<DerivedAllBaseChoice> y = new Holder<DerivedAllBaseChoice>(yOrig);         Holder<DerivedAllBaseChoice> z = new Holder<DerivedAllBaseChoice>();          DerivedAllBaseChoice ret;         if (testDocLiteral) {             ret = docClient.testDerivedAllBaseChoice(x, y, z);         } else {             ret = rpcClient.testDerivedAllBaseChoice(x, y, z);         }         if (!perfTestOnly) {             assertTrue("testDerivedAllBaseChoice(): Incorrect value for inout param",                        equals(x, y.value));             assertTrue("testDerivedAllBaseChoice(): Incorrect value for out param",                        equals(yOrig, z.value));             assertTrue("testDerivedAllBaseChoice(): Incorrect return value", equals(x, ret));         }     }          //org.apache.type_test.types1.DerivedAllBaseStruct      protected boolean equals(DerivedAllBaseStruct x, DerivedAllBaseStruct y) {         return equals((SimpleStruct)x, (SimpleStruct)y)&& (x.getVarFloatExt() == y.getVarFloatExt())&& (x.getVarStringExt().equals(y.getVarStringExt()))&& (x.getAttrString().equals(y.getAttrString()));     }      public void testDerivedAllBaseStruct() throws Exception {         if (!shouldRunTest("DerivedAllBaseStruct")) {             return;         }         DerivedAllBaseStruct x = new DerivedAllBaseStruct();         //Base         x.setVarFloat(3.14f);         x.setVarInt(new BigInteger("42"));         x.setVarString("BaseStruct-x");         x.setVarAttrString("BaseStructAttr-x");         //Derived         x.setVarFloatExt(-3.14f);         x.setVarStringExt("DerivedAll-x");         x.setAttrString("DerivedAttr-x");          DerivedAllBaseStruct yOrig = new DerivedAllBaseStruct();         //Base         yOrig.setVarFloat(-9.14f);         yOrig.setVarInt(new BigInteger("10"));         yOrig.setVarString("BaseStruct-y");         yOrig.setVarAttrString("BaseStructAttr-y");         //Derived         yOrig.setVarFloatExt(1.414f);         yOrig.setVarStringExt("DerivedAll-y");         yOrig.setAttrString("DerivedAttr-y");          Holder<DerivedAllBaseStruct> y = new Holder<DerivedAllBaseStruct>(yOrig);         Holder<DerivedAllBaseStruct> z = new Holder<DerivedAllBaseStruct>();          DerivedAllBaseStruct ret;         if (testDocLiteral) {             ret = docClient.testDerivedAllBaseStruct(x, y, z);         } else {             ret = rpcClient.testDerivedAllBaseStruct(x, y, z);         }         if (!perfTestOnly) {             assertTrue("testDerivedAllBaseStruct(): Incorrect value for inout param",                        equals(x, y.value));             assertTrue("testDerivedAllBaseStruct(): Incorrect value for out param",                        equals(yOrig, z.value));             assertTrue("testDerivedAllBaseStruct(): Incorrect return value",                        equals(x, ret));         }     }           //org.apache.type_test.types1.DerivedChoiceBaseAll      protected boolean equals(DerivedChoiceBaseAll x, DerivedChoiceBaseAll y) {         if (x.getVarStringExt() != null&& y.getVarStringExt() != null&& !x.getVarStringExt().equals(y.getVarStringExt())) {             return false;         } else if (x.getVarFloatExt() != null&& y.getVarFloatExt() != null&& x.getVarFloatExt().compareTo(y.getVarFloatExt()) != 0) {             return false;         }         return equals((SimpleAll)x, (SimpleAll)y)&& x.getAttrString().equals(y.getAttrString());     }      public void testDerivedChoiceBaseAll() throws Exception {         if (!shouldRunTest("DerivedChoiceBaseAll")) {             return;         }         DerivedChoiceBaseAll x = new DerivedChoiceBaseAll();         //Base         x.setVarFloat(3.14f);         x.setVarInt(42);         x.setVarString("BaseAll-x");         x.setVarAttrString("BaseAllAttr-x");         //Derived         x.setVarStringExt("DerivedChoice-x");         x.setAttrString("DerivedAttr-x");          DerivedChoiceBaseAll yOrig = new DerivedChoiceBaseAll();         //Base         yOrig.setVarFloat(-9.14f);         yOrig.setVarInt(10);         yOrig.setVarString("BaseAll-y");         yOrig.setVarAttrString("BaseAllAttr-y");         //Derived         yOrig.setVarFloatExt(1.414f);         yOrig.setAttrString("DerivedAttr-y");          Holder<DerivedChoiceBaseAll> y = new Holder<DerivedChoiceBaseAll>(yOrig);         Holder<DerivedChoiceBaseAll> z = new Holder<DerivedChoiceBaseAll>();          DerivedChoiceBaseAll ret;         if (testDocLiteral) {             ret = docClient.testDerivedChoiceBaseAll(x, y, z);         } else {             ret = rpcClient.testDerivedChoiceBaseAll(x, y, z);         }         if (!perfTestOnly) {             assertTrue("testDerivedChoiceBaseAll(): Incorrect value for inout param",                        equals(x, y.value));             assertTrue("testDerivedChoiceBaseAll(): Incorrect value for out param",                        equals(yOrig, z.value));             assertTrue("testDerivedChoiceBaseAll(): Incorrect return value", equals(x, ret));         }     }          //org.apache.type_test.types1.DerivedStructBaseAll      protected boolean equals(DerivedStructBaseAll x, DerivedStructBaseAll y) {         return equals((SimpleAll)x, (SimpleAll)y)&& (Float.compare(x.getVarFloatExt(), y.getVarFloatExt()) == 0)&& (x.getVarStringExt().equals(y.getVarStringExt()))&& (x.getAttrString().equals(y.getAttrString()));     }      public void testDerivedStructBaseAll() throws Exception {         if (!shouldRunTest("DerivedStructBaseAll")) {             return;         }         DerivedStructBaseAll x = new DerivedStructBaseAll();         //Base         x.setVarFloat(3.14f);         x.setVarInt(42);         x.setVarString("BaseAll-x");         x.setVarAttrString("BaseAllAttr-x");         //Derived         x.setVarFloatExt(-3.14f);         x.setVarStringExt("DerivedStruct-x");         x.setAttrString("DerivedAttr-x");          DerivedStructBaseAll yOrig = new DerivedStructBaseAll();         //Base         yOrig.setVarFloat(-9.14f);         yOrig.setVarInt(10);         yOrig.setVarString("BaseAll-y");         yOrig.setVarAttrString("BaseAllAttr-y");         //Derived         yOrig.setVarFloatExt(1.414f);         yOrig.setVarStringExt("DerivedStruct-y");         yOrig.setAttrString("DerivedAttr-y");          Holder<DerivedStructBaseAll> y = new Holder<DerivedStructBaseAll>(yOrig);         Holder<DerivedStructBaseAll> z = new Holder<DerivedStructBaseAll>();          DerivedStructBaseAll ret;         if (testDocLiteral) {             ret = docClient.testDerivedStructBaseAll(x, y, z);         } else {             ret = rpcClient.testDerivedStructBaseAll(x, y, z);         }         if (!perfTestOnly) {             assertTrue("testDerivedStructBaseAll(): Incorrect value for inout param",                        equals(x, y.value));             assertTrue("testDerivedStructBaseAll(): Incorrect value for out param",                        equals(yOrig, z.value));             assertTrue("testDerivedStructBaseAll(): Incorrect return value", equals(x, ret));         }     }      //org.apache.type_test.types1.DerivedChoiceBaseSimpleContent      protected void equals(String msg, DerivedChoiceBaseSimpleContent x,             DerivedChoiceBaseSimpleContent y) throws Exception {         equals(msg, (Document)x, (Document)y);         assertEquals(msg, x.getAttrStringExt(), y.getAttrStringExt());         if (x.getVarStringExt() != null) {             assertNotNull(msg, y.getVarStringExt());                            assertEquals(msg, x.getVarStringExt(), y.getVarStringExt());             assertTrue(msg, x.getVarFloatExt() == y.getVarFloatExt());         }     }      public void testDerivedChoiceBaseSimpleContent() throws Exception {         if (!shouldRunTest("DerivedChoiceBaseSimpleContent")) {             return;         }         DerivedChoiceBaseSimpleContent x = new DerivedChoiceBaseSimpleContent();         //Base         x.setID("Base-x");         x.setValue("BART");         //Derived         x.setVarStringExt("DerivedChoice-x");         x.setAttrStringExt("DerivedAttr-x");          DerivedChoiceBaseSimpleContent yOrig = new DerivedChoiceBaseSimpleContent();         //Base         yOrig.setID("Base-y");         yOrig.setValue("LISA");         //Derived         yOrig.setVarFloatExt(1.414f);         yOrig.setAttrStringExt("DerivedAttr-y");          Holder<DerivedChoiceBaseSimpleContent> y = new Holder<DerivedChoiceBaseSimpleContent>(yOrig);         Holder<DerivedChoiceBaseSimpleContent> z = new Holder<DerivedChoiceBaseSimpleContent>();          DerivedChoiceBaseSimpleContent ret;         if (testDocLiteral) {             ret = docClient.testDerivedChoiceBaseSimpleContent(x, y, z);         } else {             ret = rpcClient.testDerivedChoiceBaseSimpleContent(x, y, z);         }         if (!perfTestOnly) {             equals("testDerivedChoiceBaseSimpleContent(): Incorrect value for inout param", x, y.value);             equals("testDerivedChoiceBaseSimpleContent(): Incorrect value for out param", yOrig, z.value);             equals("testDerivedChoiceBaseSimpleContent(): Incorrect return value", x, ret);         }     }     */
comment|//org.apache.type_test.types1.RestrictedStructBaseStruct;
specifier|protected
name|boolean
name|equals
parameter_list|(
name|RestrictedStructBaseStruct
name|x
parameter_list|,
name|RestrictedStructBaseStruct
name|y
parameter_list|)
block|{
return|return
operator|(
name|x
operator|.
name|getVarFloat
argument_list|()
operator|==
name|y
operator|.
name|getVarFloat
argument_list|()
operator|)
operator|&&
operator|(
name|x
operator|.
name|getVarInt
argument_list|()
operator|.
name|equals
argument_list|(
name|y
operator|.
name|getVarInt
argument_list|()
argument_list|)
operator|)
operator|&&
operator|(
name|x
operator|.
name|getVarAttrString
argument_list|()
operator|.
name|equals
argument_list|(
name|y
operator|.
name|getVarAttrString
argument_list|()
argument_list|)
operator|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRestrictedStructBaseStruct
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"RestrictedStructBaseStruct"
argument_list|)
condition|)
block|{
return|return;
block|}
name|RestrictedStructBaseStruct
name|x
init|=
operator|new
name|RestrictedStructBaseStruct
argument_list|()
decl_stmt|;
name|x
operator|.
name|setVarFloat
argument_list|(
literal|3.14f
argument_list|)
expr_stmt|;
name|x
operator|.
name|setVarInt
argument_list|(
operator|new
name|BigInteger
argument_list|(
literal|"42"
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|.
name|setVarAttrString
argument_list|(
literal|"BaseStructAttr-x"
argument_list|)
expr_stmt|;
name|RestrictedStructBaseStruct
name|yOrig
init|=
operator|new
name|RestrictedStructBaseStruct
argument_list|()
decl_stmt|;
name|yOrig
operator|.
name|setVarFloat
argument_list|(
operator|-
literal|9.14f
argument_list|)
expr_stmt|;
name|yOrig
operator|.
name|setVarInt
argument_list|(
operator|new
name|BigInteger
argument_list|(
literal|"10"
argument_list|)
argument_list|)
expr_stmt|;
name|yOrig
operator|.
name|setVarAttrString
argument_list|(
literal|"BaseStructAttr-y"
argument_list|)
expr_stmt|;
name|Holder
argument_list|<
name|RestrictedStructBaseStruct
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|RestrictedStructBaseStruct
argument_list|>
argument_list|(
name|yOrig
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|RestrictedStructBaseStruct
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|RestrictedStructBaseStruct
argument_list|>
argument_list|()
decl_stmt|;
name|RestrictedStructBaseStruct
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testRestrictedStructBaseStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testRestrictedStructBaseStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testRestrictedStructBaseStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testRestrictedStructBaseStruct(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testRestrictedStructBaseStruct(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOrig
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testRestrictedStructBaseStruct(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//org.apache.type_test.types1.RestrictedAllBaseAll;
specifier|protected
name|boolean
name|equals
parameter_list|(
name|RestrictedAllBaseAll
name|x
parameter_list|,
name|RestrictedAllBaseAll
name|y
parameter_list|)
block|{
return|return
operator|(
name|x
operator|.
name|getVarFloat
argument_list|()
operator|==
name|y
operator|.
name|getVarFloat
argument_list|()
operator|)
operator|&&
operator|(
name|x
operator|.
name|getVarInt
argument_list|()
operator|==
name|y
operator|.
name|getVarInt
argument_list|()
operator|)
operator|&&
operator|(
name|x
operator|.
name|getVarAttrString
argument_list|()
operator|.
name|equals
argument_list|(
name|y
operator|.
name|getVarAttrString
argument_list|()
argument_list|)
operator|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRestrictedAllBaseAll
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"RestrictedAllBaseAll"
argument_list|)
condition|)
block|{
return|return;
block|}
name|RestrictedAllBaseAll
name|x
init|=
operator|new
name|RestrictedAllBaseAll
argument_list|()
decl_stmt|;
name|x
operator|.
name|setVarFloat
argument_list|(
literal|3.14f
argument_list|)
expr_stmt|;
name|x
operator|.
name|setVarInt
argument_list|(
literal|42
argument_list|)
expr_stmt|;
name|x
operator|.
name|setVarAttrString
argument_list|(
literal|"BaseAllAttr-x"
argument_list|)
expr_stmt|;
name|RestrictedAllBaseAll
name|yOrig
init|=
operator|new
name|RestrictedAllBaseAll
argument_list|()
decl_stmt|;
name|yOrig
operator|.
name|setVarFloat
argument_list|(
operator|-
literal|9.14f
argument_list|)
expr_stmt|;
name|yOrig
operator|.
name|setVarInt
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|yOrig
operator|.
name|setVarAttrString
argument_list|(
literal|"BaseAllAttr-y"
argument_list|)
expr_stmt|;
name|Holder
argument_list|<
name|RestrictedAllBaseAll
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|RestrictedAllBaseAll
argument_list|>
argument_list|(
name|yOrig
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|RestrictedAllBaseAll
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|RestrictedAllBaseAll
argument_list|>
argument_list|()
decl_stmt|;
name|RestrictedAllBaseAll
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testRestrictedAllBaseAll
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testRestrictedAllBaseAll
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testRestrictedAllBaseAll
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testRestrictedAllBaseAll(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testRestrictedAllBaseAll(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOrig
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testRestrictedAllBaseAll(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//org.apache.type_test.types1.UnionWithStringList;
annotation|@
name|Test
specifier|public
name|void
name|testUnionWithStringList
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"UnionWithStringList"
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|testDocLiteral
operator|||
name|testXMLBinding
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|x
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"5"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|yOrig
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"I"
argument_list|,
literal|"am"
argument_list|,
literal|"SimpleList"
argument_list|)
decl_stmt|;
comment|// Invoke testUnionWithStringList
name|Holder
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|(
name|yOrig
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|ret
init|=
name|testDocLiteral
condition|?
name|docClient
operator|.
name|testUnionWithStringList
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
else|:
name|xmlClient
operator|.
name|testUnionWithStringList
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertEquals
argument_list|(
literal|"testUnionWithStringList(): Incorrect value for inout param"
argument_list|,
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"testUnionWithStringList(): Incorrect value for out param"
argument_list|,
name|yOrig
argument_list|,
name|z
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"testUnionWithStringList(): Incorrect return value"
argument_list|,
name|x
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
index|[]
name|x
init|=
block|{
literal|"5"
block|}
decl_stmt|;
name|String
index|[]
name|yOrig
init|=
block|{
literal|"I"
block|,
literal|"am"
block|,
literal|"SimpleList"
block|}
decl_stmt|;
name|Holder
argument_list|<
name|String
index|[]
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|String
index|[]
argument_list|>
argument_list|(
name|yOrig
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|String
index|[]
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|String
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|String
index|[]
name|ret
init|=
name|rpcClient
operator|.
name|testUnionWithStringList
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testUnionWithStringList(): Incorrect value for inout param"
argument_list|,
name|Arrays
operator|.
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testUnionWithStringList(): Incorrect value for out param"
argument_list|,
name|Arrays
operator|.
name|equals
argument_list|(
name|yOrig
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testUnionWithStringList(): Incorrect return value"
argument_list|,
name|Arrays
operator|.
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//org.apache.type_test.types1.UnionWithStringListRestriction;
annotation|@
name|Test
specifier|public
name|void
name|testUnionWithStringListRestriction
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"UnionWithStringListRestriction"
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|testDocLiteral
operator|||
name|testXMLBinding
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|x
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"5"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|yOrig
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"I"
argument_list|,
literal|"am"
argument_list|,
literal|"SimpleList"
argument_list|)
decl_stmt|;
comment|// Invoke testUnionWithStringListRestriction
name|Holder
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|(
name|yOrig
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|ret
init|=
name|testDocLiteral
condition|?
name|docClient
operator|.
name|testUnionWithStringListRestriction
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
else|:
name|xmlClient
operator|.
name|testUnionWithStringListRestriction
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertEquals
argument_list|(
literal|"testUnionWithStringListRestriction(): Incorrect value for inout param"
argument_list|,
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"testUnionWithStringListRestriction(): Incorrect value for out param"
argument_list|,
name|yOrig
argument_list|,
name|z
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"testUnionWithStringListRestriction(): Incorrect return value"
argument_list|,
name|x
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
index|[]
name|x
init|=
block|{
literal|"5"
block|}
decl_stmt|;
name|String
index|[]
name|yOrig
init|=
block|{
literal|"I"
block|,
literal|"am"
block|,
literal|"SimpleList"
block|}
decl_stmt|;
name|Holder
argument_list|<
name|String
index|[]
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|String
index|[]
argument_list|>
argument_list|(
name|yOrig
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|String
index|[]
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|String
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|String
index|[]
name|ret
init|=
name|rpcClient
operator|.
name|testUnionWithStringListRestriction
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testUnionWithStringListRestriction(): Incorrect value for inout param"
argument_list|,
name|Arrays
operator|.
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testUnionWithStringListRestriction(): Incorrect value for out param"
argument_list|,
name|Arrays
operator|.
name|equals
argument_list|(
name|yOrig
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testUnionWithStringListRestriction(): Incorrect return value"
argument_list|,
name|Arrays
operator|.
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//org.apache.type_test.types1.UnionWithAnonList;
annotation|@
name|Test
specifier|public
name|void
name|testUnionWithAnonList
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"UnionWithAnonList"
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|testDocLiteral
operator|||
name|testXMLBinding
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|x
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"5"
argument_list|)
decl_stmt|;
comment|// Need to specify valid floats according to schema lexical
comment|// representation, not java floats... to avoid validation error
comment|// with xerces and ibm jdk.
comment|//List<String> yOrig = Arrays.asList("0.5f", "1.5f", "2.5f");
name|List
argument_list|<
name|String
argument_list|>
name|yOrig
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"-1E4"
argument_list|,
literal|"1267.43233E12"
argument_list|,
literal|"12.78e-2"
argument_list|,
literal|"12"
argument_list|,
literal|"-0"
argument_list|,
literal|"INF"
argument_list|)
decl_stmt|;
comment|// Invoke testUnionWithAnonList
name|Holder
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|(
name|yOrig
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|ret
init|=
name|testDocLiteral
condition|?
name|docClient
operator|.
name|testUnionWithAnonList
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
else|:
name|xmlClient
operator|.
name|testUnionWithAnonList
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertEquals
argument_list|(
literal|"testUnionWithAnonList(): Incorrect value for inout param"
argument_list|,
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"testUnionWithAnonList(): Incorrect value for out param"
argument_list|,
name|yOrig
argument_list|,
name|z
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"testUnionWithAnonList(): Incorrect return value"
argument_list|,
name|x
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
index|[]
name|x
init|=
block|{
literal|"5"
block|}
decl_stmt|;
comment|// Use consistent values as above...
comment|//String[] yOrig = {"0.5f", "1.5f", "2.5f"};
name|String
index|[]
name|yOrig
init|=
block|{
literal|"-1E4"
block|,
literal|"1267.43233E12"
block|,
literal|"12.78e-2"
block|,
literal|"12"
block|,
literal|"-0"
block|,
literal|"INF"
block|}
decl_stmt|;
name|Holder
argument_list|<
name|String
index|[]
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|String
index|[]
argument_list|>
argument_list|(
name|yOrig
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|String
index|[]
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|String
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|String
index|[]
name|ret
init|=
name|rpcClient
operator|.
name|testUnionWithStringListRestriction
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testUnionWithAnonList(): Incorrect value for inout param"
argument_list|,
name|Arrays
operator|.
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testUnionWithAnonList(): Incorrect value for out param"
argument_list|,
name|Arrays
operator|.
name|equals
argument_list|(
name|yOrig
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testUnionWithAnonList(): Incorrect return value"
argument_list|,
name|Arrays
operator|.
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAnyURIRestriction
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"AnyURIRestriction"
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// normal case, maxLength = 50 for anyURI
name|String
name|x
init|=
operator|new
name|String
argument_list|(
literal|"http://cxf.apache.org/"
argument_list|)
decl_stmt|;
name|String
name|yOrig
init|=
operator|new
name|String
argument_list|(
literal|"http://www.iona.com/info/services/oss/"
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|String
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|String
argument_list|>
argument_list|(
name|yOrig
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|String
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testAnyURIRestriction
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testAnyURIRestriction
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testAnyURIRestriction
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertEquals
argument_list|(
literal|"testString(): Incorrect value for inout param"
argument_list|,
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"testString(): Incorrect value for out param"
argument_list|,
name|yOrig
argument_list|,
name|z
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"testString(): Incorrect return value"
argument_list|,
name|x
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|testDocLiteral
operator|||
name|testXMLBinding
condition|)
block|{
comment|// abnormal case
name|yOrig
operator|=
operator|new
name|String
argument_list|(
literal|"http://www.iona.com/info/services/oss/info_services_oss_train.html"
argument_list|)
expr_stmt|;
name|y
operator|=
operator|new
name|Holder
argument_list|<
name|String
argument_list|>
argument_list|(
name|yOrig
argument_list|)
expr_stmt|;
name|z
operator|=
operator|new
name|Holder
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
try|try
block|{
name|ret
operator|=
name|testDocLiteral
condition|?
name|docClient
operator|.
name|testAnyURIRestriction
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
else|:
name|xmlClient
operator|.
name|testAnyURIRestriction
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"maxLength=50 restriction is violated."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
comment|//ex.printStackTrace();
block|}
block|}
block|}
comment|// Test Inheritance
comment|// test internal inheritance
annotation|@
name|Test
specifier|public
name|void
name|testInheritanceNestedStruct
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"InheritanceNestedStruct"
argument_list|)
condition|)
block|{
return|return;
block|}
name|DerivedStructBaseStruct
name|xs
init|=
operator|new
name|DerivedStructBaseStruct
argument_list|()
decl_stmt|;
comment|//Base
name|xs
operator|.
name|setVarFloat
argument_list|(
literal|3.14f
argument_list|)
expr_stmt|;
name|xs
operator|.
name|setVarInt
argument_list|(
operator|new
name|BigInteger
argument_list|(
literal|"42"
argument_list|)
argument_list|)
expr_stmt|;
name|xs
operator|.
name|setVarString
argument_list|(
literal|"BaseStruct-x"
argument_list|)
expr_stmt|;
name|xs
operator|.
name|setVarAttrString
argument_list|(
literal|"BaseStructAttr-x"
argument_list|)
expr_stmt|;
comment|//Derived
name|xs
operator|.
name|setVarFloatExt
argument_list|(
operator|-
literal|3.14f
argument_list|)
expr_stmt|;
name|xs
operator|.
name|setVarStringExt
argument_list|(
literal|"DerivedStruct-x"
argument_list|)
expr_stmt|;
name|xs
operator|.
name|setAttrString1
argument_list|(
literal|"DerivedAttr1-x"
argument_list|)
expr_stmt|;
name|xs
operator|.
name|setAttrString2
argument_list|(
literal|"DerivedAttr2-x"
argument_list|)
expr_stmt|;
name|DerivedStructBaseStruct
name|ys
init|=
operator|new
name|DerivedStructBaseStruct
argument_list|()
decl_stmt|;
comment|//Base
name|ys
operator|.
name|setVarFloat
argument_list|(
operator|-
literal|9.14f
argument_list|)
expr_stmt|;
name|ys
operator|.
name|setVarInt
argument_list|(
operator|new
name|BigInteger
argument_list|(
literal|"10"
argument_list|)
argument_list|)
expr_stmt|;
name|ys
operator|.
name|setVarString
argument_list|(
literal|"BaseStruct-y"
argument_list|)
expr_stmt|;
name|ys
operator|.
name|setVarAttrString
argument_list|(
literal|"BaseStructAttr-y"
argument_list|)
expr_stmt|;
comment|//Derived
name|ys
operator|.
name|setVarFloatExt
argument_list|(
literal|1.414f
argument_list|)
expr_stmt|;
name|ys
operator|.
name|setVarStringExt
argument_list|(
literal|"DerivedStruct-y"
argument_list|)
expr_stmt|;
name|ys
operator|.
name|setAttrString1
argument_list|(
literal|"DerivedAttr1-y"
argument_list|)
expr_stmt|;
name|ys
operator|.
name|setAttrString2
argument_list|(
literal|"DerivedAttr2-y"
argument_list|)
expr_stmt|;
name|NestedStruct
name|x
init|=
operator|new
name|NestedStruct
argument_list|()
decl_stmt|;
name|x
operator|.
name|setVarFloat
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|"3.14"
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|.
name|setVarInt
argument_list|(
literal|42
argument_list|)
expr_stmt|;
name|x
operator|.
name|setVarString
argument_list|(
literal|"Hello There"
argument_list|)
expr_stmt|;
name|x
operator|.
name|setVarEmptyStruct
argument_list|(
operator|new
name|EmptyStruct
argument_list|()
argument_list|)
expr_stmt|;
name|x
operator|.
name|setVarStruct
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|NestedStruct
name|yOrig
init|=
operator|new
name|NestedStruct
argument_list|()
decl_stmt|;
name|yOrig
operator|.
name|setVarFloat
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|"1.414"
argument_list|)
argument_list|)
expr_stmt|;
name|yOrig
operator|.
name|setVarInt
argument_list|(
literal|13
argument_list|)
expr_stmt|;
name|yOrig
operator|.
name|setVarString
argument_list|(
literal|"Cheerio"
argument_list|)
expr_stmt|;
name|yOrig
operator|.
name|setVarEmptyStruct
argument_list|(
operator|new
name|EmptyStruct
argument_list|()
argument_list|)
expr_stmt|;
name|yOrig
operator|.
name|setVarStruct
argument_list|(
name|ys
argument_list|)
expr_stmt|;
name|Holder
argument_list|<
name|NestedStruct
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|NestedStruct
argument_list|>
argument_list|(
name|yOrig
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|NestedStruct
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|NestedStruct
argument_list|>
argument_list|()
decl_stmt|;
name|NestedStruct
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testNestedStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testNestedStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testNestedStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testNestedStruct(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testNestedStruct(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOrig
argument_list|,
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testNestedStruct(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// test first level inheritance (parameters)
annotation|@
name|Test
specifier|public
name|void
name|testInheritanceSimpleStructDerivedStruct
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"InheritanceSimpleStructDerivedStruct"
argument_list|)
condition|)
block|{
return|return;
block|}
name|DerivedStructBaseStruct
name|x
init|=
operator|new
name|DerivedStructBaseStruct
argument_list|()
decl_stmt|;
comment|//Base
name|x
operator|.
name|setVarFloat
argument_list|(
literal|3.14f
argument_list|)
expr_stmt|;
name|x
operator|.
name|setVarInt
argument_list|(
operator|new
name|BigInteger
argument_list|(
literal|"42"
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|.
name|setVarString
argument_list|(
literal|"BaseStruct-x"
argument_list|)
expr_stmt|;
name|x
operator|.
name|setVarAttrString
argument_list|(
literal|"BaseStructAttr-x"
argument_list|)
expr_stmt|;
comment|//Derived
name|x
operator|.
name|setVarFloatExt
argument_list|(
operator|-
literal|3.14f
argument_list|)
expr_stmt|;
name|x
operator|.
name|setVarStringExt
argument_list|(
literal|"DerivedStruct-x"
argument_list|)
expr_stmt|;
name|x
operator|.
name|setAttrString1
argument_list|(
literal|"DerivedAttr1-x"
argument_list|)
expr_stmt|;
name|x
operator|.
name|setAttrString2
argument_list|(
literal|"DerivedAttr2-x"
argument_list|)
expr_stmt|;
name|DerivedStructBaseStruct
name|yOrig
init|=
operator|new
name|DerivedStructBaseStruct
argument_list|()
decl_stmt|;
comment|//Base
name|yOrig
operator|.
name|setVarFloat
argument_list|(
operator|-
literal|9.14f
argument_list|)
expr_stmt|;
name|yOrig
operator|.
name|setVarInt
argument_list|(
operator|new
name|BigInteger
argument_list|(
literal|"10"
argument_list|)
argument_list|)
expr_stmt|;
name|yOrig
operator|.
name|setVarString
argument_list|(
literal|"BaseStruct-y"
argument_list|)
expr_stmt|;
name|yOrig
operator|.
name|setVarAttrString
argument_list|(
literal|"BaseStructAttr-y"
argument_list|)
expr_stmt|;
comment|//Derived
name|yOrig
operator|.
name|setVarFloatExt
argument_list|(
literal|1.414f
argument_list|)
expr_stmt|;
name|yOrig
operator|.
name|setVarStringExt
argument_list|(
literal|"DerivedStruct-y"
argument_list|)
expr_stmt|;
name|yOrig
operator|.
name|setAttrString1
argument_list|(
literal|"DerivedAttr1-y"
argument_list|)
expr_stmt|;
name|yOrig
operator|.
name|setAttrString2
argument_list|(
literal|"DerivedAttr2-y"
argument_list|)
expr_stmt|;
name|Holder
argument_list|<
name|SimpleStruct
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|SimpleStruct
argument_list|>
argument_list|(
name|yOrig
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|SimpleStruct
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|SimpleStruct
argument_list|>
argument_list|()
decl_stmt|;
name|SimpleStruct
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testSimpleStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testSimpleStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testSimpleStruct
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testInheritanceSimpleDerived(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
operator|(
name|DerivedStructBaseStruct
operator|)
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testInheritanceSimpleDerived(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOrig
argument_list|,
operator|(
name|DerivedStructBaseStruct
operator|)
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testInheritanceSimpleDerived(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
operator|(
name|DerivedStructBaseStruct
operator|)
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testInheritanceSimpleChoiceDerivedStruct
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"InheritanceSimpleChoiceDerivedStruct"
argument_list|)
condition|)
block|{
return|return;
block|}
name|DerivedStructBaseChoice
name|x
init|=
operator|new
name|DerivedStructBaseChoice
argument_list|()
decl_stmt|;
comment|//Base
name|x
operator|.
name|setVarString
argument_list|(
literal|"BaseChoice-x"
argument_list|)
expr_stmt|;
comment|//Derived
name|x
operator|.
name|setVarFloatExt
argument_list|(
operator|-
literal|3.14f
argument_list|)
expr_stmt|;
name|x
operator|.
name|setVarStringExt
argument_list|(
literal|"DerivedStruct-x"
argument_list|)
expr_stmt|;
name|x
operator|.
name|setAttrString
argument_list|(
literal|"DerivedAttr-x"
argument_list|)
expr_stmt|;
name|DerivedStructBaseChoice
name|yOrig
init|=
operator|new
name|DerivedStructBaseChoice
argument_list|()
decl_stmt|;
comment|//Base
name|yOrig
operator|.
name|setVarFloat
argument_list|(
operator|-
literal|9.14f
argument_list|)
expr_stmt|;
comment|//Derived
name|yOrig
operator|.
name|setVarFloatExt
argument_list|(
literal|1.414f
argument_list|)
expr_stmt|;
name|yOrig
operator|.
name|setVarStringExt
argument_list|(
literal|"DerivedStruct-y"
argument_list|)
expr_stmt|;
name|yOrig
operator|.
name|setAttrString
argument_list|(
literal|"DerivedAttr-y"
argument_list|)
expr_stmt|;
name|Holder
argument_list|<
name|SimpleChoice
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|SimpleChoice
argument_list|>
argument_list|(
name|yOrig
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|SimpleChoice
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|SimpleChoice
argument_list|>
argument_list|()
decl_stmt|;
name|SimpleChoice
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testSimpleChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testSimpleChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testSimpleChoice
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testInheritanceSimpleChoiceDerivedStruct(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
operator|(
name|DerivedStructBaseChoice
operator|)
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testInheritanceSimpleChoiceDerivedStruct(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOrig
argument_list|,
operator|(
name|DerivedStructBaseChoice
operator|)
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testInheritanceSimpleChoiceDerivedStruct(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
operator|(
name|DerivedStructBaseChoice
operator|)
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testInheritanceUnboundedArrayDerivedChoice
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"InheritanceUnboundedArrayDerivedChoice"
argument_list|)
condition|)
block|{
return|return;
block|}
name|DerivedChoiceBaseArray
name|x
init|=
operator|new
name|DerivedChoiceBaseArray
argument_list|()
decl_stmt|;
comment|//Base
name|x
operator|.
name|getItem
argument_list|()
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"AAA"
argument_list|,
literal|"BBB"
argument_list|,
literal|"CCC"
argument_list|)
argument_list|)
expr_stmt|;
comment|//Derived
name|x
operator|.
name|setVarStringExt
argument_list|(
literal|"DerivedChoice-x"
argument_list|)
expr_stmt|;
name|x
operator|.
name|setAttrStringExt
argument_list|(
literal|"DerivedAttr-x"
argument_list|)
expr_stmt|;
name|DerivedChoiceBaseArray
name|yOrig
init|=
operator|new
name|DerivedChoiceBaseArray
argument_list|()
decl_stmt|;
comment|//Base
name|yOrig
operator|.
name|getItem
argument_list|()
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"XXX"
argument_list|,
literal|"YYY"
argument_list|,
literal|"ZZZ"
argument_list|)
argument_list|)
expr_stmt|;
comment|//Derived
name|yOrig
operator|.
name|setVarFloatExt
argument_list|(
literal|1.414f
argument_list|)
expr_stmt|;
name|yOrig
operator|.
name|setAttrStringExt
argument_list|(
literal|"DerivedAttr-y"
argument_list|)
expr_stmt|;
name|Holder
argument_list|<
name|UnboundedArray
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|UnboundedArray
argument_list|>
argument_list|(
name|yOrig
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|UnboundedArray
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|UnboundedArray
argument_list|>
argument_list|()
decl_stmt|;
name|UnboundedArray
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testUnboundedArray
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testUnboundedArray
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testUnboundedArray
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfTestOnly
condition|)
block|{
name|assertTrue
argument_list|(
literal|"testInheritanceUnboundedArrayDerivedChoice(): Incorrect value for inout param"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
operator|(
name|DerivedChoiceBaseArray
operator|)
name|y
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testInheritanceUnboundedArrayDerivedChoice(): Incorrect value for out param"
argument_list|,
name|equals
argument_list|(
name|yOrig
argument_list|,
operator|(
name|DerivedChoiceBaseArray
operator|)
name|z
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"testInheritanceUnboundedArrayDerivedChoice(): Incorrect return value"
argument_list|,
name|equals
argument_list|(
name|x
argument_list|,
operator|(
name|DerivedChoiceBaseArray
operator|)
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testInheritanceEmptyAllDerivedEmpty
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|shouldRunTest
argument_list|(
literal|"InheritanceEmptyAllDerivedEmpty"
argument_list|)
condition|)
block|{
return|return;
block|}
name|DerivedEmptyBaseEmptyAll
name|x
init|=
operator|new
name|DerivedEmptyBaseEmptyAll
argument_list|()
decl_stmt|;
name|DerivedEmptyBaseEmptyAll
name|yOrig
init|=
operator|new
name|DerivedEmptyBaseEmptyAll
argument_list|()
decl_stmt|;
name|Holder
argument_list|<
name|EmptyAll
argument_list|>
name|y
init|=
operator|new
name|Holder
argument_list|<
name|EmptyAll
argument_list|>
argument_list|(
name|yOrig
argument_list|)
decl_stmt|;
name|Holder
argument_list|<
name|EmptyAll
argument_list|>
name|z
init|=
operator|new
name|Holder
argument_list|<
name|EmptyAll
argument_list|>
argument_list|()
decl_stmt|;
name|EmptyAll
name|ret
decl_stmt|;
if|if
condition|(
name|testDocLiteral
condition|)
block|{
name|ret
operator|=
name|docClient
operator|.
name|testEmptyAll
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testXMLBinding
condition|)
block|{
name|ret
operator|=
name|xmlClient
operator|.
name|testEmptyAll
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|rpcClient
operator|.
name|testEmptyAll
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
name|assertNotNull
argument_list|(
literal|"testInheritanceEmptyAllDerivedEmpty()"
argument_list|,
name|y
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"testInheritanceEmptyAllDerivedEmpty()"
argument_list|,
name|z
operator|.
name|value
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"testInheritanceEmptyAllDerivedEmpty()"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

