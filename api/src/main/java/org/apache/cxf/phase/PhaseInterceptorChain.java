begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements. See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|phase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|common
operator|.
name|logging
operator|.
name|LogUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|continuations
operator|.
name|SuspendedInvocationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|interceptor
operator|.
name|Fault
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|interceptor
operator|.
name|Interceptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|interceptor
operator|.
name|InterceptorChain
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|FaultMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|MessageObserver
import|;
end_import

begin_comment
comment|/**  * A PhaseInterceptorChain orders Interceptors according to the phase they  * participate in and also according to the before& after properties on an  * Interceptor.  *<p>  * A List of phases is supplied to the PhaseInterceptorChain in the constructor.  * This class is typically instantiated from the PhaseChainCache class in this  * package. Interceptors that are added to the chain are ordered by phase.  * Within a phase, interceptors can order themselves. Each PhaseInterceptor   * has an ID. PhaseInterceptors can supply a Collection of IDs which they   * should run before or after, supplying fine grained ordering.  *<p>  *    */
end_comment

begin_class
specifier|public
class|class
name|PhaseInterceptorChain
implements|implements
name|InterceptorChain
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LogUtils
operator|.
name|getL7dLogger
argument_list|(
name|PhaseInterceptorChain
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|nameMap
decl_stmt|;
specifier|private
specifier|final
name|Phase
name|phases
index|[]
decl_stmt|;
comment|// heads[phase] refers to the first interceptor of the given phase
specifier|private
name|InterceptorHolder
name|heads
index|[]
decl_stmt|;
comment|// tails[phase] refers to the last interceptor of the given phase
specifier|private
name|InterceptorHolder
name|tails
index|[]
decl_stmt|;
comment|// hasAfters[phase] indicates that the given phase has already inserted
comment|// interceptors that may need to be placed after future to-be-inserted
comment|// interceptors.  This flag is used to activate ordering of interceptors
comment|// when new ones are added to the list for this phase.
comment|// Note no hasBefores[] is needed because implementation adds subsequent
comment|// interceptors to the end of the list by default.
specifier|private
name|boolean
name|hasAfters
index|[]
decl_stmt|;
specifier|private
name|State
name|state
decl_stmt|;
specifier|private
name|Message
name|pausedMessage
decl_stmt|;
specifier|private
name|MessageObserver
name|faultObserver
decl_stmt|;
specifier|private
name|PhaseInterceptorIterator
name|iterator
decl_stmt|;
comment|// currently one chain for one request/response, use below as signal
comment|// to avoid duplicate fault processing on nested calling of
comment|// doIntercept(), which will throw same fault multi-times
specifier|private
name|boolean
name|faultOccurred
decl_stmt|;
specifier|private
name|PhaseInterceptorChain
parameter_list|(
name|PhaseInterceptorChain
name|src
parameter_list|)
block|{
comment|//only used for clone
name|state
operator|=
name|State
operator|.
name|EXECUTING
expr_stmt|;
comment|//immutable, just repoint
name|nameMap
operator|=
name|src
operator|.
name|nameMap
expr_stmt|;
name|phases
operator|=
name|src
operator|.
name|phases
expr_stmt|;
name|int
name|length
init|=
name|phases
operator|.
name|length
decl_stmt|;
name|hasAfters
operator|=
operator|new
name|boolean
index|[
name|length
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|src
operator|.
name|hasAfters
argument_list|,
literal|0
argument_list|,
name|hasAfters
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|heads
operator|=
operator|new
name|InterceptorHolder
index|[
name|length
index|]
expr_stmt|;
name|tails
operator|=
operator|new
name|InterceptorHolder
index|[
name|length
index|]
expr_stmt|;
name|InterceptorHolder
name|last
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|length
condition|;
name|x
operator|++
control|)
block|{
name|InterceptorHolder
name|ih
init|=
name|src
operator|.
name|heads
index|[
name|x
index|]
decl_stmt|;
while|while
condition|(
name|ih
operator|!=
literal|null
operator|&&
name|ih
operator|.
name|phaseIdx
operator|==
name|x
condition|)
block|{
name|InterceptorHolder
name|ih2
init|=
operator|new
name|InterceptorHolder
argument_list|(
name|ih
argument_list|)
decl_stmt|;
name|ih2
operator|.
name|prev
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|last
operator|!=
literal|null
condition|)
block|{
name|last
operator|.
name|next
operator|=
name|ih2
expr_stmt|;
block|}
if|if
condition|(
name|heads
index|[
name|x
index|]
operator|==
literal|null
condition|)
block|{
name|heads
index|[
name|x
index|]
operator|=
name|ih2
expr_stmt|;
block|}
name|tails
index|[
name|x
index|]
operator|=
name|ih2
expr_stmt|;
name|last
operator|=
name|ih2
expr_stmt|;
name|ih
operator|=
name|ih
operator|.
name|next
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|PhaseInterceptorChain
parameter_list|(
name|SortedSet
argument_list|<
name|Phase
argument_list|>
name|ps
parameter_list|)
block|{
name|state
operator|=
name|State
operator|.
name|EXECUTING
expr_stmt|;
name|int
name|numPhases
init|=
name|ps
operator|.
name|size
argument_list|()
decl_stmt|;
name|phases
operator|=
operator|new
name|Phase
index|[
name|numPhases
index|]
expr_stmt|;
name|nameMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
name|heads
operator|=
operator|new
name|InterceptorHolder
index|[
name|numPhases
index|]
expr_stmt|;
name|tails
operator|=
operator|new
name|InterceptorHolder
index|[
name|numPhases
index|]
expr_stmt|;
name|hasAfters
operator|=
operator|new
name|boolean
index|[
name|numPhases
index|]
expr_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Phase
name|phase
range|:
name|ps
control|)
block|{
name|phases
index|[
name|idx
index|]
operator|=
name|phase
expr_stmt|;
name|nameMap
operator|.
name|put
argument_list|(
name|phase
operator|.
name|getName
argument_list|()
argument_list|,
name|idx
argument_list|)
expr_stmt|;
operator|++
name|idx
expr_stmt|;
block|}
block|}
comment|// this method should really be on the InterceptorChain interface
specifier|public
name|State
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
specifier|public
name|PhaseInterceptorChain
name|cloneChain
parameter_list|()
block|{
return|return
operator|new
name|PhaseInterceptorChain
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|private
name|void
name|updateIterator
parameter_list|()
block|{
if|if
condition|(
name|iterator
operator|==
literal|null
condition|)
block|{
name|iterator
operator|=
operator|new
name|PhaseInterceptorIterator
argument_list|(
name|heads
argument_list|)
expr_stmt|;
name|outputChainToLog
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|//System.out.println(toString());
block|}
block|}
specifier|public
name|void
name|add
parameter_list|(
name|Collection
argument_list|<
name|Interceptor
argument_list|>
name|newhandlers
parameter_list|)
block|{
name|add
argument_list|(
name|newhandlers
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|add
parameter_list|(
name|Collection
argument_list|<
name|Interceptor
argument_list|>
name|newhandlers
parameter_list|,
name|boolean
name|force
parameter_list|)
block|{
if|if
condition|(
name|newhandlers
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Interceptor
name|handler
range|:
name|newhandlers
control|)
block|{
name|add
argument_list|(
name|handler
argument_list|,
name|force
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|add
parameter_list|(
name|Interceptor
name|i
parameter_list|)
block|{
name|add
argument_list|(
name|i
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|add
parameter_list|(
name|Interceptor
name|i
parameter_list|,
name|boolean
name|force
parameter_list|)
block|{
name|PhaseInterceptor
name|pi
init|=
operator|(
name|PhaseInterceptor
operator|)
name|i
decl_stmt|;
name|String
name|phaseName
init|=
name|pi
operator|.
name|getPhase
argument_list|()
decl_stmt|;
name|Integer
name|phase
init|=
name|nameMap
operator|.
name|get
argument_list|(
name|phaseName
argument_list|)
decl_stmt|;
if|if
condition|(
name|phase
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
literal|"Skipping interceptor "
operator|+
name|i
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
operator|(
operator|(
name|phaseName
operator|==
literal|null
operator|)
condition|?
literal|": Phase declaration is missing."
else|:
literal|": Phase "
operator|+
name|phaseName
operator|+
literal|" specified does not exist."
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
literal|"Adding interceptor "
operator|+
name|i
operator|+
literal|" to phase "
operator|+
name|phaseName
argument_list|)
expr_stmt|;
block|}
name|insertInterceptor
argument_list|(
name|phase
argument_list|,
name|pi
argument_list|,
name|force
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|synchronized
name|void
name|pause
parameter_list|()
block|{
name|state
operator|=
name|State
operator|.
name|PAUSED
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|resume
parameter_list|()
block|{
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|PAUSED
condition|)
block|{
name|state
operator|=
name|State
operator|.
name|EXECUTING
expr_stmt|;
name|doIntercept
argument_list|(
name|pausedMessage
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Intercept a message, invoking each phase's handlers in turn.      *       * @param message the message       * @throws Exception      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|synchronized
name|boolean
name|doIntercept
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
name|updateIterator
argument_list|()
expr_stmt|;
name|boolean
name|isFineLogging
init|=
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
decl_stmt|;
name|pausedMessage
operator|=
name|message
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|State
operator|.
name|EXECUTING
operator|&&
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
try|try
block|{
name|Interceptor
name|currentInterceptor
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|isFineLogging
condition|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
literal|"Invoking handleMessage on interceptor "
operator|+
name|currentInterceptor
argument_list|)
expr_stmt|;
block|}
comment|//System.out.println("-----------" + currentInterceptor);
name|currentInterceptor
operator|.
name|handleMessage
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SuspendedInvocationException
name|ex
parameter_list|)
block|{
comment|// we need to resume from the same interceptor the exception got originated from
if|if
condition|(
name|iterator
operator|.
name|hasPrevious
argument_list|()
condition|)
block|{
name|iterator
operator|.
name|previous
argument_list|()
expr_stmt|;
block|}
name|pause
argument_list|()
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|ex
parameter_list|)
block|{
if|if
condition|(
operator|!
name|faultOccurred
condition|)
block|{
name|faultOccurred
operator|=
literal|true
expr_stmt|;
name|FaultMode
name|mode
init|=
name|message
operator|.
name|get
argument_list|(
name|FaultMode
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|FaultMode
operator|.
name|CHECKED_APPLICATION_FAULT
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
literal|"Application has thrown exception, unwinding now "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|INFO
argument_list|)
condition|)
block|{
name|Throwable
name|t
init|=
name|ex
decl_stmt|;
if|if
condition|(
name|ex
operator|instanceof
name|Fault
operator|&&
name|ex
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|t
operator|=
name|ex
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Application has thrown exception, unwinding now: "
operator|+
name|t
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|INFO
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|FaultMode
operator|.
name|UNCHECKED_APPLICATION_FAULT
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Application has thrown exception, unwinding now "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Interceptor has thrown exception, unwinding now "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|message
operator|.
name|setContent
argument_list|(
name|Exception
operator|.
name|class
argument_list|,
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|.
name|getExchange
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|message
operator|.
name|getExchange
argument_list|()
operator|.
name|put
argument_list|(
name|Exception
operator|.
name|class
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|unwind
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|faultObserver
operator|!=
literal|null
condition|)
block|{
name|faultObserver
operator|.
name|onMessage
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
name|state
operator|=
name|State
operator|.
name|ABORTED
expr_stmt|;
block|}
block|}
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|EXECUTING
condition|)
block|{
name|state
operator|=
name|State
operator|.
name|COMPLETE
expr_stmt|;
name|pausedMessage
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|state
operator|==
name|State
operator|.
name|COMPLETE
return|;
block|}
comment|/**      * Intercept a message, invoking each phase's handlers in turn,      * starting after the specified interceptor.      *       * @param message the message      * @param startingAfterInterceptorID the id of the interceptor       * @throws Exception      */
specifier|public
specifier|synchronized
name|boolean
name|doInterceptStartingAfter
parameter_list|(
name|Message
name|message
parameter_list|,
name|String
name|startingAfterInterceptorID
parameter_list|)
block|{
name|updateIterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|State
operator|.
name|EXECUTING
operator|&&
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|PhaseInterceptor
name|currentInterceptor
init|=
operator|(
name|PhaseInterceptor
operator|)
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentInterceptor
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
name|startingAfterInterceptorID
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
return|return
name|doIntercept
argument_list|(
name|message
argument_list|)
return|;
block|}
comment|/**      * Intercept a message, invoking each phase's handlers in turn,      * starting at the specified interceptor.      *       * @param message the message      * @param startingAtInterceptorID the id of the interceptor       * @throws Exception      */
specifier|public
specifier|synchronized
name|boolean
name|doInterceptStartingAt
parameter_list|(
name|Message
name|message
parameter_list|,
name|String
name|startingAtInterceptorID
parameter_list|)
block|{
name|updateIterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|State
operator|.
name|EXECUTING
operator|&&
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|PhaseInterceptor
name|currentInterceptor
init|=
operator|(
name|PhaseInterceptor
operator|)
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentInterceptor
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
name|startingAtInterceptorID
argument_list|)
condition|)
block|{
name|iterator
operator|.
name|previous
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
name|doIntercept
argument_list|(
name|message
argument_list|)
return|;
block|}
specifier|public
specifier|synchronized
name|void
name|reset
parameter_list|()
block|{
name|updateIterator
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|COMPLETE
condition|)
block|{
name|state
operator|=
name|State
operator|.
name|EXECUTING
expr_stmt|;
name|iterator
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|iterator
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|void
name|unwind
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
name|boolean
name|isFineLogging
init|=
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasPrevious
argument_list|()
condition|)
block|{
name|Interceptor
name|currentInterceptor
init|=
name|iterator
operator|.
name|previous
argument_list|()
decl_stmt|;
if|if
condition|(
name|isFineLogging
condition|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
literal|"Invoking handleFault on interceptor "
operator|+
name|currentInterceptor
argument_list|)
expr_stmt|;
block|}
name|currentInterceptor
operator|.
name|handleFault
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|remove
parameter_list|(
name|Interceptor
name|i
parameter_list|)
block|{
name|PhaseInterceptorIterator
name|it
init|=
operator|new
name|PhaseInterceptorIterator
argument_list|(
name|heads
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|InterceptorHolder
name|holder
init|=
name|it
operator|.
name|nextInterceptorHolder
argument_list|()
decl_stmt|;
if|if
condition|(
name|holder
operator|.
name|interceptor
operator|==
name|i
condition|)
block|{
name|remove
argument_list|(
name|holder
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
specifier|public
specifier|synchronized
name|void
name|abort
parameter_list|()
block|{
name|this
operator|.
name|state
operator|=
name|InterceptorChain
operator|.
name|State
operator|.
name|ABORTED
expr_stmt|;
block|}
specifier|public
name|Iterator
argument_list|<
name|Interceptor
argument_list|<
name|?
extends|extends
name|Message
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|getIterator
argument_list|()
return|;
block|}
specifier|public
name|ListIterator
argument_list|<
name|Interceptor
argument_list|<
name|?
extends|extends
name|Message
argument_list|>
argument_list|>
name|getIterator
parameter_list|()
block|{
return|return
operator|new
name|PhaseInterceptorIterator
argument_list|(
name|heads
argument_list|)
return|;
block|}
specifier|private
name|void
name|remove
parameter_list|(
name|InterceptorHolder
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|.
name|prev
operator|!=
literal|null
condition|)
block|{
name|i
operator|.
name|prev
operator|.
name|next
operator|=
name|i
operator|.
name|next
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|.
name|next
operator|!=
literal|null
condition|)
block|{
name|i
operator|.
name|next
operator|.
name|prev
operator|=
name|i
operator|.
name|prev
expr_stmt|;
block|}
name|int
name|ph
init|=
name|i
operator|.
name|phaseIdx
decl_stmt|;
if|if
condition|(
name|heads
index|[
name|ph
index|]
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|next
operator|!=
literal|null
operator|&&
name|i
operator|.
name|next
operator|.
name|phaseIdx
operator|==
name|ph
condition|)
block|{
name|heads
index|[
name|ph
index|]
operator|=
name|i
operator|.
name|next
expr_stmt|;
block|}
else|else
block|{
name|heads
index|[
name|ph
index|]
operator|=
literal|null
expr_stmt|;
name|tails
index|[
name|ph
index|]
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tails
index|[
name|ph
index|]
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|prev
operator|!=
literal|null
operator|&&
name|i
operator|.
name|prev
operator|.
name|phaseIdx
operator|==
name|ph
condition|)
block|{
name|tails
index|[
name|ph
index|]
operator|=
name|i
operator|.
name|prev
expr_stmt|;
block|}
else|else
block|{
name|heads
index|[
name|ph
index|]
operator|=
literal|null
expr_stmt|;
name|tails
index|[
name|ph
index|]
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|insertInterceptor
parameter_list|(
name|int
name|phase
parameter_list|,
name|PhaseInterceptor
name|interc
parameter_list|,
name|boolean
name|force
parameter_list|)
block|{
name|InterceptorHolder
name|ih
init|=
operator|new
name|InterceptorHolder
argument_list|(
name|interc
argument_list|,
name|phase
argument_list|)
decl_stmt|;
if|if
condition|(
name|heads
index|[
name|phase
index|]
operator|==
literal|null
condition|)
block|{
comment|// no interceptors yet in this phase
name|heads
index|[
name|phase
index|]
operator|=
name|ih
expr_stmt|;
name|tails
index|[
name|phase
index|]
operator|=
name|ih
expr_stmt|;
name|hasAfters
index|[
name|phase
index|]
operator|=
operator|!
name|interc
operator|.
name|getAfter
argument_list|()
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
name|int
name|idx
init|=
name|phase
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|idx
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|tails
index|[
name|idx
index|]
operator|!=
literal|null
condition|)
block|{
break|break;
block|}
operator|--
name|idx
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
block|{
comment|//found something before us, in an earlier phase
name|ih
operator|.
name|prev
operator|=
name|tails
index|[
name|idx
index|]
expr_stmt|;
name|ih
operator|.
name|next
operator|=
name|tails
index|[
name|idx
index|]
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|ih
operator|.
name|next
operator|!=
literal|null
condition|)
block|{
name|ih
operator|.
name|next
operator|.
name|prev
operator|=
name|ih
expr_stmt|;
block|}
name|tails
index|[
name|idx
index|]
operator|.
name|next
operator|=
name|ih
expr_stmt|;
block|}
else|else
block|{
comment|//did not find something before us, try after
name|idx
operator|=
name|phase
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|heads
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|heads
index|[
name|idx
index|]
operator|!=
literal|null
condition|)
block|{
break|break;
block|}
operator|++
name|idx
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|!=
name|heads
operator|.
name|length
condition|)
block|{
comment|//found something after us
name|ih
operator|.
name|next
operator|=
name|heads
index|[
name|idx
index|]
expr_stmt|;
name|heads
index|[
name|idx
index|]
operator|.
name|prev
operator|=
name|ih
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// this phase already has interceptors attached
comment|// list of interceptors that the new interceptor should precede
name|Set
name|beforeList
init|=
name|interc
operator|.
name|getBefore
argument_list|()
decl_stmt|;
comment|// list of interceptors that the new interceptor should be after
name|Set
name|afterList
init|=
name|interc
operator|.
name|getAfter
argument_list|()
decl_stmt|;
comment|// firstBefore will hold the first interceptor of a given phase
comment|// that the interceptor to be added must precede
name|InterceptorHolder
name|firstBefore
init|=
literal|null
decl_stmt|;
comment|// lastAfter will hold the last interceptor of a given phase
comment|// that the interceptor to be added must come after
name|InterceptorHolder
name|lastAfter
init|=
literal|null
decl_stmt|;
name|String
name|id
init|=
name|interc
operator|.
name|getId
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasAfters
index|[
name|phase
index|]
operator|||
operator|!
name|beforeList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|InterceptorHolder
name|ih2
init|=
name|heads
index|[
name|phase
index|]
decl_stmt|;
while|while
condition|(
name|ih2
operator|!=
name|tails
index|[
name|phase
index|]
operator|.
name|next
condition|)
block|{
name|PhaseInterceptor
name|cmp
init|=
name|ih2
operator|.
name|interceptor
decl_stmt|;
name|String
name|cmpId
init|=
name|cmp
operator|.
name|getId
argument_list|()
decl_stmt|;
if|if
condition|(
name|cmpId
operator|!=
literal|null
operator|&&
name|firstBefore
operator|==
literal|null
operator|&&
operator|(
name|beforeList
operator|.
name|contains
argument_list|(
name|cmpId
argument_list|)
operator|||
name|cmp
operator|.
name|getAfter
argument_list|()
operator|.
name|contains
argument_list|(
name|id
argument_list|)
operator|)
condition|)
block|{
name|firstBefore
operator|=
name|ih2
expr_stmt|;
block|}
if|if
condition|(
name|cmpId
operator|!=
literal|null
operator|&&
name|afterList
operator|.
name|contains
argument_list|(
name|cmpId
argument_list|)
condition|)
block|{
name|lastAfter
operator|=
name|ih2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|force
operator|&&
name|cmpId
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|)
block|{
comment|// interceptor is already in chain
return|return;
block|}
name|ih2
operator|=
name|ih2
operator|.
name|next
expr_stmt|;
block|}
if|if
condition|(
name|lastAfter
operator|==
literal|null
operator|&&
name|beforeList
operator|.
name|contains
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|firstBefore
operator|=
name|heads
index|[
name|phase
index|]
expr_stmt|;
block|}
comment|//System.out.print("Didn't skip: " + phase.toString());
comment|//System.out.println("             " + interc.getId());
block|}
elseif|else
if|if
condition|(
operator|!
name|force
condition|)
block|{
comment|// skip interceptor if already in chain
name|InterceptorHolder
name|ih2
init|=
name|heads
index|[
name|phase
index|]
decl_stmt|;
while|while
condition|(
name|ih2
operator|!=
name|tails
index|[
name|phase
index|]
operator|.
name|next
condition|)
block|{
if|if
condition|(
name|ih2
operator|.
name|interceptor
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|)
block|{
return|return;
block|}
name|ih2
operator|=
name|ih2
operator|.
name|next
expr_stmt|;
block|}
comment|//System.out.print("Skipped: " + phase.toString());
comment|//System.out.println("         " + interc.getId());
block|}
name|hasAfters
index|[
name|phase
index|]
operator||=
operator|!
name|afterList
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
if|if
condition|(
name|firstBefore
operator|==
literal|null
condition|)
block|{
comment|//just add new interceptor at the end
name|ih
operator|.
name|prev
operator|=
name|tails
index|[
name|phase
index|]
expr_stmt|;
name|ih
operator|.
name|next
operator|=
name|tails
index|[
name|phase
index|]
operator|.
name|next
expr_stmt|;
name|tails
index|[
name|phase
index|]
operator|.
name|next
operator|=
name|ih
expr_stmt|;
if|if
condition|(
name|ih
operator|.
name|next
operator|!=
literal|null
condition|)
block|{
name|ih
operator|.
name|next
operator|.
name|prev
operator|=
name|ih
expr_stmt|;
block|}
name|tails
index|[
name|phase
index|]
operator|=
name|ih
expr_stmt|;
block|}
else|else
block|{
name|ih
operator|.
name|prev
operator|=
name|firstBefore
operator|.
name|prev
expr_stmt|;
if|if
condition|(
name|ih
operator|.
name|prev
operator|!=
literal|null
condition|)
block|{
name|ih
operator|.
name|prev
operator|.
name|next
operator|=
name|ih
expr_stmt|;
block|}
name|ih
operator|.
name|next
operator|=
name|firstBefore
expr_stmt|;
name|firstBefore
operator|.
name|prev
operator|=
name|ih
expr_stmt|;
if|if
condition|(
name|heads
index|[
name|phase
index|]
operator|==
name|firstBefore
condition|)
block|{
name|heads
index|[
name|phase
index|]
operator|=
name|ih
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|iterator
operator|!=
literal|null
condition|)
block|{
name|outputChainToLog
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|toString
argument_list|(
literal|""
argument_list|)
return|;
block|}
specifier|private
name|String
name|toString
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|StringBuilder
name|chain
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|chain
operator|.
name|append
argument_list|(
literal|"Chain "
argument_list|)
operator|.
name|append
argument_list|(
name|super
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
name|message
argument_list|)
operator|.
name|append
argument_list|(
literal|". Current flow:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|phases
operator|.
name|length
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|heads
index|[
name|x
index|]
operator|!=
literal|null
condition|)
block|{
name|chain
operator|.
name|append
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printPhase
argument_list|(
name|x
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|chain
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|void
name|printPhase
parameter_list|(
name|int
name|ph
parameter_list|,
name|StringBuilder
name|chain
parameter_list|)
block|{
name|chain
operator|.
name|append
argument_list|(
name|phases
index|[
name|ph
index|]
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" ["
argument_list|)
expr_stmt|;
name|InterceptorHolder
name|i
init|=
name|heads
index|[
name|ph
index|]
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|tails
index|[
name|ph
index|]
operator|.
name|next
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|chain
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|chain
operator|.
name|append
argument_list|(
name|i
operator|.
name|interceptor
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|i
operator|=
name|i
operator|.
name|next
expr_stmt|;
block|}
name|chain
operator|.
name|append
argument_list|(
literal|"]\n"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|outputChainToLog
parameter_list|(
name|boolean
name|modified
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
if|if
condition|(
name|modified
condition|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
name|toString
argument_list|(
literal|" was modified"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|fine
argument_list|(
name|toString
argument_list|(
literal|" was created"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|MessageObserver
name|getFaultObserver
parameter_list|()
block|{
return|return
name|faultObserver
return|;
block|}
specifier|public
name|void
name|setFaultObserver
parameter_list|(
name|MessageObserver
name|faultObserver
parameter_list|)
block|{
name|this
operator|.
name|faultObserver
operator|=
name|faultObserver
expr_stmt|;
block|}
specifier|static
specifier|final
class|class
name|PhaseInterceptorIterator
implements|implements
name|ListIterator
argument_list|<
name|Interceptor
argument_list|<
name|?
extends|extends
name|Message
argument_list|>
argument_list|>
block|{
name|InterceptorHolder
name|heads
index|[]
decl_stmt|;
name|InterceptorHolder
name|prev
decl_stmt|;
name|InterceptorHolder
name|first
decl_stmt|;
specifier|public
name|PhaseInterceptorIterator
parameter_list|(
name|InterceptorHolder
name|h
index|[]
parameter_list|)
block|{
name|heads
operator|=
name|h
expr_stmt|;
name|first
operator|=
name|findFirst
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|prev
operator|=
literal|null
expr_stmt|;
name|first
operator|=
name|findFirst
argument_list|()
expr_stmt|;
block|}
specifier|private
name|InterceptorHolder
name|findFirst
parameter_list|()
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|heads
operator|.
name|length
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|heads
index|[
name|x
index|]
operator|!=
literal|null
condition|)
block|{
return|return
name|heads
index|[
name|x
index|]
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
if|if
condition|(
name|prev
operator|==
literal|null
condition|)
block|{
return|return
name|first
operator|!=
literal|null
return|;
block|}
return|return
name|prev
operator|.
name|next
operator|!=
literal|null
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Interceptor
argument_list|<
name|?
extends|extends
name|Message
argument_list|>
name|next
parameter_list|()
block|{
if|if
condition|(
name|prev
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|first
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|prev
operator|=
name|first
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prev
operator|.
name|next
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|prev
operator|=
name|prev
operator|.
name|next
expr_stmt|;
block|}
return|return
name|prev
operator|.
name|interceptor
return|;
block|}
specifier|public
name|InterceptorHolder
name|nextInterceptorHolder
parameter_list|()
block|{
if|if
condition|(
name|prev
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|first
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|prev
operator|=
name|first
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prev
operator|.
name|next
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|prev
operator|=
name|prev
operator|.
name|next
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
specifier|public
name|boolean
name|hasPrevious
parameter_list|()
block|{
return|return
name|prev
operator|!=
literal|null
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Interceptor
argument_list|<
name|?
extends|extends
name|Message
argument_list|>
name|previous
parameter_list|()
block|{
if|if
condition|(
name|prev
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|InterceptorHolder
name|tmp
init|=
name|prev
decl_stmt|;
name|prev
operator|=
name|prev
operator|.
name|prev
expr_stmt|;
return|return
name|tmp
operator|.
name|interceptor
return|;
block|}
specifier|public
name|int
name|nextIndex
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|int
name|previousIndex
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|void
name|add
parameter_list|(
name|Interceptor
name|o
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|void
name|set
parameter_list|(
name|Interceptor
name|o
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
specifier|static
specifier|final
class|class
name|InterceptorHolder
block|{
name|PhaseInterceptor
name|interceptor
decl_stmt|;
name|InterceptorHolder
name|next
decl_stmt|;
name|InterceptorHolder
name|prev
decl_stmt|;
name|int
name|phaseIdx
decl_stmt|;
name|InterceptorHolder
parameter_list|(
name|PhaseInterceptor
name|i
parameter_list|,
name|int
name|p
parameter_list|)
block|{
name|interceptor
operator|=
name|i
expr_stmt|;
name|phaseIdx
operator|=
name|p
expr_stmt|;
block|}
name|InterceptorHolder
parameter_list|(
name|InterceptorHolder
name|p
parameter_list|)
block|{
name|interceptor
operator|=
name|p
operator|.
name|interceptor
expr_stmt|;
name|phaseIdx
operator|=
name|p
operator|.
name|phaseIdx
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

