begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements. See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|FaultMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|phase
operator|.
name|Phase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|phase
operator|.
name|PhaseInterceptorChain
import|;
end_import

begin_comment
comment|//import org.apache.cxf.ws.addressing.AddressingPropertiesImpl;
end_comment

begin_comment
comment|//import org.apache.cxf.ws.addressing.AttributedURIType;
end_comment

begin_comment
comment|//import org.apache.cxf.ws.addressing.EndpointReferenceType;
end_comment

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|addressing
operator|.
name|JAXWSAConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|addressing
operator|.
name|MAPAggregator
import|;
end_import

begin_comment
comment|//import org.apache.cxf.ws.rm.v200702.Identifier;
end_comment

begin_import
import|import
name|org
operator|.
name|easymock
operator|.
name|classextension
operator|.
name|EasyMock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|easymock
operator|.
name|classextension
operator|.
name|IMocksControl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_class
specifier|public
class|class
name|RMOutInterceptorTest
extends|extends
name|Assert
block|{
specifier|private
name|IMocksControl
name|control
decl_stmt|;
annotation|@
name|Before
specifier|public
name|void
name|setUp
parameter_list|()
block|{
name|control
operator|=
name|EasyMock
operator|.
name|createNiceControl
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOrdering
parameter_list|()
block|{
name|Phase
name|p
init|=
operator|new
name|Phase
argument_list|(
name|Phase
operator|.
name|PRE_LOGICAL
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|SortedSet
argument_list|<
name|Phase
argument_list|>
name|phases
init|=
operator|new
name|TreeSet
argument_list|<
name|Phase
argument_list|>
argument_list|()
decl_stmt|;
name|phases
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PhaseInterceptorChain
name|chain
init|=
operator|new
name|PhaseInterceptorChain
argument_list|(
name|phases
argument_list|)
decl_stmt|;
name|MAPAggregator
name|map
init|=
operator|new
name|MAPAggregator
argument_list|()
decl_stmt|;
name|RMOutInterceptor
name|rmi
init|=
operator|new
name|RMOutInterceptor
argument_list|()
decl_stmt|;
name|chain
operator|.
name|add
argument_list|(
name|rmi
argument_list|)
expr_stmt|;
name|chain
operator|.
name|add
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|Iterator
name|it
init|=
name|chain
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertSame
argument_list|(
literal|"Unexpected order."
argument_list|,
name|map
argument_list|,
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
literal|"Unexpected order."
argument_list|,
name|rmi
argument_list|,
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testHandleRuntimeFault
parameter_list|()
throws|throws
name|NoSuchMethodException
throws|,
name|SequenceFault
throws|,
name|RMException
block|{
name|Method
index|[]
name|mocked
init|=
operator|new
name|Method
index|[]
block|{
name|RMOutInterceptor
operator|.
name|class
operator|.
name|getDeclaredMethod
argument_list|(
literal|"isRuntimeFault"
argument_list|,
operator|new
name|Class
index|[]
block|{
name|Message
operator|.
name|class
block|}
argument_list|)
block|}
decl_stmt|;
name|RMOutInterceptor
name|interceptor
init|=
name|control
operator|.
name|createMock
argument_list|(
name|RMOutInterceptor
operator|.
name|class
argument_list|,
name|mocked
argument_list|)
decl_stmt|;
name|Message
name|message
init|=
name|control
operator|.
name|createMock
argument_list|(
name|Message
operator|.
name|class
argument_list|)
decl_stmt|;
name|EasyMock
operator|.
name|expect
argument_list|(
name|interceptor
operator|.
name|isRuntimeFault
argument_list|(
name|message
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|control
operator|.
name|replay
argument_list|()
expr_stmt|;
name|interceptor
operator|.
name|handle
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|control
operator|.
name|verify
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testHandleNoMAPs
parameter_list|()
throws|throws
name|NoSuchMethodException
throws|,
name|SequenceFault
throws|,
name|RMException
block|{
name|Method
index|[]
name|mocked
init|=
operator|new
name|Method
index|[]
block|{
name|RMOutInterceptor
operator|.
name|class
operator|.
name|getDeclaredMethod
argument_list|(
literal|"isRuntimeFault"
argument_list|,
operator|new
name|Class
index|[]
block|{
name|Message
operator|.
name|class
block|}
argument_list|)
block|}
decl_stmt|;
name|RMOutInterceptor
name|interceptor
init|=
name|control
operator|.
name|createMock
argument_list|(
name|RMOutInterceptor
operator|.
name|class
argument_list|,
name|mocked
argument_list|)
decl_stmt|;
name|Message
name|message
init|=
name|control
operator|.
name|createMock
argument_list|(
name|Message
operator|.
name|class
argument_list|)
decl_stmt|;
name|EasyMock
operator|.
name|expect
argument_list|(
name|interceptor
operator|.
name|isRuntimeFault
argument_list|(
name|message
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|EasyMock
operator|.
name|expect
argument_list|(
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|REQUESTOR_ROLE
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
name|Boolean
operator|.
name|FALSE
argument_list|)
operator|.
name|anyTimes
argument_list|()
expr_stmt|;
name|EasyMock
operator|.
name|expect
argument_list|(
name|message
operator|.
name|get
argument_list|(
name|JAXWSAConstants
operator|.
name|SERVER_ADDRESSING_PROPERTIES_OUTBOUND
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|control
operator|.
name|replay
argument_list|()
expr_stmt|;
name|interceptor
operator|.
name|handle
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|control
operator|.
name|verify
argument_list|()
expr_stmt|;
block|}
comment|/*    @Test     public void testHandleApplicationMessage() throws NoSuchMethodException, SequenceFault, RMException {         AddressingPropertiesImpl maps = createMAPs("greetMe", "localhost:9000/GreeterPort",              org.apache.cxf.ws.addressing.Names.WSA_NONE_ADDRESS);         Method[] mocked = new Method[] {             AbstractRMInterceptor.class.getDeclaredMethod("getManager", new Class[]{}),             RMOutInterceptor.class.getDeclaredMethod("isRuntimeFault", new Class[] {Message.class}),             RMOutInterceptor.class.getDeclaredMethod("addAcknowledgements",                 new Class[] {Destination.class, RMProperties.class, Identifier.class,                               AttributedURIType.class})                     };         RMOutInterceptor interceptor = control.createMock(RMOutInterceptor.class, mocked);                  RMManager manager = control.createMock(RMManager.class);         EasyMock.expect(interceptor.getManager()).andReturn(manager).times(5);                  Message message = control.createMock(Message.class);         EasyMock.expect(interceptor.isRuntimeFault(message)).andReturn(false);         Exchange ex = control.createMock(Exchange.class);         EasyMock.expect(message.getExchange()).andReturn(ex).anyTimes();         EasyMock.expect(ex.getOutMessage()).andReturn(message).times(1);         EasyMock.expect(ex.put("defer.uncorrelated.message.abort", Boolean.TRUE)).andReturn(null);                EasyMock.expect(message.get(Message.REQUESTOR_ROLE)).andReturn(Boolean.TRUE).anyTimes();                 EasyMock.expect(message.get(JAXWSAConstants.CLIENT_ADDRESSING_PROPERTIES_OUTBOUND))             .andReturn(maps).anyTimes();         RMProperties rmpsOut = new RMProperties();         EasyMock.expect(message.get(RMMessageConstants.RM_PROPERTIES_OUTBOUND)).andReturn(rmpsOut);         InterceptorChain chain = control.createMock(InterceptorChain.class);         EasyMock.expect(message.getInterceptorChain()).andReturn(chain);         chain.add(EasyMock.isA(RetransmissionInterceptor.class));         EasyMock.expectLastCall();         RetransmissionQueue queue = control.createMock(RetransmissionQueue.class);         EasyMock.expect(manager.getRetransmissionQueue()).andReturn(queue);         queue.start();         EasyMock.expectLastCall();                          Source source = control.createMock(Source.class);         EasyMock.expect(manager.getSource(message)).andReturn(source);         Destination destination = control.createMock(Destination.class);         EasyMock.expect(manager.getDestination(message)).andReturn(destination);         SourceSequence sseq = control.createMock(SourceSequence.class);         EasyMock.expect(manager.getSequence((Identifier)EasyMock.isNull(), EasyMock.same(message),                                          EasyMock.same(maps))).andReturn(sseq);         EasyMock.expect(sseq.nextMessageNumber((Identifier)EasyMock.isNull(),              (Long)EasyMock.eq(0L), EasyMock.eq(false))).andReturn(new Long(10));         EasyMock.expect(sseq.isLastMessage()).andReturn(false);         interceptor.addAcknowledgements(EasyMock.same(destination), EasyMock.same(rmpsOut),              (Identifier)EasyMock.isNull(), EasyMock.isA(AttributedURIType.class));         EasyMock.expectLastCall();         Identifier sid = control.createMock(Identifier.class);         EasyMock.expect(sseq.getIdentifier()).andReturn(sid);         EasyMock.expect(sseq.getCurrentMessageNr()).andReturn(new Long(10));                   control.replay();         interceptor.handle(message);         assertSame(sid, rmpsOut.getSequence().getIdentifier());                 assertEquals(new Long(10), rmpsOut.getSequence().getMessageNumber());         control.verify();     }   */
annotation|@
name|Test
specifier|public
name|void
name|testIsRuntimeFault
parameter_list|()
block|{
name|Message
name|message
init|=
name|control
operator|.
name|createMock
argument_list|(
name|Message
operator|.
name|class
argument_list|)
decl_stmt|;
name|Exchange
name|exchange
init|=
name|control
operator|.
name|createMock
argument_list|(
name|Exchange
operator|.
name|class
argument_list|)
decl_stmt|;
name|EasyMock
operator|.
name|expect
argument_list|(
name|message
operator|.
name|getExchange
argument_list|()
argument_list|)
operator|.
name|andReturn
argument_list|(
name|exchange
argument_list|)
operator|.
name|times
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|EasyMock
operator|.
name|expect
argument_list|(
name|exchange
operator|.
name|getOutFaultMessage
argument_list|()
argument_list|)
operator|.
name|andReturn
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|EasyMock
operator|.
name|expect
argument_list|(
name|message
operator|.
name|get
argument_list|(
name|FaultMode
operator|.
name|class
argument_list|)
argument_list|)
operator|.
name|andReturn
argument_list|(
name|FaultMode
operator|.
name|RUNTIME_FAULT
argument_list|)
expr_stmt|;
name|control
operator|.
name|replay
argument_list|()
expr_stmt|;
name|RMOutInterceptor
name|rmi
init|=
operator|new
name|RMOutInterceptor
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|rmi
operator|.
name|isRuntimeFault
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
name|control
operator|.
name|verify
argument_list|()
expr_stmt|;
name|control
operator|.
name|reset
argument_list|()
expr_stmt|;
name|EasyMock
operator|.
name|expect
argument_list|(
name|message
operator|.
name|getExchange
argument_list|()
argument_list|)
operator|.
name|andReturn
argument_list|(
name|exchange
argument_list|)
operator|.
name|times
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|EasyMock
operator|.
name|expect
argument_list|(
name|exchange
operator|.
name|getOutFaultMessage
argument_list|()
argument_list|)
operator|.
name|andReturn
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|control
operator|.
name|replay
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|rmi
operator|.
name|isRuntimeFault
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
name|control
operator|.
name|verify
argument_list|()
expr_stmt|;
block|}
comment|/*    private AddressingPropertiesImpl createMAPs(String action, String to, String replyTo) {         AddressingPropertiesImpl maps = new AddressingPropertiesImpl();         maps.setTo(RMUtils.createReference(to));         EndpointReferenceType epr = RMUtils.createReference(replyTo);         maps.setReplyTo(epr);         return maps;                 }   */
block|}
end_class

end_unit

