begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements. See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
operator|.
name|soap
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimerTask
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|namespace
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamConstants
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamReader
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Element
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|Bus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|soap
operator|.
name|SoapHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|soap
operator|.
name|SoapMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|soap
operator|.
name|SoapVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|soap
operator|.
name|interceptor
operator|.
name|SoapOutInterceptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|common
operator|.
name|logging
operator|.
name|LogUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|endpoint
operator|.
name|DeferredConduitSelector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|endpoint
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|helpers
operator|.
name|DOMUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|interceptor
operator|.
name|AbstractOutDatabindingInterceptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|interceptor
operator|.
name|Fault
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|interceptor
operator|.
name|Interceptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|io
operator|.
name|CachedOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|io
operator|.
name|CachedOutputStreamCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|io
operator|.
name|WriteOnCloseOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|MessageUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|phase
operator|.
name|Phase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|phase
operator|.
name|PhaseChainCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|phase
operator|.
name|PhaseInterceptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|phase
operator|.
name|PhaseInterceptorChain
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|phase
operator|.
name|PhaseManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|service
operator|.
name|model
operator|.
name|EndpointInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|staxutils
operator|.
name|PartialXMLStreamReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|staxutils
operator|.
name|StaxUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|staxutils
operator|.
name|W3CDOMStreamWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|Conduit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|MessageObserver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|workqueue
operator|.
name|SynchronousExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|addressing
operator|.
name|AddressingProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|addressing
operator|.
name|AttributedURIType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|addressing
operator|.
name|EndpointReferenceType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|addressing
operator|.
name|soap
operator|.
name|MAPCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|policy
operator|.
name|AssertionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|policy
operator|.
name|builder
operator|.
name|jaxb
operator|.
name|JaxbAssertion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
operator|.
name|ProtocolVariation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
operator|.
name|RMCaptureOutInterceptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
operator|.
name|RMConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
operator|.
name|RMContextUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
operator|.
name|RMEndpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
operator|.
name|RMException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
operator|.
name|RMManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
operator|.
name|RMMessageConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
operator|.
name|RMProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
operator|.
name|RMUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
operator|.
name|RetransmissionQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
operator|.
name|RetryStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
operator|.
name|SourceSequence
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
operator|.
name|manager
operator|.
name|RetryPolicyType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
operator|.
name|persistence
operator|.
name|RMStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
operator|.
name|v200702
operator|.
name|Identifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rm
operator|.
name|v200702
operator|.
name|SequenceType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|rmp
operator|.
name|v200502
operator|.
name|RMAssertion
import|;
end_import

begin_comment
comment|/**  *   */
end_comment

begin_class
specifier|public
class|class
name|RetransmissionQueueImpl
implements|implements
name|RetransmissionQueue
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LogUtils
operator|.
name|getL7dLogger
argument_list|(
name|RetransmissionQueueImpl
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ResendCandidate
argument_list|>
argument_list|>
name|candidates
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ResendCandidate
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ResendCandidate
argument_list|>
argument_list|>
name|suspendedCandidates
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ResendCandidate
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Resender
name|resender
decl_stmt|;
specifier|private
name|RMManager
name|manager
decl_stmt|;
specifier|private
name|int
name|unacknowledgedCount
decl_stmt|;
specifier|public
name|RetransmissionQueueImpl
parameter_list|(
name|RMManager
name|m
parameter_list|)
block|{
name|manager
operator|=
name|m
expr_stmt|;
block|}
specifier|public
name|RMManager
name|getManager
parameter_list|()
block|{
return|return
name|manager
return|;
block|}
specifier|public
name|void
name|setManager
parameter_list|(
name|RMManager
name|m
parameter_list|)
block|{
name|manager
operator|=
name|m
expr_stmt|;
block|}
specifier|public
name|void
name|addUnacknowledged
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
name|cacheUnacknowledged
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param seq the sequence under consideration      * @return the number of unacknowledged messages for that sequence      */
specifier|public
specifier|synchronized
name|int
name|countUnacknowledged
parameter_list|(
name|SourceSequence
name|seq
parameter_list|)
block|{
name|List
argument_list|<
name|ResendCandidate
argument_list|>
name|sequenceCandidates
init|=
name|getSequenceCandidates
argument_list|(
name|seq
argument_list|)
decl_stmt|;
return|return
name|sequenceCandidates
operator|==
literal|null
condition|?
literal|0
else|:
name|sequenceCandidates
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|int
name|countUnacknowledged
parameter_list|()
block|{
return|return
name|unacknowledgedCount
return|;
block|}
comment|/**      * @return true if there are no unacknowledged messages in the queue      */
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
literal|0
operator|==
name|getUnacknowledged
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Purge all candidates for the given sequence that have been acknowledged.      *       * @param seq the sequence object.      */
specifier|public
name|void
name|purgeAcknowledged
parameter_list|(
name|SourceSequence
name|seq
parameter_list|)
block|{
name|purgeCandidates
argument_list|(
name|seq
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Purge all candidates for the given sequence. This method is used to       * terminate the sequence by force and release the resource associated      * with the sequence.      *        * @param seq the sequence object.      */
specifier|public
name|void
name|purgeAll
parameter_list|(
name|SourceSequence
name|seq
parameter_list|)
block|{
name|purgeCandidates
argument_list|(
name|seq
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|purgeCandidates
parameter_list|(
name|SourceSequence
name|seq
parameter_list|,
name|boolean
name|any
parameter_list|)
block|{
name|Collection
argument_list|<
name|Long
argument_list|>
name|purged
init|=
operator|new
name|ArrayList
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|ResendCandidate
argument_list|>
name|resends
init|=
operator|new
name|ArrayList
argument_list|<
name|ResendCandidate
argument_list|>
argument_list|()
decl_stmt|;
name|Identifier
name|sid
init|=
name|seq
operator|.
name|getIdentifier
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
literal|"Start purging resend candidates."
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ResendCandidate
argument_list|>
name|sequenceCandidates
init|=
name|getSequenceCandidates
argument_list|(
name|seq
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|sequenceCandidates
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|sequenceCandidates
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ResendCandidate
name|candidate
init|=
name|sequenceCandidates
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|m
init|=
name|candidate
operator|.
name|getNumber
argument_list|()
decl_stmt|;
if|if
condition|(
name|any
operator|||
name|seq
operator|.
name|isAcknowledged
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|sequenceCandidates
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|candidate
operator|.
name|resolved
argument_list|()
expr_stmt|;
name|unacknowledgedCount
operator|--
expr_stmt|;
name|purged
operator|.
name|add
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|resends
operator|.
name|add
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sequenceCandidates
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|candidates
operator|.
name|remove
argument_list|(
name|sid
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|fine
argument_list|(
literal|"Completed purging resend candidates."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|purged
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|RMStore
name|store
init|=
name|manager
operator|.
name|getStore
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|store
condition|)
block|{
name|store
operator|.
name|removeMessages
argument_list|(
name|sid
argument_list|,
name|purged
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|RMEndpoint
name|rmEndpoint
init|=
name|seq
operator|.
name|getSource
argument_list|()
operator|.
name|getReliableEndpoint
argument_list|()
decl_stmt|;
for|for
control|(
name|ResendCandidate
name|resend
range|:
name|resends
control|)
block|{
name|rmEndpoint
operator|.
name|handleAcknowledgment
argument_list|(
name|sid
operator|.
name|getValue
argument_list|()
argument_list|,
name|resend
operator|.
name|getNumber
argument_list|()
argument_list|,
name|resend
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|List
argument_list|<
name|Long
argument_list|>
name|getUnacknowledgedMessageNumbers
parameter_list|(
name|SourceSequence
name|seq
parameter_list|)
block|{
name|List
argument_list|<
name|Long
argument_list|>
name|unacknowledged
init|=
operator|new
name|ArrayList
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ResendCandidate
argument_list|>
name|sequenceCandidates
init|=
name|getSequenceCandidates
argument_list|(
name|seq
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|sequenceCandidates
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sequenceCandidates
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ResendCandidate
name|candidate
init|=
name|sequenceCandidates
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|unacknowledged
operator|.
name|add
argument_list|(
name|candidate
operator|.
name|getNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|unacknowledged
return|;
block|}
specifier|public
name|RetryStatus
name|getRetransmissionStatus
parameter_list|(
name|SourceSequence
name|seq
parameter_list|,
name|long
name|num
parameter_list|)
block|{
name|List
argument_list|<
name|ResendCandidate
argument_list|>
name|sequenceCandidates
init|=
name|getSequenceCandidates
argument_list|(
name|seq
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|sequenceCandidates
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sequenceCandidates
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ResendCandidate
name|candidate
init|=
name|sequenceCandidates
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|==
name|candidate
operator|.
name|getNumber
argument_list|()
condition|)
block|{
return|return
name|candidate
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|Map
argument_list|<
name|Long
argument_list|,
name|RetryStatus
argument_list|>
name|getRetransmissionStatuses
parameter_list|(
name|SourceSequence
name|seq
parameter_list|)
block|{
name|Map
argument_list|<
name|Long
argument_list|,
name|RetryStatus
argument_list|>
name|cp
init|=
operator|new
name|HashMap
argument_list|<
name|Long
argument_list|,
name|RetryStatus
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ResendCandidate
argument_list|>
name|sequenceCandidates
init|=
name|getSequenceCandidates
argument_list|(
name|seq
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|sequenceCandidates
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sequenceCandidates
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ResendCandidate
name|candidate
init|=
name|sequenceCandidates
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|cp
operator|.
name|put
argument_list|(
name|candidate
operator|.
name|getNumber
argument_list|()
argument_list|,
name|candidate
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|cp
return|;
block|}
comment|/**      * Initiate resends.      */
specifier|public
name|void
name|start
parameter_list|()
block|{
if|if
condition|(
literal|null
operator|!=
name|resender
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|fine
argument_list|(
literal|"Starting retransmission queue"
argument_list|)
expr_stmt|;
comment|// setup resender
name|resender
operator|=
name|getDefaultResender
argument_list|()
expr_stmt|;
block|}
comment|/**      * Stops resending messages for the specified source sequence.      */
specifier|public
name|void
name|stop
parameter_list|(
name|SourceSequence
name|seq
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|List
argument_list|<
name|ResendCandidate
argument_list|>
name|sequenceCandidates
init|=
name|getSequenceCandidates
argument_list|(
name|seq
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|sequenceCandidates
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|sequenceCandidates
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ResendCandidate
name|candidate
init|=
name|sequenceCandidates
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|candidate
operator|.
name|cancel
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Cancelled resends for sequence {0}."
argument_list|,
name|seq
operator|.
name|getIdentifier
argument_list|()
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|void
name|stop
parameter_list|()
block|{              }
specifier|public
name|void
name|suspend
parameter_list|(
name|SourceSequence
name|seq
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|String
name|key
init|=
name|seq
operator|.
name|getIdentifier
argument_list|()
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ResendCandidate
argument_list|>
name|sequenceCandidates
init|=
name|candidates
operator|.
name|remove
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|sequenceCandidates
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|sequenceCandidates
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ResendCandidate
name|candidate
init|=
name|sequenceCandidates
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|candidate
operator|.
name|suspend
argument_list|()
expr_stmt|;
block|}
name|suspendedCandidates
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|sequenceCandidates
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Suspended resends for sequence {0}."
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|resume
parameter_list|(
name|SourceSequence
name|seq
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|String
name|key
init|=
name|seq
operator|.
name|getIdentifier
argument_list|()
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ResendCandidate
argument_list|>
name|sequenceCandidates
init|=
name|suspendedCandidates
operator|.
name|remove
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|sequenceCandidates
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sequenceCandidates
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ResendCandidate
name|candidate
init|=
name|sequenceCandidates
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|candidate
operator|.
name|resume
argument_list|()
expr_stmt|;
block|}
name|candidates
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|sequenceCandidates
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Resumed resends for sequence {0}."
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * @return the exponential backoff      */
specifier|protected
name|int
name|getExponentialBackoff
parameter_list|()
block|{
return|return
name|DEFAULT_EXPONENTIAL_BACKOFF
return|;
block|}
comment|/**      * @param message the message context      * @return a ResendCandidate      */
specifier|protected
name|ResendCandidate
name|createResendCandidate
parameter_list|(
name|SoapMessage
name|message
parameter_list|)
block|{
return|return
operator|new
name|ResendCandidate
argument_list|(
name|message
argument_list|)
return|;
block|}
comment|/**      * Accepts a new resend candidate.      *       * @param ctx the message context.      * @return ResendCandidate      */
specifier|protected
name|ResendCandidate
name|cacheUnacknowledged
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
name|RMProperties
name|rmps
init|=
name|RMContextUtils
operator|.
name|retrieveRMProperties
argument_list|(
name|message
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|SequenceType
name|st
init|=
name|rmps
operator|.
name|getSequence
argument_list|()
decl_stmt|;
name|Identifier
name|sid
init|=
name|st
operator|.
name|getIdentifier
argument_list|()
decl_stmt|;
name|String
name|key
init|=
name|sid
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ResendCandidate
name|candidate
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|List
argument_list|<
name|ResendCandidate
argument_list|>
name|sequenceCandidates
init|=
name|getSequenceCandidates
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|sequenceCandidates
condition|)
block|{
name|sequenceCandidates
operator|=
operator|new
name|ArrayList
argument_list|<
name|ResendCandidate
argument_list|>
argument_list|()
expr_stmt|;
name|candidates
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|sequenceCandidates
argument_list|)
expr_stmt|;
block|}
name|candidate
operator|=
operator|new
name|ResendCandidate
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSequenceSuspended
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|candidate
operator|.
name|suspend
argument_list|()
expr_stmt|;
block|}
name|sequenceCandidates
operator|.
name|add
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|unacknowledgedCount
operator|++
expr_stmt|;
block|}
name|LOG
operator|.
name|fine
argument_list|(
literal|"Cached unacknowledged message."
argument_list|)
expr_stmt|;
try|try
block|{
name|RMEndpoint
name|rme
init|=
name|manager
operator|.
name|getReliableEndpoint
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|rme
operator|.
name|handleAccept
argument_list|(
name|key
argument_list|,
name|st
operator|.
name|getMessageNumber
argument_list|()
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RMException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"Could not find reliable endpoint for message"
argument_list|)
expr_stmt|;
block|}
return|return
name|candidate
return|;
block|}
comment|/**      * @return a map relating sequence ID to a lists of un-acknowledged messages      *         for that sequence      */
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ResendCandidate
argument_list|>
argument_list|>
name|getUnacknowledged
parameter_list|()
block|{
return|return
name|candidates
return|;
block|}
comment|/**      * @param seq the sequence under consideration      * @return the list of resend candidates for that sequence      * @pre called with mutex held      */
specifier|protected
name|List
argument_list|<
name|ResendCandidate
argument_list|>
name|getSequenceCandidates
parameter_list|(
name|SourceSequence
name|seq
parameter_list|)
block|{
return|return
name|getSequenceCandidates
argument_list|(
name|seq
operator|.
name|getIdentifier
argument_list|()
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * @param key the sequence identifier under consideration      * @return the list of resend candidates for that sequence      * @pre called with mutex held      */
specifier|protected
name|List
argument_list|<
name|ResendCandidate
argument_list|>
name|getSequenceCandidates
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|List
argument_list|<
name|ResendCandidate
argument_list|>
name|sc
init|=
name|candidates
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|sc
condition|)
block|{
name|sc
operator|=
name|suspendedCandidates
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
return|return
name|sc
return|;
block|}
comment|/**      * @param key the sequence identifier under consideration      * @return true if the sequence is currently suspended; false otherwise      * @pre called with mutex held      */
specifier|protected
name|boolean
name|isSequenceSuspended
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|suspendedCandidates
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**      * Represents a candidate for resend, i.e. an unacked outgoing message.      */
specifier|protected
class|class
name|ResendCandidate
implements|implements
name|Runnable
implements|,
name|RetryStatus
block|{
specifier|private
name|Message
name|message
decl_stmt|;
specifier|private
name|long
name|number
decl_stmt|;
specifier|private
name|Date
name|next
decl_stmt|;
specifier|private
name|TimerTask
name|nextTask
decl_stmt|;
specifier|private
name|int
name|retries
decl_stmt|;
specifier|private
name|int
name|maxRetries
decl_stmt|;
specifier|private
name|long
name|nextInterval
decl_stmt|;
specifier|private
name|long
name|backoff
decl_stmt|;
specifier|private
name|boolean
name|pending
decl_stmt|;
specifier|private
name|boolean
name|suspended
decl_stmt|;
specifier|private
name|boolean
name|includeAckRequested
decl_stmt|;
comment|/**          * @param ctx message context for the unacked message          */
specifier|protected
name|ResendCandidate
parameter_list|(
name|Message
name|m
parameter_list|)
block|{
name|message
operator|=
name|m
expr_stmt|;
name|retries
operator|=
literal|0
expr_stmt|;
name|RMConfiguration
name|cfg
init|=
name|manager
operator|.
name|getEffectiveConfiguration
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|long
name|baseRetransmissionInterval
init|=
name|cfg
operator|.
name|getBaseRetransmissionInterval
argument_list|()
operator|.
name|longValue
argument_list|()
decl_stmt|;
name|backoff
operator|=
name|cfg
operator|.
name|isExponentialBackoff
argument_list|()
condition|?
name|RetransmissionQueue
operator|.
name|DEFAULT_EXPONENTIAL_BACKOFF
else|:
literal|1
expr_stmt|;
name|next
operator|=
operator|new
name|Date
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|baseRetransmissionInterval
argument_list|)
expr_stmt|;
name|nextInterval
operator|=
name|baseRetransmissionInterval
operator|*
name|backoff
expr_stmt|;
name|RetryPolicyType
name|rmrp
init|=
literal|null
operator|!=
name|manager
operator|.
name|getSourcePolicy
argument_list|()
condition|?
name|manager
operator|.
name|getSourcePolicy
argument_list|()
operator|.
name|getRetryPolicy
argument_list|()
else|:
literal|null
decl_stmt|;
name|maxRetries
operator|=
literal|null
operator|!=
name|rmrp
condition|?
name|rmrp
operator|.
name|getMaxRetries
argument_list|()
else|:
operator|-
literal|1
expr_stmt|;
name|AddressingProperties
name|maps
init|=
name|RMContextUtils
operator|.
name|retrieveMAPs
argument_list|(
name|message
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|AttributedURIType
name|to
init|=
literal|null
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|maps
condition|)
block|{
name|to
operator|=
name|maps
operator|.
name|getTo
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|to
operator|!=
literal|null
operator|&&
name|RMUtils
operator|.
name|getAddressingConstants
argument_list|()
operator|.
name|getAnonymousURI
argument_list|()
operator|.
name|equals
argument_list|(
name|to
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|INFO
argument_list|,
literal|"Cannot resend to anonymous target.  Not scheduling a resend."
argument_list|)
expr_stmt|;
return|return;
block|}
name|RMProperties
name|rmprops
init|=
name|RMContextUtils
operator|.
name|retrieveRMProperties
argument_list|(
name|message
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|rmprops
condition|)
block|{
name|number
operator|=
name|rmprops
operator|.
name|getSequence
argument_list|()
operator|.
name|getMessageNumber
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|manager
operator|.
name|getTimer
argument_list|()
operator|&&
name|maxRetries
operator|!=
literal|0
condition|)
block|{
name|schedule
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**          * Initiate resend asynchronsly.          *           * @param requestAcknowledge true if a AckRequest header is to be sent          *            with resend          */
specifier|protected
name|void
name|initiate
parameter_list|(
name|boolean
name|requestAcknowledge
parameter_list|)
block|{
name|includeAckRequested
operator|=
name|requestAcknowledge
expr_stmt|;
name|pending
operator|=
literal|true
expr_stmt|;
name|Endpoint
name|ep
init|=
name|message
operator|.
name|getExchange
argument_list|()
operator|.
name|getEndpoint
argument_list|()
decl_stmt|;
name|Executor
name|executor
init|=
name|ep
operator|.
name|getExecutor
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|executor
condition|)
block|{
name|executor
operator|=
name|ep
operator|.
name|getService
argument_list|()
operator|.
name|getExecutor
argument_list|()
expr_stmt|;
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
block|{
name|executor
operator|=
name|SynchronousExecutor
operator|.
name|getInstance
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Using service executor {0}"
argument_list|,
name|executor
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Using endpoint executor {0}"
argument_list|,
name|executor
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|executor
operator|.
name|execute
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RejectedExecutionException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"RESEND_INITIATION_FAILED_MSG"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
comment|// ensure ACK wasn't received while this task was enqueued
comment|// on executor
if|if
condition|(
name|isPending
argument_list|()
condition|)
block|{
name|resender
operator|.
name|resend
argument_list|(
name|message
argument_list|,
name|includeAckRequested
argument_list|)
expr_stmt|;
name|includeAckRequested
operator|=
literal|false
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|attempted
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|long
name|getNumber
parameter_list|()
block|{
return|return
name|number
return|;
block|}
comment|/**          * @return number of resend attempts          */
specifier|public
name|int
name|getRetries
parameter_list|()
block|{
return|return
name|retries
return|;
block|}
comment|/**          * @return number of max resend attempts          */
specifier|public
name|int
name|getMaxRetries
parameter_list|()
block|{
return|return
name|maxRetries
return|;
block|}
comment|/**          * @return date of next resend          */
specifier|public
name|Date
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
comment|/**          * @return date of previous resend or null if no attempt is yet taken           */
specifier|public
name|Date
name|getPrevious
parameter_list|()
block|{
if|if
condition|(
name|retries
operator|>
literal|0
condition|)
block|{
return|return
operator|new
name|Date
argument_list|(
name|next
operator|.
name|getTime
argument_list|()
operator|-
name|nextInterval
operator|/
name|backoff
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|long
name|getNextInterval
parameter_list|()
block|{
return|return
name|nextInterval
return|;
block|}
specifier|public
name|long
name|getBackoff
parameter_list|()
block|{
return|return
name|backoff
return|;
block|}
specifier|public
name|boolean
name|isSuspended
parameter_list|()
block|{
return|return
name|suspended
return|;
block|}
comment|/**          * @return if resend attempt is pending          */
specifier|public
specifier|synchronized
name|boolean
name|isPending
parameter_list|()
block|{
return|return
name|pending
return|;
block|}
comment|/**          * ACK has been received for this candidate.          */
specifier|protected
specifier|synchronized
name|void
name|resolved
parameter_list|()
block|{
name|pending
operator|=
literal|false
expr_stmt|;
name|next
operator|=
literal|null
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|nextTask
condition|)
block|{
name|nextTask
operator|.
name|cancel
argument_list|()
expr_stmt|;
name|releaseSavedMessage
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**          * Cancel further resend (although no ACK has been received).          */
specifier|protected
specifier|synchronized
name|void
name|cancel
parameter_list|()
block|{
if|if
condition|(
literal|null
operator|!=
name|nextTask
condition|)
block|{
name|nextTask
operator|.
name|cancel
argument_list|()
expr_stmt|;
name|releaseSavedMessage
argument_list|()
expr_stmt|;
block|}
block|}
specifier|protected
specifier|synchronized
name|void
name|suspend
parameter_list|()
block|{
name|suspended
operator|=
literal|true
expr_stmt|;
name|pending
operator|=
literal|false
expr_stmt|;
comment|//TODO release the message and later reload it upon resume
comment|//cancel();
if|if
condition|(
literal|null
operator|!=
name|nextTask
condition|)
block|{
name|nextTask
operator|.
name|cancel
argument_list|()
expr_stmt|;
block|}
block|}
specifier|protected
specifier|synchronized
name|void
name|resume
parameter_list|()
block|{
name|suspended
operator|=
literal|false
expr_stmt|;
name|next
operator|=
operator|new
name|Date
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|attempted
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|releaseSavedMessage
parameter_list|()
block|{
name|CachedOutputStream
name|cos
init|=
operator|(
name|CachedOutputStream
operator|)
name|message
operator|.
name|get
argument_list|(
name|RMMessageConstants
operator|.
name|SAVED_CONTENT
argument_list|)
decl_stmt|;
if|if
condition|(
name|cos
operator|!=
literal|null
condition|)
block|{
name|cos
operator|.
name|releaseTempFileHold
argument_list|()
expr_stmt|;
try|try
block|{
name|cos
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
comment|// REVISIT -- When reference holder is not needed anymore, code can be removed.
name|Closeable
name|closeable
init|=
operator|(
name|Closeable
operator|)
name|message
operator|.
name|get
argument_list|(
name|RMMessageConstants
operator|.
name|ATTACHMENTS_CLOSEABLE
argument_list|)
decl_stmt|;
if|if
condition|(
name|closeable
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|closeable
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
block|}
comment|/**          * @return associated message context          */
specifier|protected
name|Message
name|getMessage
parameter_list|()
block|{
return|return
name|message
return|;
block|}
comment|/**          * A resend has been attempted. Schedule the next attempt.          */
specifier|protected
specifier|synchronized
name|void
name|attempted
parameter_list|()
block|{
name|pending
operator|=
literal|false
expr_stmt|;
name|retries
operator|++
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|next
operator|&&
name|maxRetries
operator|!=
name|retries
condition|)
block|{
name|next
operator|=
operator|new
name|Date
argument_list|(
name|next
operator|.
name|getTime
argument_list|()
operator|+
name|nextInterval
argument_list|)
expr_stmt|;
name|nextInterval
operator|*=
name|backoff
expr_stmt|;
name|schedule
argument_list|()
expr_stmt|;
block|}
block|}
specifier|protected
specifier|final
specifier|synchronized
name|void
name|schedule
parameter_list|()
block|{
if|if
condition|(
literal|null
operator|==
name|manager
operator|.
name|getTimer
argument_list|()
condition|)
block|{
return|return;
block|}
class|class
name|ResendTask
extends|extends
name|TimerTask
block|{
name|ResendCandidate
name|candidate
decl_stmt|;
name|ResendTask
parameter_list|(
name|ResendCandidate
name|c
parameter_list|)
block|{
name|candidate
operator|=
name|c
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
operator|!
name|candidate
operator|.
name|isPending
argument_list|()
condition|)
block|{
name|candidate
operator|.
name|initiate
argument_list|(
name|includeAckRequested
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|nextTask
operator|=
operator|new
name|ResendTask
argument_list|(
name|this
argument_list|)
expr_stmt|;
try|try
block|{
name|manager
operator|.
name|getTimer
argument_list|()
operator|.
name|schedule
argument_list|(
name|nextTask
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"SCHEDULE_RESEND_FAILED_MSG"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Encapsulates actual resend logic (pluggable to facilitate unit testing)      */
specifier|public
interface|interface
name|Resender
block|{
comment|/**          * Resend mechanics.          *           * @param message          * @param if a AckRequest should be included          */
name|void
name|resend
parameter_list|(
name|Message
name|message
parameter_list|,
name|boolean
name|requestAcknowledge
parameter_list|)
function_decl|;
block|}
comment|/**      * Create default Resender logic.      *       * @return default Resender      */
specifier|protected
specifier|final
name|Resender
name|getDefaultResender
parameter_list|()
block|{
return|return
operator|new
name|Resender
argument_list|()
block|{
specifier|public
name|void
name|resend
parameter_list|(
name|Message
name|message
parameter_list|,
name|boolean
name|requestAcknowledge
parameter_list|)
block|{
name|RMProperties
name|properties
init|=
name|RMContextUtils
operator|.
name|retrieveRMProperties
argument_list|(
name|message
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|SequenceType
name|st
init|=
name|properties
operator|.
name|getSequence
argument_list|()
decl_stmt|;
if|if
condition|(
name|st
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|INFO
argument_list|,
literal|"RESEND_MSG"
argument_list|,
name|st
operator|.
name|getMessageNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|message
operator|instanceof
name|SoapMessage
condition|)
block|{
name|doResend
argument_list|(
operator|(
name|SoapMessage
operator|)
name|message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doResend
argument_list|(
operator|new
name|SoapMessage
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|;
block|}
comment|/**      * Plug in replacement resend logic (facilitates unit testing).      *       * @param replacement resend logic      */
specifier|protected
name|void
name|replaceResender
parameter_list|(
name|Resender
name|replacement
parameter_list|)
block|{
name|resender
operator|=
name|replacement
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|protected
name|JaxbAssertion
argument_list|<
name|RMAssertion
argument_list|>
name|getAssertion
parameter_list|(
name|AssertionInfo
name|ai
parameter_list|)
block|{
return|return
operator|(
name|JaxbAssertion
argument_list|<
name|RMAssertion
argument_list|>
operator|)
name|ai
operator|.
name|getAssertion
argument_list|()
return|;
block|}
specifier|private
name|void
name|readHeaders
parameter_list|(
name|XMLStreamReader
name|xmlReader
parameter_list|,
name|SoapMessage
name|message
parameter_list|)
throws|throws
name|XMLStreamException
block|{
comment|// read header portion of SOAP document into DOM
name|SoapVersion
name|version
init|=
name|message
operator|.
name|getVersion
argument_list|()
decl_stmt|;
name|XMLStreamReader
name|filteredReader
init|=
operator|new
name|PartialXMLStreamReader
argument_list|(
name|xmlReader
argument_list|,
name|version
operator|.
name|getBody
argument_list|()
argument_list|)
decl_stmt|;
name|Node
name|nd
init|=
name|message
operator|.
name|getContent
argument_list|(
name|Node
operator|.
name|class
argument_list|)
decl_stmt|;
name|W3CDOMStreamWriter
name|writer
init|=
name|message
operator|.
name|get
argument_list|(
name|W3CDOMStreamWriter
operator|.
name|class
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|StaxUtils
operator|.
name|copy
argument_list|(
name|filteredReader
argument_list|,
name|writer
argument_list|)
expr_stmt|;
name|doc
operator|=
name|writer
operator|.
name|getDocument
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|instanceof
name|Document
condition|)
block|{
name|doc
operator|=
operator|(
name|Document
operator|)
name|nd
expr_stmt|;
name|StaxUtils
operator|.
name|readDocElements
argument_list|(
name|doc
argument_list|,
name|doc
argument_list|,
name|filteredReader
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doc
operator|=
name|StaxUtils
operator|.
name|read
argument_list|(
name|filteredReader
argument_list|)
expr_stmt|;
name|message
operator|.
name|setContent
argument_list|(
name|Node
operator|.
name|class
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
comment|// get the actual SOAP header
name|Element
name|element
init|=
name|doc
operator|.
name|getDocumentElement
argument_list|()
decl_stmt|;
name|QName
name|header
init|=
name|version
operator|.
name|getHeader
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Element
argument_list|>
name|elemList
init|=
name|DOMUtils
operator|.
name|findAllElementsByTagNameNS
argument_list|(
name|element
argument_list|,
name|header
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|header
operator|.
name|getLocalPart
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Element
name|elem
range|:
name|elemList
control|)
block|{
comment|// set all child elements as headers for message transmission
name|Element
name|hel
init|=
name|DOMUtils
operator|.
name|getFirstElement
argument_list|(
name|elem
argument_list|)
decl_stmt|;
while|while
condition|(
name|hel
operator|!=
literal|null
condition|)
block|{
name|SoapHeader
name|sheader
init|=
operator|new
name|SoapHeader
argument_list|(
name|DOMUtils
operator|.
name|getElementQName
argument_list|(
name|hel
argument_list|)
argument_list|,
name|hel
argument_list|)
decl_stmt|;
name|message
operator|.
name|getHeaders
argument_list|()
operator|.
name|add
argument_list|(
name|sheader
argument_list|)
expr_stmt|;
name|hel
operator|=
name|DOMUtils
operator|.
name|getNextElement
argument_list|(
name|hel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|doResend
parameter_list|(
name|SoapMessage
name|message
parameter_list|)
block|{
try|try
block|{
comment|// initialize copied interceptor chain for message
name|PhaseInterceptorChain
name|retransmitChain
init|=
name|manager
operator|.
name|getRetransmitChain
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|ProtocolVariation
name|protocol
init|=
name|RMContextUtils
operator|.
name|getProtocolVariation
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|Endpoint
name|endpoint
init|=
name|manager
operator|.
name|getReliableEndpoint
argument_list|(
name|message
argument_list|)
operator|.
name|getEndpoint
argument_list|(
name|protocol
argument_list|)
decl_stmt|;
name|PhaseChainCache
name|cache
init|=
operator|new
name|PhaseChainCache
argument_list|()
decl_stmt|;
name|boolean
name|after
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|retransmitChain
operator|==
literal|null
condition|)
block|{
comment|// no saved retransmit chain, so construct one from scratch (won't work for WS-Security on server, so
comment|//  need to fix)
name|retransmitChain
operator|=
name|buildRetransmitChain
argument_list|(
name|endpoint
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|after
operator|=
literal|false
expr_stmt|;
block|}
name|message
operator|.
name|setInterceptorChain
argument_list|(
name|retransmitChain
argument_list|)
expr_stmt|;
comment|// clear flag for SOAP out interceptor so envelope will be written
name|message
operator|.
name|remove
argument_list|(
name|SoapOutInterceptor
operator|.
name|WROTE_ENVELOPE_START
argument_list|)
expr_stmt|;
comment|// discard all saved content
name|Set
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|formats
init|=
name|message
operator|.
name|getContentFormats
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|CachedOutputStreamCallback
argument_list|>
name|callbacks
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|clas
range|:
name|formats
control|)
block|{
name|Object
name|content
init|=
name|message
operator|.
name|getContent
argument_list|(
name|clas
argument_list|)
decl_stmt|;
if|if
condition|(
name|content
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing "
operator|+
name|clas
operator|.
name|getName
argument_list|()
operator|+
literal|" content of actual type "
operator|+
name|content
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|message
operator|.
name|removeContent
argument_list|(
name|clas
argument_list|)
expr_stmt|;
if|if
condition|(
name|clas
operator|==
name|OutputStream
operator|.
name|class
operator|&&
name|content
operator|instanceof
name|WriteOnCloseOutputStream
condition|)
block|{
name|callbacks
operator|=
operator|(
operator|(
name|WriteOnCloseOutputStream
operator|)
name|content
operator|)
operator|.
name|getCallbacks
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// read SOAP headers from saved input stream
name|CachedOutputStream
name|cos
init|=
operator|(
name|CachedOutputStream
operator|)
name|message
operator|.
name|get
argument_list|(
name|RMMessageConstants
operator|.
name|SAVED_CONTENT
argument_list|)
decl_stmt|;
name|cos
operator|.
name|holdTempFile
argument_list|()
expr_stmt|;
comment|// CachedOutputStream is hold until delivering was successful
name|InputStream
name|is
init|=
name|cos
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
comment|// instance is needed to close input stream later on
name|XMLStreamReader
name|reader
init|=
name|StaxUtils
operator|.
name|createXMLStreamReader
argument_list|(
name|is
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|message
operator|.
name|getHeaders
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|reader
operator|.
name|getEventType
argument_list|()
operator|!=
name|XMLStreamConstants
operator|.
name|START_ELEMENT
operator|&&
name|reader
operator|.
name|nextTag
argument_list|()
operator|!=
name|XMLStreamConstants
operator|.
name|START_ELEMENT
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No document found"
argument_list|)
throw|;
block|}
name|readHeaders
argument_list|(
name|reader
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|int
name|event
decl_stmt|;
while|while
condition|(
operator|(
name|event
operator|=
name|reader
operator|.
name|nextTag
argument_list|()
operator|)
operator|!=
name|XMLStreamConstants
operator|.
name|START_ELEMENT
condition|)
block|{
if|if
condition|(
name|event
operator|==
name|XMLStreamConstants
operator|.
name|END_ELEMENT
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No body content present"
argument_list|)
throw|;
block|}
block|}
comment|// set message addressing properties
name|AddressingProperties
name|maps
init|=
operator|new
name|MAPCodec
argument_list|()
operator|.
name|unmarshalMAPs
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|RMContextUtils
operator|.
name|storeMAPs
argument_list|(
name|maps
argument_list|,
name|message
argument_list|,
literal|true
argument_list|,
name|MessageUtils
operator|.
name|isRequestor
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
name|AttributedURIType
name|to
init|=
literal|null
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|maps
condition|)
block|{
name|to
operator|=
name|maps
operator|.
name|getTo
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|==
name|to
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"NO_ADDRESS_FOR_RESEND_MSG"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|RMUtils
operator|.
name|getAddressingConstants
argument_list|()
operator|.
name|getAnonymousURI
argument_list|()
operator|.
name|equals
argument_list|(
name|to
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Cannot resend to anonymous target"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// initialize conduit for new message
name|Conduit
name|c
init|=
name|message
operator|.
name|getExchange
argument_list|()
operator|.
name|getConduit
argument_list|(
name|message
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
name|c
operator|=
name|buildConduit
argument_list|(
name|message
argument_list|,
name|endpoint
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
name|c
operator|.
name|prepare
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|// replace standard message marshaling with copy from saved stream
name|ListIterator
argument_list|<
name|Interceptor
argument_list|<
name|?
extends|extends
name|Message
argument_list|>
argument_list|>
name|iterator
init|=
name|retransmitChain
operator|.
name|getIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Interceptor
argument_list|<
name|?
extends|extends
name|Message
argument_list|>
name|incept
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// remove JAX-WS interceptors which handle message modes and such
if|if
condition|(
name|incept
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"org.apache.cxf.jaxws.interceptors"
argument_list|)
condition|)
block|{
name|retransmitChain
operator|.
name|remove
argument_list|(
name|incept
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|incept
operator|instanceof
name|PhaseInterceptor
operator|&&
operator|(
operator|(
operator|(
name|PhaseInterceptor
argument_list|<
name|?
argument_list|>
operator|)
name|incept
operator|)
operator|.
name|getPhase
argument_list|()
operator|==
name|Phase
operator|.
name|MARSHAL
operator|)
condition|)
block|{
comment|// remove any interceptors from the marshal phase
name|retransmitChain
operator|.
name|remove
argument_list|(
name|incept
argument_list|)
expr_stmt|;
block|}
block|}
name|retransmitChain
operator|.
name|add
argument_list|(
operator|new
name|CopyOutInterceptor
argument_list|(
name|reader
argument_list|,
name|is
argument_list|)
argument_list|)
expr_stmt|;
comment|// restore callbacks on output stream
if|if
condition|(
name|callbacks
operator|!=
literal|null
condition|)
block|{
name|OutputStream
name|os
init|=
name|message
operator|.
name|getContent
argument_list|(
name|OutputStream
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|os
operator|!=
literal|null
condition|)
block|{
name|WriteOnCloseOutputStream
name|woc
decl_stmt|;
if|if
condition|(
name|os
operator|instanceof
name|WriteOnCloseOutputStream
condition|)
block|{
name|woc
operator|=
operator|(
name|WriteOnCloseOutputStream
operator|)
name|os
expr_stmt|;
block|}
else|else
block|{
name|woc
operator|=
operator|new
name|WriteOnCloseOutputStream
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|message
operator|.
name|setContent
argument_list|(
name|OutputStream
operator|.
name|class
argument_list|,
name|woc
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|CachedOutputStreamCallback
name|cb
range|:
name|callbacks
control|)
block|{
name|woc
operator|.
name|registerCallback
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// send the message
name|message
operator|.
name|put
argument_list|(
name|RMMessageConstants
operator|.
name|RM_RETRANSMISSION
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|after
condition|)
block|{
name|retransmitChain
operator|.
name|doInterceptStartingAfter
argument_list|(
name|message
argument_list|,
name|RMCaptureOutInterceptor
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retransmitChain
operator|.
name|doIntercept
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|INFO
argument_list|)
condition|)
block|{
name|RMProperties
name|rmps
init|=
name|RMContextUtils
operator|.
name|retrieveRMProperties
argument_list|(
name|message
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|SequenceType
name|seq
init|=
name|rmps
operator|.
name|getSequence
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|INFO
argument_list|,
literal|"Retransmitted message "
operator|+
name|seq
operator|.
name|getMessageNumber
argument_list|()
operator|+
literal|" in sequence "
operator|+
name|seq
operator|.
name|getIdentifier
argument_list|()
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|rmps
operator|=
operator|new
name|RMProperties
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|SEVERE
argument_list|,
literal|"RESEND_FAILED_MSG"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @param message      * @param endpoint      * @param to      * @return      */
specifier|protected
name|Conduit
name|buildConduit
parameter_list|(
name|SoapMessage
name|message
parameter_list|,
specifier|final
name|Endpoint
name|endpoint
parameter_list|,
name|AttributedURIType
name|to
parameter_list|)
block|{
name|Conduit
name|c
decl_stmt|;
specifier|final
name|String
name|address
init|=
name|to
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|DeferredConduitSelector
name|cs
init|=
operator|new
name|DeferredConduitSelector
argument_list|()
block|{
annotation|@
name|Override
specifier|public
specifier|synchronized
name|Conduit
name|selectConduit
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
name|Conduit
name|conduit
init|=
literal|null
decl_stmt|;
name|EndpointInfo
name|endpointInfo
init|=
name|endpoint
operator|.
name|getEndpointInfo
argument_list|()
decl_stmt|;
name|EndpointReferenceType
name|original
init|=
name|endpointInfo
operator|.
name|getTarget
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
literal|null
operator|!=
name|address
condition|)
block|{
name|endpointInfo
operator|.
name|setAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
block|}
name|conduit
operator|=
name|super
operator|.
name|selectConduit
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|endpointInfo
operator|.
name|setAddress
argument_list|(
name|original
argument_list|)
expr_stmt|;
block|}
name|conduits
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|conduit
return|;
block|}
block|}
decl_stmt|;
name|cs
operator|.
name|setEndpoint
argument_list|(
name|endpoint
argument_list|)
expr_stmt|;
name|c
operator|=
name|cs
operator|.
name|selectConduit
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|// REVISIT
comment|// use application endpoint message observer instead?
name|c
operator|.
name|setMessageObserver
argument_list|(
operator|new
name|MessageObserver
argument_list|()
block|{
specifier|public
name|void
name|onMessage
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
literal|"Ignoring response to resent message."
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|cs
operator|.
name|close
argument_list|()
expr_stmt|;
name|message
operator|.
name|getExchange
argument_list|()
operator|.
name|setConduit
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
comment|/**      * @param endpoint      * @param cache      * @return      */
specifier|protected
name|PhaseInterceptorChain
name|buildRetransmitChain
parameter_list|(
specifier|final
name|Endpoint
name|endpoint
parameter_list|,
name|PhaseChainCache
name|cache
parameter_list|)
block|{
name|PhaseInterceptorChain
name|retransmitChain
decl_stmt|;
name|Bus
name|bus
init|=
name|getManager
argument_list|()
operator|.
name|getBus
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Interceptor
argument_list|<
name|?
extends|extends
name|Message
argument_list|>
argument_list|>
name|i1
init|=
name|bus
operator|.
name|getOutInterceptors
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
literal|"Interceptors contributed by bus: "
operator|+
name|i1
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Interceptor
argument_list|<
name|?
extends|extends
name|Message
argument_list|>
argument_list|>
name|i2
init|=
name|endpoint
operator|.
name|getOutInterceptors
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
literal|"Interceptors contributed by endpoint: "
operator|+
name|i2
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Interceptor
argument_list|<
name|?
extends|extends
name|Message
argument_list|>
argument_list|>
name|i3
init|=
name|endpoint
operator|.
name|getBinding
argument_list|()
operator|.
name|getOutInterceptors
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
literal|"Interceptors contributed by binding: "
operator|+
name|i3
argument_list|)
expr_stmt|;
block|}
name|PhaseManager
name|pm
init|=
name|bus
operator|.
name|getExtension
argument_list|(
name|PhaseManager
operator|.
name|class
argument_list|)
decl_stmt|;
name|retransmitChain
operator|=
name|cache
operator|.
name|get
argument_list|(
name|pm
operator|.
name|getOutPhases
argument_list|()
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|,
name|i3
argument_list|)
expr_stmt|;
return|return
name|retransmitChain
return|;
block|}
specifier|public
specifier|static
class|class
name|CopyOutInterceptor
extends|extends
name|AbstractOutDatabindingInterceptor
block|{
specifier|private
specifier|final
name|XMLStreamReader
name|reader
decl_stmt|;
specifier|private
name|InputStream
name|is
decl_stmt|;
specifier|public
name|CopyOutInterceptor
parameter_list|(
name|XMLStreamReader
name|rdr
parameter_list|,
name|InputStream
name|is
parameter_list|)
block|{
name|super
argument_list|(
name|Phase
operator|.
name|MARSHAL
argument_list|)
expr_stmt|;
name|reader
operator|=
name|rdr
expr_stmt|;
name|this
operator|.
name|is
operator|=
name|is
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|handleMessage
parameter_list|(
name|Message
name|message
parameter_list|)
throws|throws
name|Fault
block|{
try|try
block|{
name|XMLStreamWriter
name|writer
init|=
name|message
operator|.
name|getContent
argument_list|(
name|XMLStreamWriter
operator|.
name|class
argument_list|)
decl_stmt|;
name|StaxUtils
operator|.
name|copy
argument_list|(
name|reader
argument_list|,
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
block|}
catch|catch
parameter_list|(
name|XMLStreamException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Fault
argument_list|(
literal|"COULD_NOT_READ_XML_STREAM"
argument_list|,
name|LOG
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

