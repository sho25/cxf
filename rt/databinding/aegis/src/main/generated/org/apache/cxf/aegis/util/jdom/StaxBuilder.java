begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*--   Copyright (C) 2000-2004 Jason Hunter& Brett McLaughlin.  All rights reserved.   Redistribution and use in source and binary forms, with or without  modification, are permitted provided that the following conditions  are met:   1. Redistributions of source code must retain the above copyright  notice, this list of conditions, and the following disclaimer.   2. Redistributions in binary form must reproduce the above copyright  notice, this list of conditions, and the disclaimer that follows  these conditions in the documentation and/or other materials  provided with the distribution.   3. The name "JDOM" must not be used to endorse or promote products  derived from this software without prior written permission.  For  written permission, please contact<request_AT_jdom_DOT_org>.   4. Products derived from this software may not be called "JDOM", nor  may "JDOM" appear in their name, without prior written permission  from the JDOM Project Management<request_AT_jdom_DOT_org>.   In addition, we request (but do not require) that you include in the  end-user documentation provided with the redistribution and/or in the  software itself an acknowledgement equivalent to the following:  "This product includes software developed by the  JDOM Project (http://www.jdom.org/)."  Alternatively, the acknowledgment may be graphical using the logos  available at http://www.jdom.org/images/logos.   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  DISCLAIMED.  IN NO EVENT SHALL THE JDOM AUTHORS OR THE PROJECT  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  SUCH DAMAGE.   This software consists of voluntary contributions made by many  individuals on behalf of the JDOM Project and was originally  created by Jason Hunter<jhunter_AT_jdom_DOT_org> and  Brett McLaughlin<brett_AT_jdom_DOT_org>.  For more information  on the JDOM Project, please see<http://www.jdom.org/>.   */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|aegis
operator|.
name|util
operator|.
name|jdom
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamConstants
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|staxutils
operator|.
name|StaxUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jdom
operator|.
name|Attribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jdom
operator|.
name|Content
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jdom
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jdom
operator|.
name|Element
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jdom
operator|.
name|JDOMFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jdom
operator|.
name|Namespace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jdom
operator|.
name|UncheckedJDOMFactory
import|;
end_import

begin_comment
comment|/**  * Builds a JDOM {@link org.jdom.Document org.jdom.Document} using a  * {@link javax.xml.stream.XMLStreamReader}.  *  * @author Tatu Saloranta  * @author Bradley S. Huffman  * @author Benson I. Margulies, mods for CXF to allow reading a portion of a stream.  */
end_comment

begin_class
specifier|public
class|class
name|StaxBuilder
block|{
comment|/**      * Map that contains conversion from textual attribute types StAX uses, to      * int values JDOM uses.      */
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|ATTR_TYPES
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
literal|32
argument_list|)
decl_stmt|;
static|static
block|{
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"CDATA"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|CDATA_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"cdata"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|CDATA_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"ID"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|ID_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"id"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|ID_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"IDREF"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|IDREF_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"idref"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|IDREF_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"IDREFS"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|IDREFS_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"idrefs"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|IDREFS_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"ENTITY"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|ENTITY_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"entity"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|ENTITY_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"ENTITIES"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|ENTITIES_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"entities"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|ENTITIES_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"NMTOKEN"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|NMTOKEN_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"nmtoken"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|NMTOKEN_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"NMTOKENS"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|NMTOKENS_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"nmtokens"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|NMTOKENS_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"NOTATION"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|NOTATION_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"notation"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|NOTATION_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"ENUMERATED"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|ENUMERATED_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|ATTR_TYPES
operator|.
name|put
argument_list|(
literal|"enumerated"
argument_list|,
operator|new
name|Integer
argument_list|(
name|Attribute
operator|.
name|ENUMERATED_TYPE
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Whether ignorable white space should be ignored, ie not added in the      * resulting JDOM tree. If true, it will be ignored; if false, it will be      * added in the tree. Default value if false.      */
specifier|protected
name|boolean
name|cfgIgnoreWS
decl_stmt|;
comment|/** The factory for creating new JDOM objects */
specifier|private
name|JDOMFactory
name|factory
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|additionalNamespaces
decl_stmt|;
comment|// This is set to 'true' when we are reading the middle of a stream,
comment|// and need to stop at the end of the element we start.
specifier|private
name|boolean
name|isReadingMidStream
decl_stmt|;
comment|/**      * Default constructor.      */
specifier|public
name|StaxBuilder
parameter_list|()
block|{     }
specifier|public
name|StaxBuilder
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|namespaces
parameter_list|)
block|{
name|this
operator|.
name|additionalNamespaces
operator|=
name|namespaces
expr_stmt|;
block|}
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getAdditionalNamespaces
parameter_list|()
block|{
return|return
name|additionalNamespaces
return|;
block|}
specifier|public
name|void
name|setAdditionalNamespaces
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|additionalNamespaces
parameter_list|)
block|{
name|this
operator|.
name|additionalNamespaces
operator|=
name|additionalNamespaces
expr_stmt|;
block|}
comment|/*      * This sets a custom JDOMFactory for the builder. Use this to build the      * tree with your own subclasses of the JDOM classes. @param factory<code>JDOMFactory</code>      * to use      */
specifier|public
name|void
name|setFactory
parameter_list|(
name|JDOMFactory
name|f
parameter_list|)
block|{
name|factory
operator|=
name|f
expr_stmt|;
block|}
specifier|public
name|void
name|setIgnoreWhitespace
parameter_list|(
name|boolean
name|state
parameter_list|)
block|{
name|cfgIgnoreWS
operator|=
name|state
expr_stmt|;
block|}
comment|/**      * Returns the current {@link org.jdom.JDOMFactory} in use, if one has been      * previously set with {@link #setFactory}, otherwise null.      *      * @return the factory builder will use      */
specifier|public
name|JDOMFactory
name|getFactory
parameter_list|()
block|{
return|return
name|factory
return|;
block|}
comment|/**      * This will build a JDOM tree given a StAX stream reader.      * This API explicitly supports building mid-stream.      *      * @param r Stream reader from which input is read.      * @return<code>Document</code> - JDOM document object.      * @throws XMLStreamException If the reader threw such exception (to      *             indicate a parsing or I/O problem)      */
specifier|public
name|Document
name|build
parameter_list|(
name|XMLStreamReader
name|r
parameter_list|)
throws|throws
name|XMLStreamException
block|{
name|isReadingMidStream
operator|=
literal|true
expr_stmt|;
return|return
name|buildInternal
argument_list|(
name|r
argument_list|)
return|;
block|}
specifier|public
name|Document
name|build
parameter_list|(
name|InputStream
name|is
parameter_list|)
throws|throws
name|XMLStreamException
block|{
name|isReadingMidStream
operator|=
literal|false
expr_stmt|;
name|XMLStreamReader
name|reader
init|=
literal|null
decl_stmt|;
try|try
block|{
name|reader
operator|=
name|StaxUtils
operator|.
name|createXMLStreamReader
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return
name|buildInternal
argument_list|(
name|reader
argument_list|)
return|;
block|}
finally|finally
block|{
name|StaxUtils
operator|.
name|close
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|Document
name|build
parameter_list|(
name|Reader
name|reader
parameter_list|)
throws|throws
name|XMLStreamException
block|{
name|isReadingMidStream
operator|=
literal|false
expr_stmt|;
name|XMLStreamReader
name|streamReader
init|=
literal|null
decl_stmt|;
try|try
block|{
name|streamReader
operator|=
name|StaxUtils
operator|.
name|createXMLStreamReader
argument_list|(
name|reader
argument_list|)
expr_stmt|;
return|return
name|buildInternal
argument_list|(
name|streamReader
argument_list|)
return|;
block|}
finally|finally
block|{
name|StaxUtils
operator|.
name|close
argument_list|(
name|streamReader
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Document
name|buildInternal
parameter_list|(
name|XMLStreamReader
name|r
parameter_list|)
throws|throws
name|XMLStreamException
block|{
comment|/*          * Should we do sanity checking to see that r is positioned at          * beginning in the non-mid-stream case?          */
name|JDOMFactory
name|f
init|=
name|factory
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
name|f
operator|=
operator|new
name|UncheckedJDOMFactory
argument_list|()
expr_stmt|;
block|}
name|Document
name|doc
init|=
name|f
operator|.
name|document
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|buildTree
argument_list|(
name|f
argument_list|,
name|r
argument_list|,
name|doc
argument_list|)
expr_stmt|;
return|return
name|doc
return|;
block|}
comment|/**      * This takes a<code>XMLStreamReader</code> and builds up a JDOM tree.      * Recursion has been eliminated by using local stack of open elements; this      * improves performance somewhat (classic      * recursion-by-iteration-and-explicit stack transformation)      *      * @param node<code>Code</node> to examine.      * @param doc JDOM<code>Document</code> being built.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"fallthrough"
argument_list|)
specifier|private
name|void
name|buildTree
parameter_list|(
name|JDOMFactory
name|f
parameter_list|,
name|XMLStreamReader
name|r
parameter_list|,
name|Document
name|doc
parameter_list|)
throws|throws
name|XMLStreamException
block|{
name|Element
name|current
init|=
literal|null
decl_stmt|;
comment|// At top level
name|int
name|event
init|=
name|r
operator|.
name|getEventType
argument_list|()
decl_stmt|;
comment|// if we're at the start then we need to do a next
if|if
condition|(
name|event
operator|==
operator|-
literal|1
condition|)
block|{
name|event
operator|=
name|r
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|boolean
name|noadd
init|=
literal|false
decl_stmt|;
name|Content
name|child
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|XMLStreamConstants
operator|.
name|CDATA
case|:
name|child
operator|=
name|f
operator|.
name|cdata
argument_list|(
name|r
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|XMLStreamConstants
operator|.
name|SPACE
case|:
if|if
condition|(
name|cfgIgnoreWS
condition|)
block|{
name|noadd
operator|=
literal|true
expr_stmt|;
break|break;
block|}
comment|// fall through
case|case
name|XMLStreamConstants
operator|.
name|CHARACTERS
case|:
comment|/*                  * Small complication: although (ignorable) white space is                  * allowed in prolog/epilog, and StAX may report such event,                  * JDOM barfs if trying to add it. Thus, let's just ignore all                  * textual stuff outside the tree:                  */
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|noadd
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|child
operator|=
name|f
operator|.
name|text
argument_list|(
name|r
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|XMLStreamConstants
operator|.
name|COMMENT
case|:
name|child
operator|=
name|f
operator|.
name|comment
argument_list|(
name|r
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|XMLStreamConstants
operator|.
name|END_DOCUMENT
case|:
return|return;
case|case
name|XMLStreamConstants
operator|.
name|END_ELEMENT
case|:
comment|/**                  * If current.getParentElement() previously returned null and we                  * get this event again we shouldn't bail out with a                  * NullPointerException                  */
if|if
condition|(
name|current
operator|!=
literal|null
condition|)
block|{
name|current
operator|=
name|current
operator|.
name|getParentElement
argument_list|()
expr_stmt|;
block|}
name|noadd
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|isReadingMidStream
operator|&&
name|current
operator|==
literal|null
condition|)
return|return;
break|break;
case|case
name|XMLStreamConstants
operator|.
name|ENTITY_DECLARATION
case|:
case|case
name|XMLStreamConstants
operator|.
name|NOTATION_DECLARATION
case|:
comment|/*                  * Shouldn't really get these, but maybe some stream readers do                  * provide the info. If so, better ignore it -- DTD event should                  * have most/all we need.                  */
name|noadd
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|XMLStreamConstants
operator|.
name|ENTITY_REFERENCE
case|:
name|child
operator|=
name|f
operator|.
name|entityRef
argument_list|(
name|r
operator|.
name|getLocalName
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|XMLStreamConstants
operator|.
name|PROCESSING_INSTRUCTION
case|:
name|child
operator|=
name|f
operator|.
name|processingInstruction
argument_list|(
name|r
operator|.
name|getPITarget
argument_list|()
argument_list|,
name|r
operator|.
name|getPIData
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|XMLStreamConstants
operator|.
name|START_ELEMENT
case|:
block|{
comment|// Ok, need to add a new element and simulate recursion
name|Element
name|newElem
init|=
literal|null
decl_stmt|;
name|String
name|nsURI
init|=
name|r
operator|.
name|getNamespaceURI
argument_list|()
decl_stmt|;
name|String
name|elemPrefix
init|=
name|r
operator|.
name|getPrefix
argument_list|()
decl_stmt|;
comment|// needed for special
comment|// handling of elem's
comment|// namespace
name|String
name|ln
init|=
name|r
operator|.
name|getLocalName
argument_list|()
decl_stmt|;
if|if
condition|(
name|nsURI
operator|==
literal|null
operator|||
name|nsURI
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|elemPrefix
operator|==
literal|null
operator|||
name|elemPrefix
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|newElem
operator|=
name|f
operator|.
name|element
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*                          * Happens when a prefix is bound to the default (empty)                          * namespace...                          */
name|newElem
operator|=
name|f
operator|.
name|element
argument_list|(
name|ln
argument_list|,
name|elemPrefix
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|newElem
operator|=
name|f
operator|.
name|element
argument_list|(
name|ln
argument_list|,
name|elemPrefix
argument_list|,
name|nsURI
argument_list|)
expr_stmt|;
block|}
comment|/*                  * Let's add element right away (probably have to do it to bind                  * attribute namespaces, too)                  */
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
comment|// at root
name|doc
operator|.
name|setRootElement
argument_list|(
name|newElem
argument_list|)
expr_stmt|;
if|if
condition|(
name|additionalNamespaces
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|iter
init|=
name|additionalNamespaces
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|prefix
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|uri
init|=
name|additionalNamespaces
operator|.
name|get
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
name|newElem
operator|.
name|addNamespaceDeclaration
argument_list|(
name|Namespace
operator|.
name|getNamespace
argument_list|(
name|prefix
argument_list|,
name|uri
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|f
operator|.
name|addContent
argument_list|(
name|current
argument_list|,
name|newElem
argument_list|)
expr_stmt|;
block|}
comment|// Any declared namespaces?
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|len
operator|=
name|r
operator|.
name|getNamespaceCount
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|String
name|prefix
init|=
name|r
operator|.
name|getNamespacePrefix
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Namespace
name|ns
init|=
name|Namespace
operator|.
name|getNamespace
argument_list|(
name|prefix
argument_list|,
name|r
operator|.
name|getNamespaceURI
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
comment|// JDOM has special handling for element's "own" ns:
if|if
condition|(
name|prefix
operator|!=
literal|null
operator|&&
name|prefix
operator|.
name|equals
argument_list|(
name|elemPrefix
argument_list|)
condition|)
block|{
comment|// already set by when it was constructed...
block|}
else|else
block|{
name|f
operator|.
name|addNamespaceDeclaration
argument_list|(
name|newElem
argument_list|,
name|ns
argument_list|)
expr_stmt|;
block|}
block|}
comment|// And then the attributes:
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|len
operator|=
name|r
operator|.
name|getAttributeCount
argument_list|()
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|String
name|prefix
init|=
name|r
operator|.
name|getAttributePrefix
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Namespace
name|ns
decl_stmt|;
if|if
condition|(
name|prefix
operator|==
literal|null
operator|||
name|prefix
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Attribute not in any namespace
name|ns
operator|=
name|Namespace
operator|.
name|NO_NAMESPACE
expr_stmt|;
block|}
else|else
block|{
name|ns
operator|=
name|newElem
operator|.
name|getNamespace
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
name|Attribute
name|attr
init|=
name|f
operator|.
name|attribute
argument_list|(
name|r
operator|.
name|getAttributeLocalName
argument_list|(
name|i
argument_list|)
argument_list|,
name|r
operator|.
name|getAttributeValue
argument_list|(
name|i
argument_list|)
argument_list|,
name|resolveAttrType
argument_list|(
name|r
operator|.
name|getAttributeType
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|ns
argument_list|)
decl_stmt|;
name|f
operator|.
name|setAttribute
argument_list|(
name|newElem
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
comment|// And then 'push' new element...
name|current
operator|=
name|newElem
expr_stmt|;
comment|// Already added the element, can continue
name|noadd
operator|=
literal|true
expr_stmt|;
break|break;
block|}
case|case
name|XMLStreamConstants
operator|.
name|START_DOCUMENT
case|:
comment|/*                  * This should only be received at the beginning of document...                  * so, should we indicate the problem or not?                  */
comment|/*                  * For now, let it pass: maybe some (broken) readers pass that                  * info as first event in beginning of doc?                  */
case|case
name|XMLStreamConstants
operator|.
name|DTD
case|:
comment|/*                  * !!! Note: StAX does not expose enough information about                  * doctype declaration (specifically, public and system id!);                  * should (re-)parse information... not yet implemented                  */
comment|// TBI
comment|// continue main_loop;
comment|// Should never get these, from a stream reader:
comment|/*                  * (commented out entries are just FYI; default catches them                  * all)                  */
comment|// case XMLStreamConstants.ATTRIBUTE:
comment|// case XMLStreamConstants.NAMESPACE:
default|default:
comment|/*                  * throw new XMLStreamException("Unrecognized iterator event                  * type: " + r.getEventType() + "; should not receive such types                  * (broken stream reader?)");                  */
break|break;
block|}
if|if
condition|(
operator|!
name|noadd
operator|&&
name|child
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|f
operator|.
name|addContent
argument_list|(
name|doc
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f
operator|.
name|addContent
argument_list|(
name|current
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|event
operator|=
name|r
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
specifier|private
specifier|static
name|int
name|resolveAttrType
parameter_list|(
name|String
name|typeStr
parameter_list|)
block|{
if|if
condition|(
name|typeStr
operator|!=
literal|null
operator|&&
name|typeStr
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Integer
name|i
init|=
name|ATTR_TYPES
operator|.
name|get
argument_list|(
name|typeStr
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|null
condition|)
block|{
return|return
name|i
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
return|return
name|Attribute
operator|.
name|UNDECLARED_TYPE
return|;
block|}
block|}
end_class

end_unit

