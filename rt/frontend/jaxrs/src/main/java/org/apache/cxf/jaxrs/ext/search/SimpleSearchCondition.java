begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements. See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|jaxrs
operator|.
name|ext
operator|.
name|search
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Simple search condition comparing primitive objects or complex object by its getters. For details see  * {@link #isMet(Object)} description.  *   * @param<T> type of search condition.  */
end_comment

begin_class
specifier|public
class|class
name|SimpleSearchCondition
parameter_list|<
name|T
parameter_list|>
implements|implements
name|SearchCondition
argument_list|<
name|T
argument_list|>
block|{
specifier|private
specifier|static
name|Set
argument_list|<
name|ConditionType
argument_list|>
name|supportedTypes
init|=
operator|new
name|HashSet
argument_list|<
name|ConditionType
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|supportedTypes
operator|.
name|add
argument_list|(
name|ConditionType
operator|.
name|EQUALS
argument_list|)
expr_stmt|;
name|supportedTypes
operator|.
name|add
argument_list|(
name|ConditionType
operator|.
name|NOT_EQUALS
argument_list|)
expr_stmt|;
name|supportedTypes
operator|.
name|add
argument_list|(
name|ConditionType
operator|.
name|GREATER_THAN
argument_list|)
expr_stmt|;
name|supportedTypes
operator|.
name|add
argument_list|(
name|ConditionType
operator|.
name|GREATER_OR_EQUALS
argument_list|)
expr_stmt|;
name|supportedTypes
operator|.
name|add
argument_list|(
name|ConditionType
operator|.
name|LESS_THAN
argument_list|)
expr_stmt|;
name|supportedTypes
operator|.
name|add
argument_list|(
name|ConditionType
operator|.
name|LESS_OR_EQUALS
argument_list|)
expr_stmt|;
block|}
specifier|private
name|ConditionType
name|cType
decl_stmt|;
specifier|private
name|T
name|condition
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|ConditionType
argument_list|>
name|getters2operators
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getters2values
decl_stmt|;
specifier|private
name|Beanspector
argument_list|<
name|T
argument_list|>
name|beanspector
decl_stmt|;
comment|/**      * Creates search condition with same operator (equality, inequality) applied in all comparison; see      * {@link #isMet(Object)} for details of comparison.      *       * @param cType shared condition type      * @param condition template object      */
specifier|public
name|SimpleSearchCondition
parameter_list|(
name|ConditionType
name|cType
parameter_list|,
name|T
name|condition
parameter_list|)
block|{
if|if
condition|(
name|cType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cType is null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|condition
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"condition is null"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|supportedTypes
operator|.
name|contains
argument_list|(
name|cType
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"unsupported condition type: "
operator|+
name|cType
operator|.
name|name
argument_list|()
argument_list|)
throw|;
block|}
name|this
operator|.
name|cType
operator|=
name|cType
expr_stmt|;
name|this
operator|.
name|getters2operators
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|condition
operator|=
name|condition
expr_stmt|;
block|}
comment|/**      * Creates search condition with different operators (equality, inequality etc) specified for each getter;      * see {@link #isMet(Object)} for details of comparison. Cannot be used for primitive T type due to      * per-getter comparison strategy.      *       * @param getters2operators getters names and operators to be used with them during comparison      * @param condition template object      */
specifier|public
name|SimpleSearchCondition
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|ConditionType
argument_list|>
name|getters2operators
parameter_list|,
name|T
name|condition
parameter_list|)
block|{
if|if
condition|(
name|getters2operators
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"getters2operators is null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|condition
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"condition is null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|isPrimitive
argument_list|(
name|condition
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"mapped operators strategy is "
operator|+
literal|"not supported for primitive type "
operator|+
name|condition
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
for|for
control|(
name|ConditionType
name|ct
range|:
name|getters2operators
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|supportedTypes
operator|.
name|contains
argument_list|(
name|ct
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"unsupported condition type: "
operator|+
name|ct
operator|.
name|name
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|this
operator|.
name|cType
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|getters2operators
operator|=
name|getters2operators
expr_stmt|;
name|this
operator|.
name|condition
operator|=
name|condition
expr_stmt|;
block|}
specifier|public
name|T
name|getCondition
parameter_list|()
block|{
return|return
name|condition
return|;
block|}
comment|/**      * {@inheritDoc}      *<p>      * When constructor with map is used it returns null.      */
specifier|public
name|ConditionType
name|getConditionType
parameter_list|()
block|{
return|return
name|cType
return|;
block|}
specifier|public
name|List
argument_list|<
name|SearchCondition
argument_list|<
name|T
argument_list|>
argument_list|>
name|getConditions
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**      * Compares given object against template condition object.      *<p>      * For primitive type T like String, Number (precisely, from type T located in subpackage of      * "java.lang.*") given object is directly compared with template object. Comparison for      * {@link ConditionType#EQUALS} requires correct implementation of {@link Object#equals(Object)}, using      * inequalities requires type T implementing {@link Comparable}.      *<p>      * For other types comparison of given object against template object is done using these<b>getters</b>;      * returned "is met" value is<b>conjunction ('and' operator)</b> of comparisons per each getter. Getters      * of template object that return null or throw exception are not used in comparison, in extreme if all      * getters are excluded it means every given pojo object matches. If      * {@link #SimpleSearchCondition(ConditionType, Object) constructor with shared operator} was used, then      * getters are compared using the same operator. If {@link #SimpleSearchCondition(Map, Object) constructor      * with map of operators} was used then for every getter specified operator is used (getters for missing      * mapping are ignored). The way that comparison per getter is done depends on operator type per getter -      * comparison for {@link ConditionType#EQUALS} requires correct implementation of      * {@link Object#equals(Object)}, using inequalities requires that getter type implements      * {@link Comparable}.      *<p>      * For equality comparison and String type in template object (either being primitive or getter from      * complex type) it is allowed to used asterisk at the beginning or at the end of text as wild card (zero      * or more of any characters) e.g. "foo*", "*foo" or "*foo*". Inner asterisks are not interpreted as wild      * cards.      *<p>      *<b>Example:</b>      *       *<pre>      * SimpleSearchCondition&lt;Integer&gt; ssc = new SimpleSearchCondition&lt;Integer&gt;(      *   ConditionType.GREATER_THAN, 10);          * ssc.isMet(20);      * // true since 20&gt;10       *       * class Entity {      *   public String getName() {...      *   public int getLevel() {...      *   public String getMessage() {...      * }      *       * Entity template = new Entity("bbb", 10, null);      * ssc = new SimpleSearchCondition&lt;Entity&gt;(      *   ConditionType.GREATER_THAN, template);          *       * ssc.isMet(new Entity("aaa", 20, "some mesage"));       * // false: is not met, expression '"aaa"&gt;"bbb" and 20&gt;10' is not true        * // since "aaa" is not greater than "bbb"; not that message is null in template hence ingored      *       * ssc.isMet(new Entity("ccc", 30, "other message"));      * // true: is met, expression '"ccc"&gt;"bbb" and 30&gt;10' is true      *       * Map&lt;String,ConditionType&gt; map;      * map.put("name", ConditionType.EQUALS);      * map.put("level", ConditionType.GREATER_THAN);      * ssc = new SimpleSearchCondition&lt;Entity&gt;(      *   ConditionType.GREATER_THAN, template);      *         * ssc.isMet(new Entity("ccc", 30, "other message"));      * // false due to expression '"aaa"=="ccc" and 30&gt;10"' (note different operators)      *       *</pre>      *       * @throws IllegalAccessException when security manager disallows reflective call of getters.      */
specifier|public
name|boolean
name|isMet
parameter_list|(
name|T
name|pojo
parameter_list|)
block|{
if|if
condition|(
name|isPrimitive
argument_list|(
name|pojo
argument_list|)
condition|)
block|{
return|return
name|compare
argument_list|(
name|pojo
argument_list|,
name|cType
argument_list|,
name|condition
argument_list|)
return|;
block|}
else|else
block|{
name|boolean
name|matches
init|=
literal|false
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|get2val
init|=
name|getGettersAndValues
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|getter
range|:
name|get2val
operator|.
name|keySet
argument_list|()
control|)
block|{
name|ConditionType
name|ct
init|=
name|cType
decl_stmt|;
if|if
condition|(
name|ct
operator|==
literal|null
condition|)
block|{
name|ct
operator|=
name|getters2operators
operator|.
name|get
argument_list|(
name|getter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
block|}
name|Object
name|lval
init|=
name|getValue
argument_list|(
name|getter
argument_list|,
name|pojo
argument_list|)
decl_stmt|;
name|Object
name|rval
init|=
name|get2val
operator|.
name|get
argument_list|(
name|getter
argument_list|)
decl_stmt|;
name|matches
operator|=
name|compare
argument_list|(
name|lval
argument_list|,
name|ct
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matches
condition|)
block|{
break|break;
block|}
block|}
return|return
name|matches
return|;
block|}
block|}
comment|/**      * Creates cache of getters from template (condition) object and its values returned during one-pass      * invocation. Method isMet() will use its keys to introspect getters of passed pojo object, and values      * from map in comparison.      *       * @return template (condition) object getters mapped to their non-null values      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getGettersAndValues
parameter_list|()
block|{
if|if
condition|(
name|getters2values
operator|==
literal|null
condition|)
block|{
name|getters2values
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
expr_stmt|;
name|beanspector
operator|=
operator|new
name|Beanspector
argument_list|<
name|T
argument_list|>
argument_list|(
name|condition
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|getter
range|:
name|beanspector
operator|.
name|getGettersNames
argument_list|()
control|)
block|{
name|Object
name|value
init|=
name|getValue
argument_list|(
name|getter
argument_list|,
name|condition
argument_list|)
decl_stmt|;
name|getters2values
operator|.
name|put
argument_list|(
name|getter
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|//we do not need compare class objects
name|getters2values
operator|.
name|keySet
argument_list|()
operator|.
name|remove
argument_list|(
literal|"class"
argument_list|)
expr_stmt|;
block|}
return|return
name|getters2values
return|;
block|}
specifier|private
name|Object
name|getValue
parameter_list|(
name|String
name|getter
parameter_list|,
name|T
name|pojo
parameter_list|)
block|{
try|try
block|{
return|return
name|beanspector
operator|.
name|swap
argument_list|(
name|pojo
argument_list|)
operator|.
name|getValue
argument_list|(
name|getter
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|private
name|boolean
name|isPrimitive
parameter_list|(
name|T
name|pojo
parameter_list|)
block|{
return|return
name|pojo
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"java.lang"
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|boolean
name|compare
parameter_list|(
name|Object
name|lval
parameter_list|,
name|ConditionType
name|cond
parameter_list|,
name|Object
name|rval
parameter_list|)
block|{
name|boolean
name|compares
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|cond
operator|==
name|ConditionType
operator|.
name|EQUALS
operator|||
name|cond
operator|==
name|ConditionType
operator|.
name|NOT_EQUALS
condition|)
block|{
if|if
condition|(
name|rval
operator|==
literal|null
condition|)
block|{
name|compares
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lval
operator|==
literal|null
condition|)
block|{
name|compares
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lval
operator|instanceof
name|String
condition|)
block|{
name|compares
operator|=
name|textCompare
argument_list|(
operator|(
name|String
operator|)
name|lval
argument_list|,
operator|(
name|String
operator|)
name|rval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|compares
operator|=
name|lval
operator|.
name|equals
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cond
operator|==
name|ConditionType
operator|.
name|NOT_EQUALS
condition|)
block|{
name|compares
operator|=
operator|!
name|compares
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|lval
operator|instanceof
name|Comparable
operator|&&
name|rval
operator|instanceof
name|Comparable
condition|)
block|{
name|Comparable
name|lcomp
init|=
operator|(
name|Comparable
operator|)
name|lval
decl_stmt|;
name|Comparable
name|rcomp
init|=
operator|(
name|Comparable
operator|)
name|rval
decl_stmt|;
name|int
name|comp
init|=
name|lcomp
operator|.
name|compareTo
argument_list|(
name|rcomp
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|cond
condition|)
block|{
case|case
name|GREATER_THAN
case|:
name|compares
operator|=
name|comp
operator|>
literal|0
expr_stmt|;
break|break;
case|case
name|GREATER_OR_EQUALS
case|:
name|compares
operator|=
name|comp
operator|>=
literal|0
expr_stmt|;
break|break;
case|case
name|LESS_THAN
case|:
name|compares
operator|=
name|comp
operator|<
literal|0
expr_stmt|;
break|break;
case|case
name|LESS_OR_EQUALS
case|:
name|compares
operator|=
name|comp
operator|<=
literal|0
expr_stmt|;
break|break;
default|default:
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Condition type %s is not supported"
argument_list|,
name|cond
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|compares
return|;
block|}
specifier|private
name|boolean
name|textCompare
parameter_list|(
name|String
name|lval
parameter_list|,
name|String
name|rval
parameter_list|)
block|{
comment|// check wild cards
name|boolean
name|starts
init|=
literal|false
decl_stmt|;
name|boolean
name|ends
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|rval
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'*'
condition|)
block|{
name|starts
operator|=
literal|true
expr_stmt|;
name|rval
operator|=
name|rval
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rval
operator|.
name|charAt
argument_list|(
name|rval
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'*'
condition|)
block|{
name|ends
operator|=
literal|true
expr_stmt|;
name|rval
operator|=
name|rval
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|rval
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|starts
operator|||
name|ends
condition|)
block|{
comment|// wild card tests
if|if
condition|(
name|starts
operator|&&
operator|!
name|ends
condition|)
block|{
return|return
name|lval
operator|.
name|endsWith
argument_list|(
name|rval
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ends
operator|&&
operator|!
name|starts
condition|)
block|{
return|return
name|lval
operator|.
name|startsWith
argument_list|(
name|rval
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|lval
operator|.
name|contains
argument_list|(
name|rval
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
name|lval
operator|.
name|equals
argument_list|(
name|rval
argument_list|)
return|;
block|}
block|}
specifier|public
name|List
argument_list|<
name|T
argument_list|>
name|findAll
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|pojos
parameter_list|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|pojo
range|:
name|pojos
control|)
block|{
if|if
condition|(
name|isMet
argument_list|(
name|pojo
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|pojo
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
block|}
end_class

end_unit

