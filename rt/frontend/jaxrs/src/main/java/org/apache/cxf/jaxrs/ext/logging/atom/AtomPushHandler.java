begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements. See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|jaxrs
operator|.
name|ext
operator|.
name|logging
operator|.
name|atom
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Handler
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|LogManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|jaxrs
operator|.
name|ext
operator|.
name|logging
operator|.
name|LogRecord
import|;
end_import

begin_comment
comment|/**  * Handler pushing log records in batches as Atom Feeds to registered client. Handler responsibility is to  * adapt to JUL framework while most of job is delegated to {@link AtomPushEngine}.  *<p>  * For simple configuration using properties file (one global root-level handler of this class) following  * properties prefixed with full class name can be used:  *<ul>  *<li><b>url</b> - URL where feeds will be pushed (mandatory parameter)</li>  *<li><b>converter</b> - name of class implementing {@link Converter} class. For classes from this package  * only class name can be given e.g. instead of  * "org.apache.cxf.jaxrs.ext.logging.atom.ContentSingleEntryConverter" one can specify  * "ContentSingleEntryConverter". If parameter is not set {@link ContentSingleEntryConverter} is used.</li>  *<li><b>deliverer</b> - name of class implementing {@link Deliverer} class. For classes from this package  * only class name can be given e.g. instead of "org.apache.cxf.jaxrs.ext.logging.atom.WebClientDeliverer" one  * can specify "WebClientDeliverer". If parameter is not set {@link WebClientDeliverer} is used.</li>  *<li><b>batchSize</b> - integer number specifying minimal number of published log records that trigger  * processing and pushing ATOM document. If parameter is not set, is not greater than zero or is not a number,  * batch size is set to 1.</li>  *</ul>  * Family of<tt>retry</tt> parameters below; availability of any of this parameters enables delivery retrying  * (e.g. for default non-reliable deliverers) with {@link RetryingDeliverer} that can be combined with  * provided non-reliable deliverers. Detailed explanation of these parameter, see {@link RetryingDeliverer}  * class description.  *<ul>  *<li><b>retry.pause</b> - pausing strategy of delivery retries, either<b>linear</b> or<b>exponential</b>  * value (mandatory parameter). If mispelled linear is used.</li>  *<li><b>retry.pause.time</b> - pause time (in seconds) between retries. If parameter is not set, pause is  * set to 30 seconds.</li>  *<li><b>retry.timeout</b> - maximum time (in seconds) retrying will be continued. If not set timeout is not  * set (infinite loop of retries).</li>  *</ul>  * Example:  *   *<pre>  * handlers = org.apache.cxf.jaxrs.ext.logging.atom.AtomPushHandler, java.util.logging.ConsoleHandler  * .level = INFO  * ...  * org.apache.cxf.jaxrs.ext.logging.atom.AtomPushHandler.url = http://localhost:9080  * org.apache.cxf.jaxrs.ext.logging.atom.AtomPushHandler.batchSize = 10  * org.apache.cxf.jaxrs.ext.logging.atom.AtomPushHandler.deliverer = WebClientDeliverer   * org.apache.cxf.jaxrs.ext.logging.atom.AtomPushHandler.converter = foo.bar.MyConverter  * org.apache.cxf.jaxrs.ext.logging.atom.AtomPushHandler.retry.pause = linear  * org.apache.cxf.jaxrs.ext.logging.atom.AtomPushHandler.retry.pause.time = 10  * org.apache.cxf.jaxrs.ext.logging.atom.AtomPushHandler.retry.timeout = 360  * ...  *</pre>  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|AtomPushHandler
extends|extends
name|Handler
block|{
specifier|private
name|AtomPushEngine
name|engine
init|=
operator|new
name|AtomPushEngine
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|lazyConfig
decl_stmt|;
comment|/**      * Creates handler with configuration taken from properties file.      */
specifier|public
name|AtomPushHandler
parameter_list|()
block|{
comment|// deferred configuration: configure() called from here would use utilities that attempt to log
comment|// and create this handler instance in recursion; configure() will be called on first publish()
name|lazyConfig
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * Creates handler with custom parameters.      *       * @param batchSize batch size, see {@link AtomPushEngine#getBatchSize()}      * @param converter converter transforming logs into ATOM elements      * @param deliverer deliverer pushing ATOM elements to client      */
specifier|public
name|AtomPushHandler
parameter_list|(
name|int
name|batchSize
parameter_list|,
name|Converter
name|converter
parameter_list|,
name|Deliverer
name|deliverer
parameter_list|)
block|{
name|engine
operator|.
name|setBatchSize
argument_list|(
name|batchSize
argument_list|)
expr_stmt|;
name|engine
operator|.
name|setConverter
argument_list|(
name|converter
argument_list|)
expr_stmt|;
name|engine
operator|.
name|setDeliverer
argument_list|(
name|deliverer
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|publish
parameter_list|(
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|LogRecord
name|record
parameter_list|)
block|{
if|if
condition|(
name|LoggingThread
operator|.
name|isSilent
argument_list|()
condition|)
block|{
return|return;
block|}
name|LoggingThread
operator|.
name|markSilent
argument_list|(
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|lazyConfig
condition|)
block|{
name|lazyConfig
operator|=
literal|false
expr_stmt|;
name|configure
argument_list|()
expr_stmt|;
block|}
name|LogRecord
name|rec
init|=
name|LogRecord
operator|.
name|fromJUL
argument_list|(
name|record
argument_list|)
decl_stmt|;
name|engine
operator|.
name|publish
argument_list|(
name|rec
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|LoggingThread
operator|.
name|markSilent
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|SecurityException
block|{
name|engine
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|flush
parameter_list|()
block|{
comment|// no-op
block|}
comment|/**      * Configuration from properties. Aligned to JUL strategy - properties file is only for simple      * configuration: it allows configure one root handler with its parameters. What is even more dummy, JUL      * does not allow to iterate over configuration properties to make interpretation automated (e.g. using      * commons-beanutils)      */
specifier|private
name|void
name|configure
parameter_list|()
block|{
name|LogManager
name|manager
init|=
name|LogManager
operator|.
name|getLogManager
argument_list|()
decl_stmt|;
name|String
name|cname
init|=
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|url
init|=
name|manager
operator|.
name|getProperty
argument_list|(
name|cname
operator|+
literal|".url"
argument_list|)
decl_stmt|;
if|if
condition|(
name|url
operator|==
literal|null
condition|)
block|{
comment|// cannot proceed
return|return;
block|}
name|String
name|deliverer
init|=
name|manager
operator|.
name|getProperty
argument_list|(
name|cname
operator|+
literal|".deliverer"
argument_list|)
decl_stmt|;
if|if
condition|(
name|deliverer
operator|!=
literal|null
condition|)
block|{
name|engine
operator|.
name|setDeliverer
argument_list|(
name|createDeliverer
argument_list|(
name|deliverer
argument_list|,
name|url
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// default
name|engine
operator|.
name|setDeliverer
argument_list|(
operator|new
name|WebClientDeliverer
argument_list|(
name|url
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|converter
init|=
name|manager
operator|.
name|getProperty
argument_list|(
name|cname
operator|+
literal|".converter"
argument_list|)
decl_stmt|;
if|if
condition|(
name|converter
operator|!=
literal|null
condition|)
block|{
name|engine
operator|.
name|setConverter
argument_list|(
name|createConverter
argument_list|(
name|converter
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// default
name|engine
operator|.
name|setConverter
argument_list|(
operator|new
name|ContentSingleEntryConverter
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|engine
operator|.
name|setBatchSize
argument_list|(
name|toInt
argument_list|(
name|manager
operator|.
name|getProperty
argument_list|(
name|cname
operator|+
literal|".batchSize"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|retryType
init|=
name|manager
operator|.
name|getProperty
argument_list|(
name|cname
operator|+
literal|".retry.pause"
argument_list|)
decl_stmt|;
if|if
condition|(
name|retryType
operator|!=
literal|null
condition|)
block|{
name|int
name|timeout
init|=
name|toInt
argument_list|(
name|manager
operator|.
name|getProperty
argument_list|(
name|cname
operator|+
literal|".retry.timeout"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|pause
init|=
name|toInt
argument_list|(
name|manager
operator|.
name|getProperty
argument_list|(
name|cname
operator|+
literal|".retry.pause.time"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|30
argument_list|)
decl_stmt|;
name|boolean
name|linear
init|=
operator|!
name|retryType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"exponential"
argument_list|)
decl_stmt|;
name|Deliverer
name|wrapped
init|=
operator|new
name|RetryingDeliverer
argument_list|(
name|engine
operator|.
name|getDeliverer
argument_list|()
argument_list|,
name|timeout
argument_list|,
name|pause
argument_list|,
name|linear
argument_list|)
decl_stmt|;
name|engine
operator|.
name|setDeliverer
argument_list|(
name|wrapped
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|toInt
parameter_list|(
name|String
name|property
parameter_list|,
name|int
name|defaultValue
parameter_list|)
block|{
try|try
block|{
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|property
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
return|return
name|defaultValue
return|;
block|}
block|}
specifier|private
name|int
name|toInt
parameter_list|(
name|String
name|property
parameter_list|,
name|int
name|lessThan
parameter_list|,
name|int
name|defaultValue
parameter_list|)
block|{
name|int
name|ret
init|=
name|toInt
argument_list|(
name|property
argument_list|,
name|defaultValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
name|lessThan
condition|)
block|{
name|ret
operator|=
name|defaultValue
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
specifier|private
name|Deliverer
name|createDeliverer
parameter_list|(
name|String
name|clazz
parameter_list|,
name|String
name|url
parameter_list|)
block|{
try|try
block|{
name|Constructor
argument_list|<
name|?
argument_list|>
name|ctor
init|=
name|loadClass
argument_list|(
name|clazz
argument_list|)
operator|.
name|getConstructor
argument_list|(
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
operator|(
name|Deliverer
operator|)
name|ctor
operator|.
name|newInstance
argument_list|(
name|url
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|Converter
name|createConverter
parameter_list|(
name|String
name|clazz
parameter_list|)
block|{
try|try
block|{
name|Constructor
argument_list|<
name|?
argument_list|>
name|ctor
init|=
name|loadClass
argument_list|(
name|clazz
argument_list|)
operator|.
name|getConstructor
argument_list|()
decl_stmt|;
return|return
operator|(
name|Converter
operator|)
name|ctor
operator|.
name|newInstance
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|Class
argument_list|<
name|?
argument_list|>
name|loadClass
parameter_list|(
name|String
name|clazz
parameter_list|)
throws|throws
name|ClassNotFoundException
block|{
try|try
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getClassLoader
argument_list|()
operator|.
name|loadClass
argument_list|(
name|clazz
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
try|try
block|{
comment|// clazz could be shorted (stripped package name) retry
name|String
name|clazz2
init|=
name|getClass
argument_list|()
operator|.
name|getPackage
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"."
operator|+
name|clazz
decl_stmt|;
return|return
name|getClass
argument_list|()
operator|.
name|getClassLoader
argument_list|()
operator|.
name|loadClass
argument_list|(
name|clazz2
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e1
parameter_list|)
block|{
throw|throw
operator|new
name|ClassNotFoundException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|" or "
operator|+
name|e1
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

