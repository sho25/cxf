begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements. See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|http
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PushbackInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|HttpURLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Proxy
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|namespace
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|Bus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|common
operator|.
name|logging
operator|.
name|LogUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|common
operator|.
name|util
operator|.
name|Base64Utility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|common
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|configuration
operator|.
name|Configurable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|configuration
operator|.
name|jsse
operator|.
name|TLSClientParameters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|configuration
operator|.
name|security
operator|.
name|AuthorizationPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|configuration
operator|.
name|security
operator|.
name|CertificateConstraintsType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|configuration
operator|.
name|security
operator|.
name|ProxyAuthorizationPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|helpers
operator|.
name|CastUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|helpers
operator|.
name|HttpHeaderHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|helpers
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|helpers
operator|.
name|LoadingByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|io
operator|.
name|AbstractThresholdOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|io
operator|.
name|CacheAndWriteOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|io
operator|.
name|CachedOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|ExchangeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|MessageImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|MessageUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|service
operator|.
name|model
operator|.
name|EndpointInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|AbstractConduit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|Destination
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|DestinationFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|DestinationFactoryManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|MessageObserver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|http
operator|.
name|policy
operator|.
name|PolicyUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|https
operator|.
name|CertConstraints
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|https
operator|.
name|CertConstraintsInterceptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|https
operator|.
name|CertConstraintsJaxBUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transports
operator|.
name|http
operator|.
name|configuration
operator|.
name|HTTPClientPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|version
operator|.
name|Version
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|workqueue
operator|.
name|AutomaticWorkQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|workqueue
operator|.
name|WorkQueueManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|addressing
operator|.
name|EndpointReferenceType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|policy
operator|.
name|Assertor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|policy
operator|.
name|PolicyEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|wsdl
operator|.
name|EndpointReferenceUtils
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|Message
operator|.
name|DECOUPLED_CHANNEL_MESSAGE
import|;
end_import

begin_comment
comment|/*  * HTTP Conduit implementation.  *<p>  * This implementation is a based on the java.net.URLConnection interface and  * dependent upon installed implementations of that URLConnection,   * HttpURLConnection, and HttpsURLConnection. Currently, this implementation  * has been known to work with the Sun JDK 1.5 default implementations. The  * HttpsURLConnection is part of Sun's implementation of the JSSE.   * Presently, the source code for the Sun JSSE implementation is unavailable  * and therefore we may only lay a guess of whether its HttpsURLConnection  * implementation correctly works as far as security is concerned.  *<p>  * The Trust Decision. If a MessageTrustDecider is configured/set for the   * Conduit, it is called upon the first flush of the headers in the   * WrappedOutputStream. This reason for this approach is two-fold.   * Theoretically, in order to get connection information out of the   * URLConnection, it must be "connected". We assume that its implementation will  * only follow through up to the point at which it will be ready to send  * one byte of data down to the endpoint, but through proxies, and the   * commpletion of a TLS handshake in the case of HttpsURLConnection.   * However, if we force the connect() call right away, the default  * implementations will not allow any calls to add/setRequestProperty,  * throwing an exception that the URLConnection is already connected.   *<p>  * We need to keep the semantic that later CXF interceptors may add to the   * PROTOCOL_HEADERS in the Message. This architectual decision forces us to   * delay the connection until after that point, then pulling the trust decision.  *<p>  * The security caveat is that we don't really know when the connection is   * really established. The call to "connect" is stated to force the   * "connection," but it is a no-op if the connection was already established.   * It is entirely possible that an implementation of an URLConnection may   * indeed connect at will and start sending the headers down the connection   * during calls to add/setRequestProperty!  *<p>  * We know that the JDK 1.5 sun.com.net.www.HttpURLConnection does not send  * this information before the "connect" call, because we can look at the  * source code. However, we can only assume, not verify, that the JSSE 1.5   * HttpsURLConnection does the same, in that it is probable that the   * HttpsURLConnection shares the HttpURLConnection implementation.  *<p>  * Due to these implementations following redirects without trust checks, we  * force the URLConnection implementations not to follow redirects. If   * client side policy dictates that we follow redirects, trust decisions are  * placed before each retransmit. On a redirect, any authorization information  * dynamically acquired by a BasicAuth UserPass supplier is removed before  * being retransmitted, as it may no longer be applicable to the new url to  * which the connection is redirected.  */
end_comment

begin_comment
comment|/**  * This Conduit handles the "http" and "https" transport protocols. An  * instance is governed by policies either explicitly set or by   * configuration.  */
end_comment

begin_class
specifier|public
class|class
name|HTTPConduit
extends|extends
name|AbstractConduit
implements|implements
name|Configurable
implements|,
name|Assertor
block|{
comment|/**      *  This constant is the Message(Map) key for the HttpURLConnection that      *  is used to get the response.      */
specifier|public
specifier|static
specifier|final
name|String
name|KEY_HTTP_CONNECTION
init|=
literal|"http.connection"
decl_stmt|;
comment|/**      * This constant is the Message(Map) key for a list of visited URLs that      * is used in redirect loop protection.      */
specifier|private
specifier|static
specifier|final
name|String
name|KEY_VISITED_URLS
init|=
literal|"VisitedURLs"
decl_stmt|;
comment|/**      * This constant is the Message(Map) key for a list of URLs that      * is used in authorization loop protection.      */
specifier|private
specifier|static
specifier|final
name|String
name|KEY_AUTH_URLS
init|=
literal|"AuthURLs"
decl_stmt|;
comment|/**      * The Logger for this class.      */
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LogUtils
operator|.
name|getL7dLogger
argument_list|(
name|HTTPConduit
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * This constant holds the suffix ".http-conduit" that is appended to the       * Endpoint Qname to give the configuration name of this conduit.      */
specifier|private
specifier|static
specifier|final
name|String
name|SC_HTTP_CONDUIT_SUFFIX
init|=
literal|".http-conduit"
decl_stmt|;
comment|/**      * This field holds the connection factory, which primarily is used to       * factor out SSL specific code from this implementation.      *<p>      * This field is "protected" to facilitate some contrived UnitTesting so      * that an extended class may alter its value with an EasyMock URLConnection      * Factory.       */
specifier|protected
name|HttpURLConnectionFactory
name|connectionFactory
decl_stmt|;
comment|/**      *  This field holds a reference to the CXF bus associated this conduit.      */
specifier|private
specifier|final
name|Bus
name|bus
decl_stmt|;
comment|/**      * This field is used for two reasons. First it provides the base name for      * the conduit for Spring configuration. The other is to hold default       * address information, should it not be supplied in the Message Map, by the       * Message.ENDPOINT_ADDRESS property.      */
specifier|private
specifier|final
name|EndpointInfo
name|endpointInfo
decl_stmt|;
comment|/**      * This field holds the "default" URL for this particular conduit, which      * is created on demand.      */
specifier|private
name|URL
name|defaultEndpointURL
decl_stmt|;
specifier|private
name|boolean
name|fromEndpointReferenceType
decl_stmt|;
specifier|private
name|Destination
name|decoupledDestination
decl_stmt|;
specifier|private
name|MessageObserver
name|decoupledObserver
decl_stmt|;
specifier|private
name|int
name|decoupledDestinationRefCount
decl_stmt|;
comment|// Configurable values
comment|/**      * This field holds the QoS configuration settings for this conduit.      * This field is injected via spring configuration based on the conduit       * name.      */
specifier|private
name|HTTPClientPolicy
name|clientSidePolicy
decl_stmt|;
comment|/**      * This field holds the password authorization configuration.      * This field is injected via spring configuration based on the conduit       * name.     */
specifier|private
name|AuthorizationPolicy
name|authorizationPolicy
decl_stmt|;
comment|/**      * This field holds the password authorization configuration for the       * configured proxy. This field is injected via spring configuration based       * on the conduit name.      */
specifier|private
name|ProxyAuthorizationPolicy
name|proxyAuthorizationPolicy
decl_stmt|;
comment|/**      * This field holds the configuration TLS configuration which      * is programmatically configured.       */
specifier|private
name|TLSClientParameters
name|tlsClientParameters
decl_stmt|;
comment|/**      * This field contains the MessageTrustDecider.      */
specifier|private
name|MessageTrustDecider
name|trustDecider
decl_stmt|;
comment|/**      * This field contains the HttpAuthSupplier.      */
specifier|private
name|HttpAuthSupplier
name|authSupplier
decl_stmt|;
comment|/**      * This boolean signfies that that finalizeConfig is called, which is      * after the HTTPTransportFactory configures this object via spring.      * At this point, any change by a "setter" is dynamic, and any change      * should be handled as such.      */
specifier|private
name|boolean
name|configFinalized
decl_stmt|;
comment|/**      * Variables for holding session state if sessions are supposed to be maintained      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Cookie
argument_list|>
name|sessionCookies
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Cookie
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|maintainSession
decl_stmt|;
specifier|private
name|CertConstraints
name|certConstraints
decl_stmt|;
comment|/**      * Constructor      *       * @param b the associated Bus      * @param ei the endpoint info of the initiator      * @throws IOException      */
specifier|public
name|HTTPConduit
parameter_list|(
name|Bus
name|b
parameter_list|,
name|EndpointInfo
name|ei
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|b
argument_list|,
name|ei
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor      *       * @param b the associated Bus.      * @param endpoint the endpoint info of the initiator.      * @param t the endpoint reference of the target.      * @throws IOException      */
specifier|public
name|HTTPConduit
parameter_list|(
name|Bus
name|b
parameter_list|,
name|EndpointInfo
name|ei
parameter_list|,
name|EndpointReferenceType
name|t
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|getTargetReference
argument_list|(
name|ei
argument_list|,
name|t
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|bus
operator|=
name|b
expr_stmt|;
name|endpointInfo
operator|=
name|ei
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|fromEndpointReferenceType
operator|=
literal|true
expr_stmt|;
block|}
name|initializeConfig
argument_list|()
expr_stmt|;
block|}
comment|/**      * This method returns the registered Logger for this conduit.      */
specifier|protected
name|Logger
name|getLogger
parameter_list|()
block|{
return|return
name|LOG
return|;
block|}
comment|/**      * This method returns the name of the conduit, which is based on the      * endpoint name plus the SC_HTTP_CONDUIT_SUFFIX.      * @return      */
specifier|public
specifier|final
name|String
name|getConduitName
parameter_list|()
block|{
return|return
name|endpointInfo
operator|.
name|getName
argument_list|()
operator|+
name|SC_HTTP_CONDUIT_SUFFIX
return|;
block|}
comment|/**      * This method is called from the constructor which initializes      * the configuration. The TransportFactory will call configureBean      * on this object after construction.      */
specifier|private
name|void
name|initializeConfig
parameter_list|()
block|{
comment|// wsdl extensors are superseded by policies which in
comment|// turn are superseded by injection
name|PolicyEngine
name|pe
init|=
name|bus
operator|.
name|getExtension
argument_list|(
name|PolicyEngine
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|pe
operator|&&
name|pe
operator|.
name|isEnabled
argument_list|()
operator|&&
name|endpointInfo
operator|.
name|getService
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|clientSidePolicy
operator|=
name|PolicyUtils
operator|.
name|getClient
argument_list|(
name|pe
argument_list|,
name|endpointInfo
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This call gets called by the HTTPTransportFactory after it      * causes an injection of the Spring configuration properties      * of this Conduit.      */
specifier|protected
name|void
name|finalizeConfig
parameter_list|()
block|{
comment|// See if not set by configuration, if there are defaults
comment|// in order from the Endpoint, Service, or Bus.
if|if
condition|(
name|this
operator|.
name|clientSidePolicy
operator|==
literal|null
condition|)
block|{
name|clientSidePolicy
operator|=
name|endpointInfo
operator|.
name|getTraversedExtensor
argument_list|(
operator|new
name|HTTPClientPolicy
argument_list|()
argument_list|,
name|HTTPClientPolicy
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|authorizationPolicy
operator|==
literal|null
condition|)
block|{
name|authorizationPolicy
operator|=
name|endpointInfo
operator|.
name|getTraversedExtensor
argument_list|(
operator|new
name|AuthorizationPolicy
argument_list|()
argument_list|,
name|AuthorizationPolicy
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|proxyAuthorizationPolicy
operator|==
literal|null
condition|)
block|{
name|proxyAuthorizationPolicy
operator|=
name|endpointInfo
operator|.
name|getTraversedExtensor
argument_list|(
operator|new
name|ProxyAuthorizationPolicy
argument_list|()
argument_list|,
name|ProxyAuthorizationPolicy
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|tlsClientParameters
operator|==
literal|null
condition|)
block|{
name|tlsClientParameters
operator|=
name|endpointInfo
operator|.
name|getTraversedExtensor
argument_list|(
literal|null
argument_list|,
name|TLSClientParameters
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|trustDecider
operator|==
literal|null
condition|)
block|{
name|trustDecider
operator|=
name|endpointInfo
operator|.
name|getTraversedExtensor
argument_list|(
literal|null
argument_list|,
name|MessageTrustDecider
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|authSupplier
operator|==
literal|null
condition|)
block|{
name|authSupplier
operator|=
name|endpointInfo
operator|.
name|getTraversedExtensor
argument_list|(
literal|null
argument_list|,
name|HttpAuthSupplier
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trustDecider
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"No Trust Decider configured for Conduit '"
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Message Trust Decider of class '"
operator|+
name|trustDecider
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' with logical name of '"
operator|+
name|trustDecider
operator|.
name|getLogicalName
argument_list|()
operator|+
literal|"' has been configured for Conduit '"
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|authSupplier
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"No Auth Supplier configured for Conduit '"
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"HttpAuthSupplier of class '"
operator|+
name|authSupplier
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' with logical name of '"
operator|+
name|authSupplier
operator|.
name|getLogicalName
argument_list|()
operator|+
literal|"' has been configured for Conduit '"
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|tlsClientParameters
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Conduit '"
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"' has been configured for TLS "
operator|+
literal|"keyManagers "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|tlsClientParameters
operator|.
name|getKeyManagers
argument_list|()
argument_list|)
operator|+
literal|"trustManagers "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|tlsClientParameters
operator|.
name|getTrustManagers
argument_list|()
argument_list|)
operator|+
literal|"secureRandom "
operator|+
name|tlsClientParameters
operator|.
name|getSecureRandom
argument_list|()
operator|+
literal|"Disable Common Name (CN) Check: "
operator|+
name|tlsClientParameters
operator|.
name|isDisableCNCheck
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Conduit '"
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"' has been configured for plain http."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Get the correct URLConnection factory based on the
comment|// configuration.
name|retrieveConnectionFactory
argument_list|()
expr_stmt|;
comment|// We have finalized the configuration. Any configurable entity
comment|// set now, must make changes dynamically.
name|configFinalized
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * Allow access to the cookies that the conduit is maintaining      * @return the sessionCookies map      */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Cookie
argument_list|>
name|getCookies
parameter_list|()
block|{
return|return
name|sessionCookies
return|;
block|}
comment|/**      * This method sets the connectionFactory field for this object. It is called      * after an SSL Client Policy is set or an HttpsHostnameVerifier      * because we need to reinitialize the connection factory.      *<p>      * This method is "protected" so that this class may be extended and override      * this method to put an EasyMock URL Connection factory for some contrived       * UnitTest that will of course break, should the calls to the URL Connection      * Factory get altered.      */
specifier|protected
specifier|synchronized
name|void
name|retrieveConnectionFactory
parameter_list|()
block|{
name|connectionFactory
operator|=
name|AbstractHTTPTransportFactory
operator|.
name|getConnectionFactory
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|synchronized
name|void
name|retrieveConnectionFactory
parameter_list|(
name|String
name|url
parameter_list|)
block|{
name|connectionFactory
operator|=
name|AbstractHTTPTransportFactory
operator|.
name|getConnectionFactory
argument_list|(
name|this
argument_list|,
name|url
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|synchronized
name|HttpURLConnectionFactory
name|getConnectionFactory
parameter_list|(
name|URL
name|url
parameter_list|)
block|{
if|if
condition|(
name|connectionFactory
operator|==
literal|null
operator|||
operator|!
name|url
operator|.
name|getProtocol
argument_list|()
operator|.
name|equals
argument_list|(
name|connectionFactory
operator|.
name|getProtocol
argument_list|()
argument_list|)
condition|)
block|{
name|retrieveConnectionFactory
argument_list|(
name|url
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|connectionFactory
return|;
block|}
comment|/**      * Prepare to send an outbound HTTP message over this http conduit to a       * particular endpoint.      *<P>      * If the Message.PATH_INFO property is set it gets appended      * to the Conduit's endpoint URL. If the Message.QUERY_STRING      * property is set, it gets appended to the resultant URL following      * a "?".      *<P>      * If the Message.HTTP_REQUEST_METHOD property is NOT set, the      * Http request method defaults to "POST".      *<P>      * If the Message.PROTOCOL_HEADERS is not set on the message, it is      * initialized to an empty map.      *<P>      * This call creates the OutputStream for the content of the message.      * It also assigns the created Http(s)URLConnection to the Message      * Map.      *       * @param message The message to be sent.      */
specifier|public
name|void
name|prepare
parameter_list|(
name|Message
name|message
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|headers
init|=
name|getSetProtocolHeaders
argument_list|(
name|message
argument_list|)
decl_stmt|;
comment|// This call can possibly change the conduit endpoint address and
comment|// protocol from the default set in EndpointInfo that is associated
comment|// with the Conduit.
name|URL
name|currentURL
init|=
name|setupURL
argument_list|(
name|message
argument_list|)
decl_stmt|;
comment|// The need to cache the request is off by default
name|boolean
name|needToCacheRequest
init|=
literal|false
decl_stmt|;
name|HTTPClientPolicy
name|csPolicy
init|=
name|getClient
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|HttpURLConnection
name|connection
init|=
name|getConnectionFactory
argument_list|(
name|currentURL
argument_list|)
operator|.
name|createConnection
argument_list|(
name|getProxy
argument_list|(
name|csPolicy
argument_list|)
argument_list|,
name|currentURL
argument_list|)
decl_stmt|;
name|connection
operator|.
name|setDoOutput
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|//TODO using Message context to decided HTTP send properties
name|long
name|timeout
init|=
name|csPolicy
operator|.
name|getConnectionTimeout
argument_list|()
decl_stmt|;
if|if
condition|(
name|timeout
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|timeout
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
name|connection
operator|.
name|setConnectTimeout
argument_list|(
operator|(
name|int
operator|)
name|timeout
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|csPolicy
operator|.
name|getReceiveTimeout
argument_list|()
expr_stmt|;
if|if
condition|(
name|timeout
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|timeout
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
name|connection
operator|.
name|setReadTimeout
argument_list|(
operator|(
name|int
operator|)
name|timeout
argument_list|)
expr_stmt|;
name|connection
operator|.
name|setUseCaches
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// We implement redirects in this conduit. We do not
comment|// rely on the underlying URLConnection implementation
comment|// because of trust issues.
name|connection
operator|.
name|setInstanceFollowRedirects
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// If the HTTP_REQUEST_METHOD is not set, the default is "POST".
name|String
name|httpRequestMethod
init|=
operator|(
name|String
operator|)
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|HTTP_REQUEST_METHOD
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|httpRequestMethod
condition|)
block|{
name|connection
operator|.
name|setRequestMethod
argument_list|(
name|httpRequestMethod
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|connection
operator|.
name|setRequestMethod
argument_list|(
literal|"POST"
argument_list|)
expr_stmt|;
block|}
name|boolean
name|isChunking
init|=
literal|false
decl_stmt|;
name|int
name|chunkThreshold
init|=
literal|0
decl_stmt|;
comment|// We must cache the request if we have basic auth supplier
comment|// without preemptive basic auth.
if|if
condition|(
name|authSupplier
operator|!=
literal|null
condition|)
block|{
name|String
name|auth
init|=
name|authSupplier
operator|.
name|getPreemptiveAuthorization
argument_list|(
name|this
argument_list|,
name|currentURL
argument_list|,
name|message
argument_list|)
decl_stmt|;
if|if
condition|(
name|auth
operator|==
literal|null
operator|||
name|authSupplier
operator|.
name|requiresRequestCaching
argument_list|()
condition|)
block|{
name|needToCacheRequest
operator|=
literal|true
expr_stmt|;
name|isChunking
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Auth Supplier, but no Premeptive User Pass or Digest auth (nonce may be stale)"
operator|+
literal|" We must cache request."
argument_list|)
expr_stmt|;
block|}
name|message
operator|.
name|put
argument_list|(
literal|"AUTH_VALUE"
argument_list|,
name|auth
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csPolicy
operator|.
name|isAutoRedirect
argument_list|()
condition|)
block|{
name|needToCacheRequest
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"AutoRedirect is turned on."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csPolicy
operator|.
name|getMaxRetransmits
argument_list|()
operator|>
literal|0
condition|)
block|{
name|needToCacheRequest
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"MaxRetransmits is set> 0."
argument_list|)
expr_stmt|;
block|}
comment|// DELETE does not work and empty PUTs cause misleading exceptions
comment|// if chunking is enabled
comment|// TODO : ensure chunking can be enabled for non-empty PUTs - if requested
if|if
condition|(
name|connection
operator|.
name|getRequestMethod
argument_list|()
operator|.
name|equals
argument_list|(
literal|"POST"
argument_list|)
operator|&&
name|csPolicy
operator|.
name|isAllowChunking
argument_list|()
condition|)
block|{
comment|//TODO: The chunking mode be configured or at least some
comment|// documented client constant.
comment|//use -1 and allow the URL connection to pick a default value
name|isChunking
operator|=
literal|true
expr_stmt|;
name|chunkThreshold
operator|=
name|csPolicy
operator|.
name|getChunkingThreshold
argument_list|()
expr_stmt|;
if|if
condition|(
name|chunkThreshold
operator|<=
literal|0
condition|)
block|{
name|chunkThreshold
operator|=
literal|0
expr_stmt|;
name|connection
operator|.
name|setChunkedStreamingMode
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|//Do we need to maintain a session?
name|maintainSession
operator|=
name|Boolean
operator|.
name|TRUE
operator|.
name|equals
argument_list|(
operator|(
name|Boolean
operator|)
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|MAINTAIN_SESSION
argument_list|)
argument_list|)
expr_stmt|;
comment|//If we have any cookies and we are maintaining sessions, then use them
if|if
condition|(
name|maintainSession
operator|&&
name|sessionCookies
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|cookies
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|headers
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|HttpHeaderHelper
operator|.
name|COOKIE
operator|.
name|equalsIgnoreCase
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|cookies
operator|=
name|headers
operator|.
name|remove
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cookies
operator|==
literal|null
condition|)
block|{
name|cookies
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|cookies
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|cookies
argument_list|)
expr_stmt|;
block|}
name|headers
operator|.
name|put
argument_list|(
name|HttpHeaderHelper
operator|.
name|COOKIE
argument_list|,
name|cookies
argument_list|)
expr_stmt|;
for|for
control|(
name|Cookie
name|c
range|:
name|sessionCookies
operator|.
name|values
argument_list|()
control|)
block|{
name|cookies
operator|.
name|add
argument_list|(
name|c
operator|.
name|requestCookieHeader
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// The trust decision is relegated to after the "flushing" of the
comment|// request headers.
comment|// We place the connection on the message to pick it up
comment|// in the WrappedOutputStream.
name|message
operator|.
name|put
argument_list|(
name|KEY_HTTP_CONNECTION
argument_list|,
name|connection
argument_list|)
expr_stmt|;
if|if
condition|(
name|certConstraints
operator|!=
literal|null
condition|)
block|{
name|message
operator|.
name|put
argument_list|(
name|CertConstraints
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|certConstraints
argument_list|)
expr_stmt|;
name|message
operator|.
name|getInterceptorChain
argument_list|()
operator|.
name|add
argument_list|(
name|CertConstraintsInterceptor
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
comment|// Set the headers on the message according to configured
comment|// client side policy.
name|setHeadersByPolicy
argument_list|(
name|message
argument_list|,
name|currentURL
argument_list|,
name|headers
argument_list|)
expr_stmt|;
name|message
operator|.
name|setContent
argument_list|(
name|OutputStream
operator|.
name|class
argument_list|,
operator|new
name|WrappedOutputStream
argument_list|(
name|message
argument_list|,
name|connection
argument_list|,
name|needToCacheRequest
argument_list|,
name|isChunking
argument_list|,
name|chunkThreshold
argument_list|)
argument_list|)
expr_stmt|;
comment|// We are now "ready" to "send" the message.
block|}
specifier|public
name|void
name|close
parameter_list|(
name|Message
name|msg
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStream
name|in
init|=
name|msg
operator|.
name|getContent
argument_list|(
name|InputStream
operator|.
name|class
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|byte
name|buffer
index|[]
init|=
operator|new
name|byte
index|[
literal|1024
index|]
decl_stmt|;
while|while
condition|(
name|in
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|count
operator|<
literal|25
condition|)
block|{
comment|//don't do anything, we just need to pull off the unread data (like
comment|//closing tags that we didn't need to read
comment|//however, limit it so we don't read off gigabytes of data we won't use.
operator|++
name|count
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|super
operator|.
name|close
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This call must take place before anything is written to the       * URLConnection. The URLConnection.connect() will be called in order       * to get the connection information.       *       * This method is invoked just after setURLRequestHeaders() from the       * WrappedOutputStream before it writes data to the URLConnection.      *       * If trust cannot be established the Trust Decider implemenation      * throws an IOException.      *       * @param message      The message being sent.      * @throws IOException This exception is thrown if trust cannot be      *                     established by the configured MessageTrustDecider.      * @see MessageTrustDecider      */
specifier|private
name|void
name|makeTrustDecision
parameter_list|(
name|Message
name|message
parameter_list|)
throws|throws
name|IOException
block|{
name|HttpURLConnection
name|connection
init|=
operator|(
name|HttpURLConnection
operator|)
name|message
operator|.
name|get
argument_list|(
name|KEY_HTTP_CONNECTION
argument_list|)
decl_stmt|;
name|MessageTrustDecider
name|decider2
init|=
name|message
operator|.
name|get
argument_list|(
name|MessageTrustDecider
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|trustDecider
operator|!=
literal|null
operator|||
name|decider2
operator|!=
literal|null
condition|)
block|{
try|try
block|{
comment|// We must connect or we will not get the credentials.
comment|// The call is (said to be) ingored internally if
comment|// already connected.
name|connection
operator|.
name|connect
argument_list|()
expr_stmt|;
name|URLConnectionInfo
name|info
init|=
name|getConnectionFactory
argument_list|(
name|connection
operator|.
name|getURL
argument_list|()
argument_list|)
operator|.
name|getConnectionInfo
argument_list|(
name|connection
argument_list|)
decl_stmt|;
if|if
condition|(
name|trustDecider
operator|!=
literal|null
condition|)
block|{
name|trustDecider
operator|.
name|establishTrust
argument_list|(
name|getConduitName
argument_list|()
argument_list|,
name|info
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Trust Decider "
operator|+
name|trustDecider
operator|.
name|getLogicalName
argument_list|()
operator|+
literal|" considers Conduit "
operator|+
name|getConduitName
argument_list|()
operator|+
literal|" trusted."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|decider2
operator|!=
literal|null
condition|)
block|{
name|decider2
operator|.
name|establishTrust
argument_list|(
name|getConduitName
argument_list|()
argument_list|,
name|info
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Trust Decider "
operator|+
name|decider2
operator|.
name|getLogicalName
argument_list|()
operator|+
literal|" considers Conduit "
operator|+
name|getConduitName
argument_list|()
operator|+
literal|" trusted."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|UntrustedURLConnectionIOException
name|untrustedEx
parameter_list|)
block|{
comment|// This cast covers HttpsURLConnection as well.
operator|(
operator|(
name|HttpURLConnection
operator|)
name|connection
operator|)
operator|.
name|disconnect
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Trust Decider "
operator|+
name|trustDecider
operator|.
name|getLogicalName
argument_list|()
operator|+
literal|" considers Conduit "
operator|+
name|getConduitName
argument_list|()
operator|+
literal|" untrusted."
argument_list|,
name|untrustedEx
argument_list|)
expr_stmt|;
block|}
throw|throw
name|untrustedEx
throw|;
block|}
block|}
else|else
block|{
comment|// This case, when there is no trust decider, a trust
comment|// decision should be a matter of policy.
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"No Trust Decider for Conduit '"
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"'. An afirmative Trust Decision is assumed."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * This function sets up a URL based on ENDPOINT_ADDRESS, PATH_INFO,      * and QUERY_STRING properties in the Message. The QUERY_STRING gets      * added with a "?" after the PATH_INFO. If the ENDPOINT_ADDRESS is not      * set on the Message, the endpoint address is taken from the       * "defaultEndpointURL".      *<p>      * The PATH_INFO is only added to the endpoint address string should       * the PATH_INFO not equal the end of the endpoint address string.      *       * @param message The message holds the addressing information.      *       * @return The full URL specifying the HTTP request to the endpoint.      *       * @throws MalformedURLException      */
specifier|private
name|URL
name|setupURL
parameter_list|(
name|Message
name|message
parameter_list|)
throws|throws
name|MalformedURLException
block|{
name|String
name|result
init|=
operator|(
name|String
operator|)
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|ENDPOINT_ADDRESS
argument_list|)
decl_stmt|;
name|String
name|pathInfo
init|=
operator|(
name|String
operator|)
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|PATH_INFO
argument_list|)
decl_stmt|;
name|String
name|queryString
init|=
operator|(
name|String
operator|)
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|QUERY_STRING
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|pathInfo
operator|==
literal|null
operator|&&
name|queryString
operator|==
literal|null
condition|)
block|{
name|URL
name|url
init|=
name|getURL
argument_list|()
decl_stmt|;
name|message
operator|.
name|put
argument_list|(
name|Message
operator|.
name|ENDPOINT_ADDRESS
argument_list|,
name|url
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|url
return|;
block|}
name|result
operator|=
name|getURL
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|message
operator|.
name|put
argument_list|(
name|Message
operator|.
name|ENDPOINT_ADDRESS
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
comment|// REVISIT: is this really correct?
if|if
condition|(
literal|null
operator|!=
name|pathInfo
operator|&&
operator|!
name|result
operator|.
name|endsWith
argument_list|(
name|pathInfo
argument_list|)
condition|)
block|{
name|result
operator|=
name|result
operator|+
name|pathInfo
expr_stmt|;
block|}
if|if
condition|(
name|queryString
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|result
operator|+
literal|"?"
operator|+
name|queryString
expr_stmt|;
block|}
return|return
operator|new
name|URL
argument_list|(
name|result
argument_list|)
return|;
block|}
comment|/**      * Retreive the back-channel Destination.      *       * @return the backchannel Destination (or null if the backchannel is      * built-in)      */
specifier|public
specifier|synchronized
name|Destination
name|getBackChannel
parameter_list|()
block|{
if|if
condition|(
name|decoupledDestination
operator|==
literal|null
operator|&&
name|getClient
argument_list|()
operator|.
name|getDecoupledEndpoint
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|setUpDecoupledDestination
argument_list|()
expr_stmt|;
block|}
return|return
name|decoupledDestination
return|;
block|}
comment|/**      * Close the conduit      */
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|defaultEndpointURL
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|URLConnection
name|connect
init|=
name|defaultEndpointURL
operator|.
name|openConnection
argument_list|()
decl_stmt|;
if|if
condition|(
name|connect
operator|instanceof
name|HttpURLConnection
condition|)
block|{
operator|(
operator|(
name|HttpURLConnection
operator|)
name|connect
operator|)
operator|.
name|disconnect
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|//ignore
block|}
comment|//defaultEndpointURL = null;
block|}
comment|// in decoupled case, close response Destination if reference count
comment|// hits zero
comment|//
if|if
condition|(
name|decoupledDestination
operator|!=
literal|null
condition|)
block|{
name|releaseDecoupledDestination
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * @return the default target address      */
specifier|protected
name|String
name|getAddress
parameter_list|()
throws|throws
name|MalformedURLException
block|{
if|if
condition|(
name|defaultEndpointURL
operator|!=
literal|null
condition|)
block|{
return|return
name|defaultEndpointURL
operator|.
name|toExternalForm
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|fromEndpointReferenceType
condition|)
block|{
return|return
name|getTarget
argument_list|()
operator|.
name|getAddress
argument_list|()
operator|.
name|getValue
argument_list|()
return|;
block|}
return|return
name|endpointInfo
operator|.
name|getAddress
argument_list|()
return|;
block|}
comment|/**      * @return the default target URL      */
specifier|protected
specifier|synchronized
name|URL
name|getURL
parameter_list|()
throws|throws
name|MalformedURLException
block|{
return|return
name|getURL
argument_list|(
literal|true
argument_list|)
return|;
block|}
comment|/**      * @param createOnDemand create URL on-demand if null      * @return the default target URL      */
specifier|protected
specifier|synchronized
name|URL
name|getURL
parameter_list|(
name|boolean
name|createOnDemand
parameter_list|)
throws|throws
name|MalformedURLException
block|{
if|if
condition|(
name|defaultEndpointURL
operator|==
literal|null
operator|&&
name|createOnDemand
condition|)
block|{
if|if
condition|(
name|fromEndpointReferenceType
operator|&&
name|getTarget
argument_list|()
operator|.
name|getAddress
argument_list|()
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|defaultEndpointURL
operator|=
operator|new
name|URL
argument_list|(
name|this
operator|.
name|getTarget
argument_list|()
operator|.
name|getAddress
argument_list|()
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|defaultEndpointURL
return|;
block|}
if|if
condition|(
name|endpointInfo
operator|.
name|getAddress
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|MalformedURLException
argument_list|(
literal|"Invalid address. Endpoint address cannot be null."
argument_list|)
throw|;
block|}
name|defaultEndpointURL
operator|=
operator|new
name|URL
argument_list|(
name|endpointInfo
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|defaultEndpointURL
return|;
block|}
comment|/**      * While extracting the Message.PROTOCOL_HEADERS property from the Message,      * this call ensures that the Message.PROTOCOL_HEADERS property is      * set on the Message. If it is not set, an empty map is placed there, and      * then returned.      *       * @param message The outbound message      * @return The PROTOCOL_HEADERS map      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|getSetProtocolHeaders
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|headers
init|=
name|CastUtils
operator|.
name|cast
argument_list|(
operator|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|PROTOCOL_HEADERS
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|headers
condition|)
block|{
name|headers
operator|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|headers
operator|instanceof
name|HashMap
condition|)
block|{
name|headers
operator|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|(
name|headers
argument_list|)
expr_stmt|;
block|}
name|message
operator|.
name|put
argument_list|(
name|Message
operator|.
name|PROTOCOL_HEADERS
argument_list|,
name|headers
argument_list|)
expr_stmt|;
return|return
name|headers
return|;
block|}
comment|/**      * This procedure sets the URLConnection request properties      * from the PROTOCOL_HEADERS in the message.      */
specifier|private
name|void
name|transferProtocolHeadersToURLConnection
parameter_list|(
name|Message
name|message
parameter_list|,
name|URLConnection
name|connection
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|headers
init|=
name|getSetProtocolHeaders
argument_list|(
name|message
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|header
range|:
name|headers
operator|.
name|keySet
argument_list|()
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|headerList
init|=
name|headers
operator|.
name|get
argument_list|(
name|header
argument_list|)
decl_stmt|;
if|if
condition|(
name|HttpHeaderHelper
operator|.
name|CONTENT_TYPE
operator|.
name|equalsIgnoreCase
argument_list|(
name|header
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|HttpHeaderHelper
operator|.
name|COOKIE
operator|.
name|equalsIgnoreCase
argument_list|(
name|header
argument_list|)
condition|)
block|{
for|for
control|(
name|String
name|s
range|:
name|headerList
control|)
block|{
name|connection
operator|.
name|addRequestProperty
argument_list|(
name|HttpHeaderHelper
operator|.
name|COOKIE
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|headerList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|.
name|append
argument_list|(
name|headerList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|headerList
operator|.
name|size
argument_list|()
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
name|connection
operator|.
name|setRequestProperty
argument_list|(
name|header
argument_list|,
name|b
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|connection
operator|.
name|getRequestProperties
argument_list|()
operator|.
name|containsKey
argument_list|(
literal|"User-Agent"
argument_list|)
condition|)
block|{
name|connection
operator|.
name|addRequestProperty
argument_list|(
literal|"User-Agent"
argument_list|,
name|Version
operator|.
name|getCompleteVersionString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This procedure logs the PROTOCOL_HEADERS from the       * Message at the specified logging level.      *       * @param level   The Logging Level.      * @param headers The Message protocol headers.      */
specifier|private
name|void
name|logProtocolHeaders
parameter_list|(
name|Level
name|level
parameter_list|,
name|Message
name|message
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|headers
init|=
name|getSetProtocolHeaders
argument_list|(
name|message
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|header
range|:
name|headers
operator|.
name|keySet
argument_list|()
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|headerList
init|=
name|headers
operator|.
name|get
argument_list|(
name|header
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|value
range|:
name|headerList
control|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|level
argument_list|,
name|header
operator|+
literal|": "
operator|+
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Put the headers from Message.PROTOCOL_HEADERS headers into the URL      * connection.      * Note, this does not mean they immediately get written to the output      * stream or the wire. They just just get set on the HTTP request.      *       * @param message The outbound message.      * @throws IOException      */
specifier|private
name|void
name|setURLRequestHeaders
parameter_list|(
name|Message
name|message
parameter_list|)
throws|throws
name|IOException
block|{
name|HttpURLConnection
name|connection
init|=
operator|(
name|HttpURLConnection
operator|)
name|message
operator|.
name|get
argument_list|(
name|KEY_HTTP_CONNECTION
argument_list|)
decl_stmt|;
name|String
name|ct
init|=
operator|(
name|String
operator|)
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|CONTENT_TYPE
argument_list|)
decl_stmt|;
name|String
name|enc
init|=
operator|(
name|String
operator|)
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|ct
condition|)
block|{
if|if
condition|(
name|enc
operator|!=
literal|null
operator|&&
name|ct
operator|.
name|indexOf
argument_list|(
literal|"charset="
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|!
name|ct
operator|.
name|toLowerCase
argument_list|()
operator|.
name|contains
argument_list|(
literal|"multipart/related"
argument_list|)
condition|)
block|{
name|ct
operator|=
name|ct
operator|+
literal|"; charset="
operator|+
name|enc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|enc
operator|!=
literal|null
condition|)
block|{
name|ct
operator|=
literal|"text/xml; charset="
operator|+
name|enc
expr_stmt|;
block|}
else|else
block|{
name|ct
operator|=
literal|"text/xml"
expr_stmt|;
block|}
name|connection
operator|.
name|setRequestProperty
argument_list|(
name|HttpHeaderHelper
operator|.
name|CONTENT_TYPE
argument_list|,
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
literal|"Sending "
operator|+
name|connection
operator|.
name|getRequestMethod
argument_list|()
operator|+
literal|" Message with Headers to "
operator|+
name|connection
operator|.
name|getURL
argument_list|()
operator|+
literal|" Conduit :"
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"\nContent-Type: "
operator|+
name|ct
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|logProtocolHeaders
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
name|transferProtocolHeadersToURLConnection
argument_list|(
name|message
argument_list|,
name|connection
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set up the decoupled Destination if necessary.      */
specifier|private
name|void
name|setUpDecoupledDestination
parameter_list|()
block|{
name|EndpointReferenceType
name|reference
init|=
name|EndpointReferenceUtils
operator|.
name|getEndpointReference
argument_list|(
name|getClient
argument_list|()
operator|.
name|getDecoupledEndpoint
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|reference
operator|!=
literal|null
condition|)
block|{
name|String
name|decoupledAddress
init|=
name|reference
operator|.
name|getAddress
argument_list|()
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"creating decoupled endpoint: "
operator|+
name|decoupledAddress
argument_list|)
expr_stmt|;
try|try
block|{
name|decoupledDestination
operator|=
name|getDestination
argument_list|(
name|decoupledAddress
argument_list|)
expr_stmt|;
name|duplicateDecoupledDestination
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// REVISIT move message to localizable Messages.properties
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"decoupled endpoint creation failed: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * @param address the address      * @return a Destination for the address      */
specifier|private
name|Destination
name|getDestination
parameter_list|(
name|String
name|address
parameter_list|)
throws|throws
name|IOException
block|{
name|Destination
name|destination
init|=
literal|null
decl_stmt|;
name|DestinationFactoryManager
name|factoryManager
init|=
name|bus
operator|.
name|getExtension
argument_list|(
name|DestinationFactoryManager
operator|.
name|class
argument_list|)
decl_stmt|;
name|DestinationFactory
name|factory
init|=
name|factoryManager
operator|.
name|getDestinationFactoryForUri
argument_list|(
name|address
argument_list|)
decl_stmt|;
if|if
condition|(
name|factory
operator|!=
literal|null
condition|)
block|{
name|EndpointInfo
name|ei
init|=
operator|new
name|EndpointInfo
argument_list|()
decl_stmt|;
name|ei
operator|.
name|setAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
name|destination
operator|=
name|factory
operator|.
name|getDestination
argument_list|(
name|ei
argument_list|)
expr_stmt|;
name|decoupledObserver
operator|=
operator|new
name|InterposedMessageObserver
argument_list|()
expr_stmt|;
name|destination
operator|.
name|setMessageObserver
argument_list|(
name|decoupledObserver
argument_list|)
expr_stmt|;
block|}
return|return
name|destination
return|;
block|}
comment|/**      * @return the decoupled observer      */
specifier|protected
name|MessageObserver
name|getDecoupledObserver
parameter_list|()
block|{
return|return
name|decoupledObserver
return|;
block|}
specifier|private
specifier|synchronized
name|void
name|duplicateDecoupledDestination
parameter_list|()
block|{
name|decoupledDestinationRefCount
operator|++
expr_stmt|;
block|}
specifier|private
specifier|synchronized
name|void
name|releaseDecoupledDestination
parameter_list|()
block|{
if|if
condition|(
operator|--
name|decoupledDestinationRefCount
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"shutting down decoupled destination"
argument_list|)
expr_stmt|;
name|decoupledDestination
operator|.
name|shutdown
argument_list|()
expr_stmt|;
comment|//this way we can release the port of decoupled destination
name|decoupledDestination
operator|.
name|setMessageObserver
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This predicate returns true iff the exchange indicates       * a oneway MEP.      *       * @param exchange The exchange in question      */
specifier|private
name|boolean
name|isOneway
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|!=
literal|null
operator|&&
name|exchange
operator|.
name|isOneWay
argument_list|()
return|;
block|}
comment|/**      * @return true if expecting a decoupled response      */
specifier|private
name|boolean
name|isDecoupled
parameter_list|()
block|{
return|return
name|decoupledDestination
operator|!=
literal|null
return|;
block|}
comment|/**      * Get an input stream containing the partial response if one is present.      *       * @param connection the connection in question      * @param responseCode the response code      * @return an input stream if a partial response is pending on the connection       */
specifier|protected
specifier|static
name|InputStream
name|getPartialResponse
parameter_list|(
name|HttpURLConnection
name|connection
parameter_list|,
name|int
name|responseCode
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStream
name|in
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|responseCode
operator|==
name|HttpURLConnection
operator|.
name|HTTP_ACCEPTED
operator|||
name|responseCode
operator|==
name|HttpURLConnection
operator|.
name|HTTP_OK
condition|)
block|{
if|if
condition|(
name|connection
operator|.
name|getContentLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|in
operator|=
name|connection
operator|.
name|getInputStream
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hasChunkedResponse
argument_list|(
name|connection
argument_list|)
operator|||
name|hasEofTerminatedResponse
argument_list|(
name|connection
argument_list|)
condition|)
block|{
comment|// ensure chunked or EOF-terminated response is non-empty
name|in
operator|=
name|getNonEmptyContent
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|in
return|;
block|}
comment|/**      * @param connection the given HttpURLConnection      * @return true iff the connection has a chunked response pending      */
specifier|private
specifier|static
name|boolean
name|hasChunkedResponse
parameter_list|(
name|HttpURLConnection
name|connection
parameter_list|)
block|{
return|return
name|HttpHeaderHelper
operator|.
name|CHUNKED
operator|.
name|equalsIgnoreCase
argument_list|(
name|connection
operator|.
name|getHeaderField
argument_list|(
name|HttpHeaderHelper
operator|.
name|TRANSFER_ENCODING
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * @param connection the given HttpURLConnection      * @return true iff the connection has a chunked response pending      */
specifier|private
specifier|static
name|boolean
name|hasEofTerminatedResponse
parameter_list|(
name|HttpURLConnection
name|connection
parameter_list|)
block|{
return|return
name|HttpHeaderHelper
operator|.
name|CLOSE
operator|.
name|equalsIgnoreCase
argument_list|(
name|connection
operator|.
name|getHeaderField
argument_list|(
name|HttpHeaderHelper
operator|.
name|CONNECTION
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * @param connection the given HttpURLConnection      * @return an input stream containing the response content if non-empty      */
specifier|private
specifier|static
name|InputStream
name|getNonEmptyContent
parameter_list|(
name|HttpURLConnection
name|connection
parameter_list|)
block|{
name|InputStream
name|in
init|=
literal|null
decl_stmt|;
try|try
block|{
name|PushbackInputStream
name|pin
init|=
operator|new
name|PushbackInputStream
argument_list|(
name|connection
operator|.
name|getInputStream
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|pin
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|pin
operator|.
name|unread
argument_list|(
operator|(
name|byte
operator|)
name|c
argument_list|)
expr_stmt|;
name|in
operator|=
name|pin
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// ignore
block|}
return|return
name|in
return|;
block|}
comment|/**      * This method returns the Proxy server should it be set on the       * Client Side Policy.      *       * @return The proxy server or null, if not set.      */
specifier|private
name|Proxy
name|getProxy
parameter_list|(
name|HTTPClientPolicy
name|policy
parameter_list|)
block|{
name|Proxy
name|proxy
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|policy
operator|!=
literal|null
operator|&&
name|policy
operator|.
name|isSetProxyServer
argument_list|()
operator|&&
operator|!
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|policy
operator|.
name|getProxyServer
argument_list|()
argument_list|)
condition|)
block|{
name|proxy
operator|=
operator|new
name|Proxy
argument_list|(
name|Proxy
operator|.
name|Type
operator|.
name|valueOf
argument_list|(
name|policy
operator|.
name|getProxyServerType
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
operator|new
name|InetSocketAddress
argument_list|(
name|policy
operator|.
name|getProxyServer
argument_list|()
argument_list|,
name|policy
operator|.
name|getProxyServerPort
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|proxy
return|;
block|}
comment|/**      * This call places HTTP Header strings into the headers that are relevant      * to the Authorization policies that are set on this conduit by       * configuration.      *<p>       * An AuthorizationPolicy may also be set on the message. If so, those       * policies are merged. A user name or password set on the messsage       * overrides settings in the AuthorizationPolicy is retrieved from the      * configuration.      *<p>      * The precedence is as follows:      * 1. AuthorizationPolicy that is set on the Message, if exists.      * 2. Authorization from AuthSupplier, if exists.      * 3. AuthorizationPolicy set/configured for conduit.      *       * REVISIT: Since the AuthorizationPolicy is set on the message by class, then      * how does one override the ProxyAuthorizationPolicy which is the same       * type?      *       * @param message      * @param headers      */
specifier|private
name|void
name|setHeadersByAuthorizationPolicy
parameter_list|(
name|Message
name|message
parameter_list|,
name|URL
name|url
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|headers
parameter_list|)
block|{
name|AuthorizationPolicy
name|authPolicy
init|=
name|getAuthorization
argument_list|()
decl_stmt|;
name|AuthorizationPolicy
name|newPolicy
init|=
name|message
operator|.
name|get
argument_list|(
name|AuthorizationPolicy
operator|.
name|class
argument_list|)
decl_stmt|;
name|String
name|authString
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|authSupplier
operator|!=
literal|null
operator|&&
operator|(
name|newPolicy
operator|==
literal|null
operator|||
operator|(
operator|!
literal|"Basic"
operator|.
name|equals
argument_list|(
name|newPolicy
operator|.
name|getAuthorizationType
argument_list|()
argument_list|)
operator|&&
name|newPolicy
operator|.
name|getAuthorization
argument_list|()
operator|==
literal|null
operator|)
operator|)
condition|)
block|{
name|authString
operator|=
operator|(
name|String
operator|)
name|message
operator|.
name|get
argument_list|(
literal|"AUTH_VALUE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|authString
operator|==
literal|null
condition|)
block|{
name|authString
operator|=
name|authSupplier
operator|.
name|getPreemptiveAuthorization
argument_list|(
name|this
argument_list|,
name|url
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
operator|.
name|remove
argument_list|(
literal|"AUTH_VALUE"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|authString
operator|!=
literal|null
condition|)
block|{
name|headers
operator|.
name|put
argument_list|(
literal|"Authorization"
argument_list|,
name|createMutableList
argument_list|(
name|authString
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|String
name|userName
init|=
literal|null
decl_stmt|;
name|String
name|passwd
init|=
literal|null
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|newPolicy
condition|)
block|{
name|userName
operator|=
name|newPolicy
operator|.
name|getUserName
argument_list|()
expr_stmt|;
name|passwd
operator|=
name|newPolicy
operator|.
name|getPassword
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|userName
operator|==
literal|null
operator|&&
name|authPolicy
operator|!=
literal|null
operator|&&
name|authPolicy
operator|.
name|isSetUserName
argument_list|()
condition|)
block|{
name|userName
operator|=
name|authPolicy
operator|.
name|getUserName
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|userName
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|passwd
operator|==
literal|null
operator|&&
name|authPolicy
operator|!=
literal|null
operator|&&
name|authPolicy
operator|.
name|isSetPassword
argument_list|()
condition|)
block|{
name|passwd
operator|=
name|authPolicy
operator|.
name|getPassword
argument_list|()
expr_stmt|;
block|}
name|setBasicAuthHeader
argument_list|(
name|userName
argument_list|,
name|passwd
argument_list|,
name|headers
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|authPolicy
operator|!=
literal|null
operator|&&
name|authPolicy
operator|.
name|isSetAuthorizationType
argument_list|()
operator|&&
name|authPolicy
operator|.
name|isSetAuthorization
argument_list|()
condition|)
block|{
name|String
name|type
init|=
name|authPolicy
operator|.
name|getAuthorizationType
argument_list|()
decl_stmt|;
name|type
operator|+=
literal|" "
expr_stmt|;
name|type
operator|+=
name|authPolicy
operator|.
name|getAuthorization
argument_list|()
expr_stmt|;
name|headers
operator|.
name|put
argument_list|(
literal|"Authorization"
argument_list|,
name|createMutableList
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|AuthorizationPolicy
name|proxyAuthPolicy
init|=
name|getProxyAuthorization
argument_list|()
decl_stmt|;
if|if
condition|(
name|proxyAuthPolicy
operator|!=
literal|null
operator|&&
name|proxyAuthPolicy
operator|.
name|isSetUserName
argument_list|()
condition|)
block|{
name|userName
operator|=
name|proxyAuthPolicy
operator|.
name|getUserName
argument_list|()
expr_stmt|;
if|if
condition|(
name|userName
operator|!=
literal|null
condition|)
block|{
name|passwd
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|proxyAuthPolicy
operator|.
name|isSetPassword
argument_list|()
condition|)
block|{
name|passwd
operator|=
name|proxyAuthPolicy
operator|.
name|getPassword
argument_list|()
expr_stmt|;
block|}
name|setProxyBasicAuthHeader
argument_list|(
name|userName
argument_list|,
name|passwd
argument_list|,
name|headers
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|proxyAuthPolicy
operator|.
name|isSetAuthorizationType
argument_list|()
operator|&&
name|proxyAuthPolicy
operator|.
name|isSetAuthorization
argument_list|()
condition|)
block|{
name|String
name|type
init|=
name|proxyAuthPolicy
operator|.
name|getAuthorizationType
argument_list|()
decl_stmt|;
name|type
operator|+=
literal|" "
expr_stmt|;
name|type
operator|+=
name|proxyAuthPolicy
operator|.
name|getAuthorization
argument_list|()
expr_stmt|;
name|headers
operator|.
name|put
argument_list|(
literal|"Proxy-Authorization"
argument_list|,
name|createMutableList
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|createMutableList
parameter_list|(
name|String
name|val
parameter_list|)
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
name|val
block|}
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * This call places HTTP Header strings into the headers that are relevant      * to the ClientPolicy that is set on this conduit by configuration.      *       * REVISIT: A cookie is set statically from configuration?       */
specifier|private
name|void
name|setHeadersByClientPolicy
parameter_list|(
name|Message
name|message
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|headers
parameter_list|)
block|{
name|HTTPClientPolicy
name|policy
init|=
name|getClient
argument_list|(
name|message
argument_list|)
decl_stmt|;
if|if
condition|(
name|policy
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|policy
operator|.
name|isSetCacheControl
argument_list|()
condition|)
block|{
name|headers
operator|.
name|put
argument_list|(
literal|"Cache-Control"
argument_list|,
name|createMutableList
argument_list|(
name|policy
operator|.
name|getCacheControl
argument_list|()
operator|.
name|value
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|policy
operator|.
name|isSetHost
argument_list|()
condition|)
block|{
name|headers
operator|.
name|put
argument_list|(
literal|"Host"
argument_list|,
name|createMutableList
argument_list|(
name|policy
operator|.
name|getHost
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|policy
operator|.
name|isSetConnection
argument_list|()
condition|)
block|{
name|headers
operator|.
name|put
argument_list|(
literal|"Connection"
argument_list|,
name|createMutableList
argument_list|(
name|policy
operator|.
name|getConnection
argument_list|()
operator|.
name|value
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|policy
operator|.
name|isSetAccept
argument_list|()
condition|)
block|{
name|headers
operator|.
name|put
argument_list|(
literal|"Accept"
argument_list|,
name|createMutableList
argument_list|(
name|policy
operator|.
name|getAccept
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|headers
operator|.
name|containsKey
argument_list|(
literal|"Accept"
argument_list|)
condition|)
block|{
name|headers
operator|.
name|put
argument_list|(
literal|"Accept"
argument_list|,
name|createMutableList
argument_list|(
literal|"*/*"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|policy
operator|.
name|isSetAcceptEncoding
argument_list|()
condition|)
block|{
name|headers
operator|.
name|put
argument_list|(
literal|"Accept-Encoding"
argument_list|,
name|createMutableList
argument_list|(
name|policy
operator|.
name|getAcceptEncoding
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|policy
operator|.
name|isSetAcceptLanguage
argument_list|()
condition|)
block|{
name|headers
operator|.
name|put
argument_list|(
literal|"Accept-Language"
argument_list|,
name|createMutableList
argument_list|(
name|policy
operator|.
name|getAcceptLanguage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|policy
operator|.
name|isSetContentType
argument_list|()
condition|)
block|{
name|message
operator|.
name|put
argument_list|(
name|Message
operator|.
name|CONTENT_TYPE
argument_list|,
name|policy
operator|.
name|getContentType
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|policy
operator|.
name|isSetCookie
argument_list|()
condition|)
block|{
name|headers
operator|.
name|put
argument_list|(
literal|"Cookie"
argument_list|,
name|createMutableList
argument_list|(
name|policy
operator|.
name|getCookie
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|policy
operator|.
name|isSetBrowserType
argument_list|()
condition|)
block|{
name|headers
operator|.
name|put
argument_list|(
literal|"BrowserType"
argument_list|,
name|createMutableList
argument_list|(
name|policy
operator|.
name|getBrowserType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|policy
operator|.
name|isSetReferer
argument_list|()
condition|)
block|{
name|headers
operator|.
name|put
argument_list|(
literal|"Referer"
argument_list|,
name|createMutableList
argument_list|(
name|policy
operator|.
name|getReferer
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This call places HTTP Header strings into the headers that are relevant      * to the polices that are set on this conduit by configuration for the      * ClientPolicy and AuthorizationPolicy.      *       *       * @param message The outgoing message.      * @param url     The URL the message is going to.      * @param headers The headers in the outgoing message.      */
specifier|private
name|void
name|setHeadersByPolicy
parameter_list|(
name|Message
name|message
parameter_list|,
name|URL
name|url
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|headers
parameter_list|)
block|{
name|setHeadersByAuthorizationPolicy
argument_list|(
name|message
argument_list|,
name|url
argument_list|,
name|headers
argument_list|)
expr_stmt|;
name|setHeadersByClientPolicy
argument_list|(
name|message
argument_list|,
name|headers
argument_list|)
expr_stmt|;
block|}
comment|/**      * This is part of the Configurable interface which retrieves the       * configuration from spring injection.      */
comment|// REVISIT:What happens when the endpoint/bean name is null?
specifier|public
name|String
name|getBeanName
parameter_list|()
block|{
if|if
condition|(
name|endpointInfo
operator|.
name|getName
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|endpointInfo
operator|.
name|getName
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|".http-conduit"
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * This method gets the Authorization Policy that was configured or       * explicitly set for this HTTPConduit.      */
specifier|public
name|AuthorizationPolicy
name|getAuthorization
parameter_list|()
block|{
return|return
name|authorizationPolicy
return|;
block|}
comment|/**      * This method is used to set the Authorization Policy for this conduit.      * Using this method will override any Authorization Policy set in       * configuration.      */
specifier|public
name|void
name|setAuthorization
parameter_list|(
name|AuthorizationPolicy
name|authorization
parameter_list|)
block|{
name|this
operator|.
name|authorizationPolicy
operator|=
name|authorization
expr_stmt|;
block|}
specifier|public
name|HTTPClientPolicy
name|getClient
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
return|return
name|PolicyUtils
operator|.
name|getClient
argument_list|(
name|message
argument_list|,
name|clientSidePolicy
argument_list|)
return|;
block|}
comment|/**      * This method retrieves the Client Side Policy set/configured for this      * HTTPConduit.      */
specifier|public
name|HTTPClientPolicy
name|getClient
parameter_list|()
block|{
return|return
name|clientSidePolicy
return|;
block|}
comment|/**      * This method sets the Client Side Policy for this HTTPConduit. Using this      * method will override any HTTPClientPolicy set in configuration.      */
specifier|public
name|void
name|setClient
parameter_list|(
name|HTTPClientPolicy
name|client
parameter_list|)
block|{
name|this
operator|.
name|clientSidePolicy
operator|=
name|client
expr_stmt|;
block|}
comment|/**      * This method retrieves the Proxy Authorization Policy for a proxy that is      * set/configured for this HTTPConduit.      */
specifier|public
name|ProxyAuthorizationPolicy
name|getProxyAuthorization
parameter_list|()
block|{
return|return
name|proxyAuthorizationPolicy
return|;
block|}
comment|/**      * This method sets the Proxy Authorization Policy for a specified proxy.       * Using this method overrides any Authorization Policy for the proxy       * that is set in the configuration.      */
specifier|public
name|void
name|setProxyAuthorization
parameter_list|(
name|ProxyAuthorizationPolicy
name|proxyAuthorization
parameter_list|)
block|{
name|this
operator|.
name|proxyAuthorizationPolicy
operator|=
name|proxyAuthorization
expr_stmt|;
block|}
comment|/**      * This method returns the TLS Client Parameters that is set/configured      * for this HTTPConduit.      */
specifier|public
name|TLSClientParameters
name|getTlsClientParameters
parameter_list|()
block|{
return|return
name|tlsClientParameters
return|;
block|}
comment|/**      * This method sets the TLS Client Parameters for this HTTPConduit.      * Using this method overrides any TLS Client Parameters that is configured      * for this HTTPConduit.      */
specifier|public
name|void
name|setTlsClientParameters
parameter_list|(
name|TLSClientParameters
name|params
parameter_list|)
block|{
name|this
operator|.
name|tlsClientParameters
operator|=
name|params
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|tlsClientParameters
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Conduit '"
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"' has been (re) configured for TLS "
operator|+
literal|"keyManagers "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|tlsClientParameters
operator|.
name|getKeyManagers
argument_list|()
argument_list|)
operator|+
literal|"trustManagers "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|tlsClientParameters
operator|.
name|getTrustManagers
argument_list|()
argument_list|)
operator|+
literal|"secureRandom "
operator|+
name|tlsClientParameters
operator|.
name|getSecureRandom
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|CertificateConstraintsType
name|constraints
init|=
name|params
operator|.
name|getCertConstraints
argument_list|()
decl_stmt|;
if|if
condition|(
name|constraints
operator|!=
literal|null
condition|)
block|{
name|certConstraints
operator|=
name|CertConstraintsJaxBUtils
operator|.
name|createCertConstraints
argument_list|(
name|constraints
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Conduit '"
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"' has been (re)configured for plain http."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If this is called after the HTTPTransportFactory called
comment|// finalizeConfig, we need to update the connection factory.
if|if
condition|(
name|configFinalized
condition|)
block|{
name|retrieveConnectionFactory
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * This method gets the Trust Decider that was set/configured for this       * HTTPConduit.      * @return The Message Trust Decider or null.      */
specifier|public
name|MessageTrustDecider
name|getTrustDecider
parameter_list|()
block|{
return|return
name|this
operator|.
name|trustDecider
return|;
block|}
comment|/**      * This method sets the Trust Decider for this HTTP Conduit.      * Using this method overrides any trust decider configured for this       * HTTPConduit.      */
specifier|public
name|void
name|setTrustDecider
parameter_list|(
name|MessageTrustDecider
name|decider
parameter_list|)
block|{
name|this
operator|.
name|trustDecider
operator|=
name|decider
expr_stmt|;
block|}
comment|/**      * This method gets the Auth Supplier that was set/configured for this       * HTTPConduit.      * @return The Auth Supplier or null.      */
specifier|public
name|HttpAuthSupplier
name|getAuthSupplier
parameter_list|()
block|{
return|return
name|this
operator|.
name|authSupplier
return|;
block|}
specifier|public
name|void
name|setAuthSupplier
parameter_list|(
name|HttpAuthSupplier
name|supplier
parameter_list|)
block|{
name|this
operator|.
name|authSupplier
operator|=
name|supplier
expr_stmt|;
block|}
comment|/**      * This function processes any retransmits at the direction of redirections      * or "unauthorized" responses.      *<p>      * If the request was not retransmitted, it returns the given connection.       * If the request was retransmitted, it returns the new connection on      * which the request was sent.      *       * @param connection   The active URL connection.      * @param message      The outgoing message.      * @param cachedStream The cached request.      * @return      * @throws IOException      */
specifier|private
name|HttpURLConnection
name|processRetransmit
parameter_list|(
name|HttpURLConnection
name|connection
parameter_list|,
name|Message
name|message
parameter_list|,
name|CacheAndWriteOutputStream
name|cachedStream
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|responseCode
init|=
name|connection
operator|.
name|getResponseCode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|message
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|message
operator|.
name|getExchange
argument_list|()
operator|!=
literal|null
operator|)
condition|)
block|{
name|message
operator|.
name|getExchange
argument_list|()
operator|.
name|put
argument_list|(
name|Message
operator|.
name|RESPONSE_CODE
argument_list|,
name|responseCode
argument_list|)
expr_stmt|;
block|}
comment|// Process Redirects first.
switch|switch
condition|(
name|responseCode
condition|)
block|{
case|case
name|HttpURLConnection
operator|.
name|HTTP_MOVED_PERM
case|:
case|case
name|HttpURLConnection
operator|.
name|HTTP_MOVED_TEMP
case|:
name|connection
operator|=
name|redirectRetransmit
argument_list|(
name|connection
argument_list|,
name|message
argument_list|,
name|cachedStream
argument_list|)
expr_stmt|;
break|break;
case|case
name|HttpURLConnection
operator|.
name|HTTP_UNAUTHORIZED
case|:
name|connection
operator|=
name|authorizationRetransmit
argument_list|(
name|connection
argument_list|,
name|message
argument_list|,
name|cachedStream
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|connection
return|;
block|}
comment|/**      * This method performs a redirection retransmit in response to      * a 302 or 305 response code.      *       * @param connection   The active URL connection      * @param message      The outbound message.      * @param cachedStream The cached request.      * @return This method returns the new HttpURLConnection if      *         redirected. If it cannot be redirected for some reason      *         the same connection is returned.      *               * @throws IOException      */
specifier|private
name|HttpURLConnection
name|redirectRetransmit
parameter_list|(
name|HttpURLConnection
name|connection
parameter_list|,
name|Message
name|message
parameter_list|,
name|CacheAndWriteOutputStream
name|cachedStream
parameter_list|)
throws|throws
name|IOException
block|{
comment|// If we are not redirecting by policy, then we don't.
if|if
condition|(
operator|!
name|getClient
argument_list|(
name|message
argument_list|)
operator|.
name|isAutoRedirect
argument_list|()
condition|)
block|{
return|return
name|connection
return|;
block|}
comment|// We keep track of the redirections for redirect loop protection.
name|Set
argument_list|<
name|String
argument_list|>
name|visitedURLs
init|=
name|getSetVisitedURLs
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|String
name|lastURL
init|=
name|connection
operator|.
name|getURL
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|visitedURLs
operator|.
name|add
argument_list|(
name|lastURL
argument_list|)
expr_stmt|;
name|String
name|newURL
init|=
name|extractLocation
argument_list|(
name|connection
operator|.
name|getHeaderFields
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|newURL
operator|!=
literal|null
condition|)
block|{
comment|// See if we are being redirected in a loop as best we can,
comment|// using string equality on URL.
if|if
condition|(
name|visitedURLs
operator|.
name|contains
argument_list|(
name|newURL
argument_list|)
condition|)
block|{
comment|// We are in a redirect loop; -- bail
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|INFO
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|INFO
argument_list|,
literal|"Redirect loop detected on Conduit \""
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"\" on '"
operator|+
name|newURL
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Redirect loop detected on Conduit \""
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"\" on '"
operator|+
name|newURL
operator|+
literal|"'"
argument_list|)
throw|;
block|}
comment|// We are going to redirect.
comment|// Remove any Server Authentication Information for the previous
comment|// URL.
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|headers
init|=
name|getSetProtocolHeaders
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|headers
operator|.
name|remove
argument_list|(
literal|"Authorization"
argument_list|)
expr_stmt|;
name|headers
operator|.
name|remove
argument_list|(
literal|"Proxy-Authorization"
argument_list|)
expr_stmt|;
name|URL
name|url
init|=
operator|new
name|URL
argument_list|(
name|newURL
argument_list|)
decl_stmt|;
comment|// If user configured this Conduit with preemptive authorization
comment|// it is meant to make it to the end. (Too bad that information
comment|// went to every URL along the way, but that's what the user
comment|// wants!
comment|// TODO: Make this issue a security release note.
name|setHeadersByAuthorizationPolicy
argument_list|(
name|message
argument_list|,
name|url
argument_list|,
name|headers
argument_list|)
expr_stmt|;
name|connection
operator|=
name|retransmit
argument_list|(
name|connection
argument_list|,
name|url
argument_list|,
name|message
argument_list|,
name|cachedStream
argument_list|)
expr_stmt|;
block|}
return|return
name|connection
return|;
block|}
comment|/**      * This function gets the Set of URLs on the message that is used to       * keep track of the URLs that were used in getting authorization       * information.      *      * @param message The message where the Set of URLs is stored.      * @return The modifiable set of URLs that were visited.      */
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|getSetAuthoriationURLs
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Set
argument_list|<
name|String
argument_list|>
name|authURLs
init|=
operator|(
name|Set
argument_list|<
name|String
argument_list|>
operator|)
name|message
operator|.
name|get
argument_list|(
name|KEY_AUTH_URLS
argument_list|)
decl_stmt|;
if|if
condition|(
name|authURLs
operator|==
literal|null
condition|)
block|{
name|authURLs
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|message
operator|.
name|put
argument_list|(
name|KEY_AUTH_URLS
argument_list|,
name|authURLs
argument_list|)
expr_stmt|;
block|}
return|return
name|authURLs
return|;
block|}
comment|/**      * This function get the set of URLs on the message that is used to keep      * track of the URLs that were visited in redirects.      *       * If it is not set on the message, an new empty set is stored.      * @param message The message where the Set is stored.      * @return The modifiable set of URLs that were visited.      */
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|getSetVisitedURLs
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Set
argument_list|<
name|String
argument_list|>
name|visitedURLs
init|=
operator|(
name|Set
argument_list|<
name|String
argument_list|>
operator|)
name|message
operator|.
name|get
argument_list|(
name|KEY_VISITED_URLS
argument_list|)
decl_stmt|;
if|if
condition|(
name|visitedURLs
operator|==
literal|null
condition|)
block|{
name|visitedURLs
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|message
operator|.
name|put
argument_list|(
name|KEY_VISITED_URLS
argument_list|,
name|visitedURLs
argument_list|)
expr_stmt|;
block|}
return|return
name|visitedURLs
return|;
block|}
comment|/**      * This method performs a retransmit for authorization information.      *       * @param connection The currently active connection.      * @param message The outbound message.      * @param cachedStream The cached request.      * @return A new connection if retransmitted. If not retransmitted      *         then this method returns the same connection.      * @throws IOException      */
specifier|private
name|HttpURLConnection
name|authorizationRetransmit
parameter_list|(
name|HttpURLConnection
name|connection
parameter_list|,
name|Message
name|message
parameter_list|,
name|CacheAndWriteOutputStream
name|cachedStream
parameter_list|)
throws|throws
name|IOException
block|{
comment|// If we don't have a dynamic supply of user pass, then
comment|// we don't retransmit. We just die with a Http 401 response.
if|if
condition|(
name|authSupplier
operator|==
literal|null
condition|)
block|{
name|String
name|auth
init|=
name|connection
operator|.
name|getHeaderField
argument_list|(
literal|"WWW-Authenticate"
argument_list|)
decl_stmt|;
if|if
condition|(
name|auth
operator|.
name|startsWith
argument_list|(
literal|"Digest "
argument_list|)
condition|)
block|{
name|authSupplier
operator|=
operator|new
name|DigestAuthSupplier
argument_list|()
expr_stmt|;
block|}
else|else
block|{
return|return
name|connection
return|;
block|}
block|}
name|URL
name|currentURL
init|=
name|connection
operator|.
name|getURL
argument_list|()
decl_stmt|;
name|String
name|realm
init|=
name|extractAuthorizationRealm
argument_list|(
name|connection
operator|.
name|getHeaderFields
argument_list|()
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|authURLs
init|=
name|getSetAuthoriationURLs
argument_list|(
name|message
argument_list|)
decl_stmt|;
comment|// If we have been here (URL& Realm) before for this particular message
comment|// retransmit, it means we have already supplied information
comment|// which must have been wrong, or we wouldn't be here again.
comment|// Otherwise, the server may be 401 looping us around the realms.
if|if
condition|(
name|authURLs
operator|.
name|contains
argument_list|(
name|currentURL
operator|.
name|toString
argument_list|()
operator|+
name|realm
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|INFO
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|INFO
argument_list|,
literal|"Authorization loop detected on Conduit \""
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"\" on URL \""
operator|+
literal|"\" with realm \""
operator|+
name|realm
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Authorization loop detected on Conduit \""
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"\" on URL \""
operator|+
literal|"\" with realm \""
operator|+
name|realm
operator|+
literal|"\""
argument_list|)
throw|;
block|}
name|String
name|up
init|=
name|authSupplier
operator|.
name|getAuthorizationForRealm
argument_list|(
name|this
argument_list|,
name|currentURL
argument_list|,
name|message
argument_list|,
name|realm
argument_list|,
name|connection
operator|.
name|getHeaderField
argument_list|(
literal|"WWW-Authenticate"
argument_list|)
argument_list|)
decl_stmt|;
comment|// No user pass combination. We give up.
if|if
condition|(
name|up
operator|==
literal|null
condition|)
block|{
return|return
name|connection
return|;
block|}
comment|// Register that we have been here before we go.
name|authURLs
operator|.
name|add
argument_list|(
name|currentURL
operator|.
name|toString
argument_list|()
operator|+
name|realm
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|headers
init|=
name|getSetProtocolHeaders
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|headers
operator|.
name|put
argument_list|(
literal|"Authorization"
argument_list|,
name|createMutableList
argument_list|(
name|up
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retransmit
argument_list|(
name|connection
argument_list|,
name|currentURL
argument_list|,
name|message
argument_list|,
name|cachedStream
argument_list|)
return|;
block|}
comment|/**      * This method retransmits the request.      *       * @param connection The currently active connection.      * @param newURL     The newURL to connection to.      * @param message    The outbound message.      * @param stream     The cached request.      * @return           This function returns a new connection if      *                   retransmitted, otherwise it returns the given      *                   connection.      *                         * @throws IOException      */
specifier|private
name|HttpURLConnection
name|retransmit
parameter_list|(
name|HttpURLConnection
name|connection
parameter_list|,
name|URL
name|newURL
parameter_list|,
name|Message
name|message
parameter_list|,
name|CacheAndWriteOutputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Disconnect the old, and in with the new.
name|connection
operator|.
name|disconnect
argument_list|()
expr_stmt|;
name|HTTPClientPolicy
name|cp
init|=
name|getClient
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|connection
operator|=
name|getConnectionFactory
argument_list|(
name|newURL
argument_list|)
operator|.
name|createConnection
argument_list|(
name|getProxy
argument_list|(
name|cp
argument_list|)
argument_list|,
name|newURL
argument_list|)
expr_stmt|;
name|connection
operator|.
name|setDoOutput
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// TODO: using Message context to deceided HTTP send properties
name|connection
operator|.
name|setConnectTimeout
argument_list|(
operator|(
name|int
operator|)
name|cp
operator|.
name|getConnectionTimeout
argument_list|()
argument_list|)
expr_stmt|;
name|connection
operator|.
name|setReadTimeout
argument_list|(
operator|(
name|int
operator|)
name|cp
operator|.
name|getReceiveTimeout
argument_list|()
argument_list|)
expr_stmt|;
name|connection
operator|.
name|setUseCaches
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|connection
operator|.
name|setInstanceFollowRedirects
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// If the HTTP_REQUEST_METHOD is not set, the default is "POST".
name|String
name|httpRequestMethod
init|=
operator|(
name|String
operator|)
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|HTTP_REQUEST_METHOD
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|httpRequestMethod
condition|)
block|{
name|connection
operator|.
name|setRequestMethod
argument_list|(
name|httpRequestMethod
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|connection
operator|.
name|setRequestMethod
argument_list|(
literal|"POST"
argument_list|)
expr_stmt|;
block|}
name|message
operator|.
name|put
argument_list|(
name|KEY_HTTP_CONNECTION
argument_list|,
name|connection
argument_list|)
expr_stmt|;
name|connection
operator|.
name|setFixedLengthStreamingMode
argument_list|(
name|stream
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Need to set the headers before the trust decision
comment|// because they are set before the connect().
name|setURLRequestHeaders
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|//
comment|// This point is where the trust decision is made because the
comment|// Sun implementation of URLConnection will not let us
comment|// set/addRequestProperty after a connect() call, and
comment|// makeTrustDecision needs to make a connect() call to
comment|// make sure the proper information is available.
comment|//
name|makeTrustDecision
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|// If this is a GET method we must not touch the output
comment|// stream as this automagically turns the request into a POST.
if|if
condition|(
name|connection
operator|.
name|getRequestMethod
argument_list|()
operator|.
name|equals
argument_list|(
literal|"GET"
argument_list|)
condition|)
block|{
return|return
name|connection
return|;
block|}
comment|// Trust is okay, write the cached request
name|OutputStream
name|out
init|=
name|connection
operator|.
name|getOutputStream
argument_list|()
decl_stmt|;
name|stream
operator|.
name|writeCacheTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
literal|"Conduit \""
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"\" Retransmit message to: "
operator|+
name|connection
operator|.
name|getURL
argument_list|()
operator|+
literal|": "
operator|+
operator|new
name|String
argument_list|(
name|stream
operator|.
name|getBytes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|connection
return|;
block|}
comment|/**      * This function extracts the authorization realm from the       * "WWW-Authenticate" Http response header.      *       * @param headers The Http Response Headers      * @return The realm, or null if it is non-existent.      */
specifier|private
name|String
name|extractAuthorizationRealm
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|headers
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|auth
init|=
name|headers
operator|.
name|get
argument_list|(
literal|"WWW-Authenticate"
argument_list|)
decl_stmt|;
if|if
condition|(
name|auth
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|a
range|:
name|auth
control|)
block|{
name|int
name|idx
init|=
name|a
operator|.
name|indexOf
argument_list|(
literal|"realm="
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|a
operator|=
name|a
operator|.
name|substring
argument_list|(
name|idx
operator|+
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'"'
condition|)
block|{
name|a
operator|=
name|a
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|a
operator|.
name|indexOf
argument_list|(
literal|'"'
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|.
name|contains
argument_list|(
literal|","
argument_list|)
condition|)
block|{
name|a
operator|=
name|a
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|a
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|a
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * This method extracts the value of the "Location" Http      * Response header.      *       * @param headers The Http response headers.      * @return The value of the "Location" header, null if non-existent.      */
specifier|private
name|String
name|extractLocation
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|headers
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|head
range|:
name|headers
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
literal|"Location"
operator|.
name|equalsIgnoreCase
argument_list|(
name|head
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|locs
init|=
name|head
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|locs
operator|!=
literal|null
operator|&&
name|locs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return
name|locs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * This procedure sets the "Authorization" header with the       * BasicAuth token, which is Base64 encoded.      *       * @param userid   The user's id, which cannot be null.      * @param password The password, it may be null.      *       * @param headers  The headers map that gets the "Authorization" header set.      */
specifier|private
name|void
name|setBasicAuthHeader
parameter_list|(
name|String
name|userid
parameter_list|,
name|String
name|password
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|headers
parameter_list|)
block|{
name|String
name|userpass
init|=
name|userid
decl_stmt|;
name|userpass
operator|+=
literal|":"
expr_stmt|;
if|if
condition|(
name|password
operator|!=
literal|null
condition|)
block|{
name|userpass
operator|+=
name|password
expr_stmt|;
block|}
name|String
name|token
init|=
name|Base64Utility
operator|.
name|encode
argument_list|(
name|userpass
operator|.
name|getBytes
argument_list|()
argument_list|)
decl_stmt|;
name|headers
operator|.
name|put
argument_list|(
literal|"Authorization"
argument_list|,
name|createMutableList
argument_list|(
literal|"Basic "
operator|+
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * This procedure sets the "ProxyAuthorization" header with the       * BasicAuth token, which is Base64 encoded.      *       * @param userid   The user's id, which cannot be null.      * @param password The password, it may be null.      *       * @param headers The headers map that gets the "Proxy-Authorization"       *                header set.      */
specifier|private
name|void
name|setProxyBasicAuthHeader
parameter_list|(
name|String
name|userid
parameter_list|,
name|String
name|password
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|headers
parameter_list|)
block|{
name|String
name|userpass
init|=
name|userid
decl_stmt|;
name|userpass
operator|+=
literal|":"
expr_stmt|;
if|if
condition|(
name|password
operator|!=
literal|null
condition|)
block|{
name|userpass
operator|+=
name|password
expr_stmt|;
block|}
name|String
name|token
init|=
name|Base64Utility
operator|.
name|encode
argument_list|(
name|userpass
operator|.
name|getBytes
argument_list|()
argument_list|)
decl_stmt|;
name|headers
operator|.
name|put
argument_list|(
literal|"Proxy-Authorization"
argument_list|,
name|createMutableList
argument_list|(
literal|"Basic "
operator|+
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Wrapper output stream responsible for flushing headers and handling      * the incoming HTTP-level response (not necessarily the MEP response).      */
specifier|protected
class|class
name|WrappedOutputStream
extends|extends
name|AbstractThresholdOutputStream
block|{
comment|/**          * This field contains the currently active connection.          */
specifier|protected
name|HttpURLConnection
name|connection
decl_stmt|;
comment|/**          * This boolean is true if the request must be cached.          */
specifier|protected
name|boolean
name|cachingForRetransmission
decl_stmt|;
comment|/**          * If we are going to be chunking, we won't flush till close which causes          * new chunks, small network packets, etc..          */
specifier|protected
specifier|final
name|boolean
name|chunking
decl_stmt|;
comment|/**          * This field contains the output stream with which we cache          * the request. It maybe null if we are not caching.          */
specifier|protected
name|CacheAndWriteOutputStream
name|cachedStream
decl_stmt|;
specifier|protected
name|Message
name|outMessage
decl_stmt|;
specifier|protected
name|WrappedOutputStream
parameter_list|(
name|Message
name|m
parameter_list|,
name|HttpURLConnection
name|c
parameter_list|,
name|boolean
name|possibleRetransmit
parameter_list|,
name|boolean
name|isChunking
parameter_list|,
name|int
name|chunkThreshold
parameter_list|)
block|{
name|super
argument_list|(
name|chunkThreshold
argument_list|)
expr_stmt|;
name|this
operator|.
name|outMessage
operator|=
name|m
expr_stmt|;
name|connection
operator|=
name|c
expr_stmt|;
name|cachingForRetransmission
operator|=
name|possibleRetransmit
expr_stmt|;
name|chunking
operator|=
name|isChunking
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|thresholdNotReached
parameter_list|()
block|{
if|if
condition|(
name|chunking
condition|)
block|{
name|connection
operator|.
name|setFixedLengthStreamingMode
argument_list|(
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|thresholdReached
parameter_list|()
block|{
if|if
condition|(
name|chunking
condition|)
block|{
name|connection
operator|.
name|setChunkedStreamingMode
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Perform any actions required on stream flush (freeze headers,          * reset output stream ... etc.)          */
annotation|@
name|Override
specifier|protected
name|void
name|onFirstWrite
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|handleHeadersTrustCaching
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getMessage
argument_list|()
operator|!=
literal|null
operator|&&
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"HTTPS hostname wrong:"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The https URL hostname does not match the "
operator|+
literal|"Common Name (CN) on the server certificate.  To disable this check "
operator|+
literal|"(NOT recommended for production) set the CXF client TLS configuration "
operator|+
literal|"property \"disableCNCheck\" to true."
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|}
specifier|protected
name|void
name|handleHeadersTrustCaching
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Need to set the headers before the trust decision
comment|// because they are set before the connect().
name|setURLRequestHeaders
argument_list|(
name|outMessage
argument_list|)
expr_stmt|;
comment|//
comment|// This point is where the trust decision is made because the
comment|// Sun implementation of URLConnection will not let us
comment|// set/addRequestProperty after a connect() call, and
comment|// makeTrustDecision needs to make a connect() call to
comment|// make sure the proper information is available.
comment|//
name|makeTrustDecision
argument_list|(
name|outMessage
argument_list|)
expr_stmt|;
comment|// Trust is okay, set up for writing the request.
comment|// If this is a GET method we must not touch the output
comment|// stream as this automatically turns the request into a POST.
comment|// Nor it should be done in case of DELETE/HEAD/OPTIONS
comment|// - strangely, empty PUTs work ok
if|if
condition|(
operator|!
literal|"POST"
operator|.
name|equals
argument_list|(
name|connection
operator|.
name|getRequestMethod
argument_list|()
argument_list|)
operator|&&
operator|!
literal|"PUT"
operator|.
name|equals
argument_list|(
name|connection
operator|.
name|getRequestMethod
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|outMessage
operator|.
name|get
argument_list|(
literal|"org.apache.cxf.post.empty"
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
comment|// If we need to cache for retransmission, store data in a
comment|// CacheAndWriteOutputStream. Otherwise write directly to the output stream.
if|if
condition|(
name|cachingForRetransmission
condition|)
block|{
name|cachedStream
operator|=
operator|new
name|CacheAndWriteOutputStream
argument_list|(
name|connection
operator|.
name|getOutputStream
argument_list|()
argument_list|)
expr_stmt|;
name|wrappedStream
operator|=
name|cachedStream
expr_stmt|;
block|}
else|else
block|{
name|wrappedStream
operator|=
name|connection
operator|.
name|getOutputStream
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|chunking
condition|)
block|{
name|super
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**          * Perform any actions required on stream closure (handle response etc.)          */
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|buffer
operator|!=
literal|null
operator|&&
name|buffer
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|thresholdNotReached
argument_list|()
expr_stmt|;
name|LoadingByteArrayOutputStream
name|tmp
init|=
name|buffer
decl_stmt|;
name|buffer
operator|=
literal|null
expr_stmt|;
name|super
operator|.
name|write
argument_list|(
name|tmp
operator|.
name|getRawBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|tmp
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|written
condition|)
block|{
name|handleHeadersTrustCaching
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cachingForRetransmission
condition|)
block|{
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|cachedStream
operator|.
name|getOut
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
name|cachedStream
operator|.
name|closeFlowthroughStream
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|handleResponse
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|String
name|url
init|=
name|connection
operator|.
name|getURL
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|origMessage
init|=
name|e
operator|.
name|getMessage
argument_list|()
decl_stmt|;
if|if
condition|(
name|origMessage
operator|!=
literal|null
operator|&&
name|origMessage
operator|.
name|contains
argument_list|(
name|url
argument_list|)
condition|)
block|{
throw|throw
name|e
throw|;
block|}
throw|throw
name|mapException
argument_list|(
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" invoking "
operator|+
name|connection
operator|.
name|getURL
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|,
name|IOException
operator|.
name|class
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
name|mapException
argument_list|(
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" invoking "
operator|+
name|connection
operator|.
name|getURL
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|,
name|RuntimeException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|cachingForRetransmission
operator|&&
name|cachedStream
operator|!=
literal|null
condition|)
block|{
name|cachedStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Exception
parameter_list|>
name|T
name|mapException
parameter_list|(
name|String
name|msg
parameter_list|,
name|T
name|ex
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|cls
parameter_list|)
block|{
name|T
name|ex2
init|=
name|ex
decl_stmt|;
try|try
block|{
name|ex2
operator|=
name|cls
operator|.
name|cast
argument_list|(
name|ex
operator|.
name|getClass
argument_list|()
operator|.
name|getConstructor
argument_list|(
name|String
operator|.
name|class
argument_list|)
operator|.
name|newInstance
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|ex2
operator|.
name|initCause
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|ex2
operator|=
name|ex
expr_stmt|;
block|}
return|return
name|ex2
return|;
block|}
comment|/**          * This procedure handles all retransmits, if any.          *          * @throws IOException          */
specifier|protected
name|void
name|handleRetransmits
parameter_list|()
throws|throws
name|IOException
block|{
comment|// If we have a cachedStream, we are caching the request.
if|if
condition|(
name|cachedStream
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
literal|"Conduit \""
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"\" Transmit cached message to: "
operator|+
name|connection
operator|.
name|getURL
argument_list|()
operator|+
literal|": "
operator|+
operator|new
name|String
argument_list|(
name|cachedStream
operator|.
name|getBytes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|HttpURLConnection
name|oldcon
init|=
name|connection
decl_stmt|;
name|HTTPClientPolicy
name|policy
init|=
name|getClient
argument_list|(
name|outMessage
argument_list|)
decl_stmt|;
comment|// Default MaxRetransmits is -1 which means unlimited.
name|int
name|maxRetransmits
init|=
operator|(
name|policy
operator|==
literal|null
operator|)
condition|?
operator|-
literal|1
else|:
name|policy
operator|.
name|getMaxRetransmits
argument_list|()
decl_stmt|;
comment|// MaxRetransmits of zero means zero.
if|if
condition|(
name|maxRetransmits
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|int
name|nretransmits
init|=
literal|0
decl_stmt|;
name|connection
operator|=
name|processRetransmit
argument_list|(
name|connection
argument_list|,
name|outMessage
argument_list|,
name|cachedStream
argument_list|)
expr_stmt|;
while|while
condition|(
name|connection
operator|!=
name|oldcon
condition|)
block|{
name|nretransmits
operator|++
expr_stmt|;
name|oldcon
operator|=
name|connection
expr_stmt|;
comment|// A negative max means unlimited.
if|if
condition|(
name|maxRetransmits
operator|<
literal|0
operator|||
name|nretransmits
operator|<
name|maxRetransmits
condition|)
block|{
name|connection
operator|=
name|processRetransmit
argument_list|(
name|connection
argument_list|,
name|outMessage
argument_list|,
name|cachedStream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**          * This procedure is called on the close of the output stream so          * we are ready to handle the response from the connection.           * We may retransmit until we finally get a response.          *           * @throws IOException          */
specifier|protected
name|void
name|handleResponse
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Process retransmits until we fall out.
name|handleRetransmits
argument_list|()
expr_stmt|;
if|if
condition|(
name|outMessage
operator|==
literal|null
operator|||
name|outMessage
operator|.
name|getExchange
argument_list|()
operator|==
literal|null
operator|||
name|outMessage
operator|.
name|getExchange
argument_list|()
operator|.
name|isSynchronous
argument_list|()
condition|)
block|{
name|handleResponseInternal
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Runnable
name|runnable
init|=
operator|new
name|Runnable
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|handleResponseInternal
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Message
name|inMessage
init|=
operator|new
name|MessageImpl
argument_list|()
decl_stmt|;
name|inMessage
operator|.
name|setExchange
argument_list|(
name|outMessage
operator|.
name|getExchange
argument_list|()
argument_list|)
expr_stmt|;
name|inMessage
operator|.
name|setContent
argument_list|(
name|Exception
operator|.
name|class
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|incomingObserver
operator|.
name|onMessage
argument_list|(
name|inMessage
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|WorkQueueManager
name|mgr
init|=
name|outMessage
operator|.
name|getExchange
argument_list|()
operator|.
name|get
argument_list|(
name|Bus
operator|.
name|class
argument_list|)
operator|.
name|getExtension
argument_list|(
name|WorkQueueManager
operator|.
name|class
argument_list|)
decl_stmt|;
name|AutomaticWorkQueue
name|queue
init|=
name|mgr
operator|.
name|getNamedWorkQueue
argument_list|(
literal|"http-conduit"
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
name|queue
operator|=
name|mgr
operator|.
name|getAutomaticWorkQueue
argument_list|()
expr_stmt|;
block|}
name|queue
operator|.
name|execute
argument_list|(
name|runnable
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|handleResponseInternal
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|responseCode
init|=
name|connection
operator|.
name|getResponseCode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|outMessage
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|outMessage
operator|.
name|getExchange
argument_list|()
operator|!=
literal|null
operator|)
condition|)
block|{
name|outMessage
operator|.
name|getExchange
argument_list|()
operator|.
name|put
argument_list|(
name|Message
operator|.
name|RESPONSE_CODE
argument_list|,
name|responseCode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
literal|"Response Code: "
operator|+
name|responseCode
operator|+
literal|" Conduit: "
operator|+
name|getConduitName
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|fine
argument_list|(
literal|"Content length: "
operator|+
name|connection
operator|.
name|getContentLength
argument_list|()
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|headerFields
init|=
name|connection
operator|.
name|getHeaderFields
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|headerFields
condition|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"Header fields: "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|h
range|:
name|headerFields
operator|.
name|keySet
argument_list|()
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|headerFields
operator|.
name|get
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|fine
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|responseCode
operator|==
name|HttpURLConnection
operator|.
name|HTTP_NOT_FOUND
operator|&&
operator|!
name|MessageUtils
operator|.
name|isTrue
argument_list|(
name|outMessage
operator|.
name|getContextualProperty
argument_list|(
literal|"org.apache.cxf.http.no_io_exceptions"
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"HTTP response '"
operator|+
name|responseCode
operator|+
literal|": "
operator|+
name|connection
operator|.
name|getResponseMessage
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|Exchange
name|exchange
init|=
name|outMessage
operator|.
name|getExchange
argument_list|()
decl_stmt|;
name|InputStream
name|in
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isOneway
argument_list|(
name|exchange
argument_list|)
operator|||
name|isDecoupled
argument_list|()
condition|)
block|{
name|in
operator|=
name|getPartialResponse
argument_list|(
name|connection
argument_list|,
name|responseCode
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
comment|// oneway operation or decoupled MEP without
comment|// partial response
name|connection
operator|.
name|getInputStream
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|//not going to be resending or anything, clear out the stuff in the out message
comment|//to free memory
name|outMessage
operator|.
name|removeContent
argument_list|(
name|OutputStream
operator|.
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|cachingForRetransmission
condition|)
block|{
name|cachedStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|cachedStream
operator|=
literal|null
expr_stmt|;
block|}
name|Message
name|inMessage
init|=
operator|new
name|MessageImpl
argument_list|()
decl_stmt|;
name|inMessage
operator|.
name|setExchange
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|headers
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|connection
operator|.
name|getHeaderFields
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
name|headers
operator|.
name|put
argument_list|(
name|HttpHeaderHelper
operator|.
name|getHeaderKey
argument_list|(
name|key
argument_list|)
argument_list|,
name|connection
operator|.
name|getHeaderFields
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|inMessage
operator|.
name|put
argument_list|(
name|Message
operator|.
name|PROTOCOL_HEADERS
argument_list|,
name|headers
argument_list|)
expr_stmt|;
name|inMessage
operator|.
name|put
argument_list|(
name|Message
operator|.
name|RESPONSE_CODE
argument_list|,
name|responseCode
argument_list|)
expr_stmt|;
name|String
name|ct
init|=
name|connection
operator|.
name|getContentType
argument_list|()
decl_stmt|;
name|inMessage
operator|.
name|put
argument_list|(
name|Message
operator|.
name|CONTENT_TYPE
argument_list|,
name|ct
argument_list|)
expr_stmt|;
name|String
name|charset
init|=
name|HttpHeaderHelper
operator|.
name|findCharset
argument_list|(
name|ct
argument_list|)
decl_stmt|;
name|String
name|normalizedEncoding
init|=
name|HttpHeaderHelper
operator|.
name|mapCharset
argument_list|(
name|charset
argument_list|)
decl_stmt|;
if|if
condition|(
name|normalizedEncoding
operator|==
literal|null
condition|)
block|{
name|String
name|m
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|common
operator|.
name|i18n
operator|.
name|Message
argument_list|(
literal|"INVALID_ENCODING_MSG"
argument_list|,
name|LOG
argument_list|,
name|charset
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
name|m
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|m
argument_list|)
throw|;
block|}
name|inMessage
operator|.
name|put
argument_list|(
name|Message
operator|.
name|ENCODING
argument_list|,
name|normalizedEncoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|maintainSession
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|cookies
init|=
name|connection
operator|.
name|getHeaderFields
argument_list|()
operator|.
name|get
argument_list|(
literal|"Set-Cookie"
argument_list|)
decl_stmt|;
name|Cookie
operator|.
name|handleSetCookie
argument_list|(
name|sessionCookies
argument_list|,
name|cookies
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|responseCode
operator|!=
name|HttpURLConnection
operator|.
name|HTTP_NOT_FOUND
condition|)
block|{
name|in
operator|=
name|in
operator|==
literal|null
condition|?
name|connection
operator|.
name|getErrorStream
argument_list|()
operator|==
literal|null
condition|?
name|connection
operator|.
name|getInputStream
argument_list|()
else|:
name|connection
operator|.
name|getErrorStream
argument_list|()
else|:
name|in
expr_stmt|;
block|}
comment|// if (in == null) : it's perfectly ok for non-soap http services
comment|// have no response body : those interceptors which do need it will check anyway
name|inMessage
operator|.
name|setContent
argument_list|(
name|InputStream
operator|.
name|class
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|incomingObserver
operator|.
name|onMessage
argument_list|(
name|inMessage
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Used to set appropriate message properties, exchange etc.      * as required for an incoming decoupled response (as opposed      * what's normally set by the Destination for an incoming      * request).      */
specifier|protected
class|class
name|InterposedMessageObserver
implements|implements
name|MessageObserver
block|{
comment|/**          * Called for an incoming message.          *           * @param inMessage          */
specifier|public
name|void
name|onMessage
parameter_list|(
name|Message
name|inMessage
parameter_list|)
block|{
comment|// disposable exchange, swapped with real Exchange on correlation
name|inMessage
operator|.
name|setExchange
argument_list|(
operator|new
name|ExchangeImpl
argument_list|()
argument_list|)
expr_stmt|;
name|inMessage
operator|.
name|getExchange
argument_list|()
operator|.
name|put
argument_list|(
name|Bus
operator|.
name|class
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|inMessage
operator|.
name|put
argument_list|(
name|DECOUPLED_CHANNEL_MESSAGE
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
comment|// REVISIT: how to get response headers?
comment|//inMessage.put(Message.PROTOCOL_HEADERS, req.getXXX());
name|getSetProtocolHeaders
argument_list|(
name|inMessage
argument_list|)
expr_stmt|;
name|inMessage
operator|.
name|put
argument_list|(
name|Message
operator|.
name|RESPONSE_CODE
argument_list|,
name|HttpURLConnection
operator|.
name|HTTP_OK
argument_list|)
expr_stmt|;
comment|// remove server-specific properties
name|inMessage
operator|.
name|remove
argument_list|(
name|AbstractHTTPDestination
operator|.
name|HTTP_REQUEST
argument_list|)
expr_stmt|;
name|inMessage
operator|.
name|remove
argument_list|(
name|AbstractHTTPDestination
operator|.
name|HTTP_RESPONSE
argument_list|)
expr_stmt|;
name|inMessage
operator|.
name|remove
argument_list|(
name|Message
operator|.
name|ASYNC_POST_RESPONSE_DISPATCH
argument_list|)
expr_stmt|;
comment|//cache this inputstream since it's defer to use in case of async
try|try
block|{
name|InputStream
name|in
init|=
name|inMessage
operator|.
name|getContent
argument_list|(
name|InputStream
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
name|CachedOutputStream
name|cos
init|=
operator|new
name|CachedOutputStream
argument_list|()
decl_stmt|;
name|IOUtils
operator|.
name|copy
argument_list|(
name|in
argument_list|,
name|cos
argument_list|)
expr_stmt|;
name|inMessage
operator|.
name|setContent
argument_list|(
name|InputStream
operator|.
name|class
argument_list|,
name|cos
operator|.
name|getInputStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|incomingObserver
operator|.
name|onMessage
argument_list|(
name|inMessage
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|assertMessage
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
name|PolicyUtils
operator|.
name|assertClientPolicy
argument_list|(
name|message
argument_list|,
name|clientSidePolicy
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|canAssert
parameter_list|(
name|QName
name|type
parameter_list|)
block|{
return|return
name|PolicyUtils
operator|.
name|HTTPCLIENTPOLICY_ASSERTION_QNAME
operator|.
name|equals
argument_list|(
name|type
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
specifier|public
name|void
name|setBasicAuthSupplier
parameter_list|(
name|HttpBasicAuthSupplier
name|basicAuthSupplier
parameter_list|)
block|{
name|setAuthSupplier
argument_list|(
name|basicAuthSupplier
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

