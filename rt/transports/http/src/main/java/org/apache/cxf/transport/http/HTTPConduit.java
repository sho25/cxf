begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements. See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|http
package|;
end_package

begin_import
import|import
name|java
operator|.
name|beans
operator|.
name|PropertyChangeEvent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|beans
operator|.
name|PropertyChangeListener
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|HttpRetryException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|HttpURLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Proxy
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|namespace
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|Bus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|common
operator|.
name|injection
operator|.
name|NoJSR250Annotations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|common
operator|.
name|logging
operator|.
name|LogUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|common
operator|.
name|util
operator|.
name|SystemPropertyAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|configuration
operator|.
name|Configurable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|configuration
operator|.
name|jsse
operator|.
name|TLSClientParameters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|configuration
operator|.
name|security
operator|.
name|AuthorizationPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|configuration
operator|.
name|security
operator|.
name|CertificateConstraintsType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|configuration
operator|.
name|security
operator|.
name|ProxyAuthorizationPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|endpoint
operator|.
name|ClientCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|endpoint
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|helpers
operator|.
name|HttpHeaderHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|helpers
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|helpers
operator|.
name|LoadingByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|io
operator|.
name|AbstractThresholdOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|io
operator|.
name|CacheAndWriteOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|io
operator|.
name|CachedOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|ExchangeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|MessageContentsList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|MessageImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|MessageUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|phase
operator|.
name|PhaseInterceptorChain
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|service
operator|.
name|model
operator|.
name|EndpointInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|AbstractConduit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|Assertor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|MessageObserver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|http
operator|.
name|auth
operator|.
name|DefaultBasicAuthSupplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|http
operator|.
name|auth
operator|.
name|DigestAuthSupplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|http
operator|.
name|auth
operator|.
name|HttpAuthHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|http
operator|.
name|auth
operator|.
name|HttpAuthSupplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|http
operator|.
name|auth
operator|.
name|SpnegoAuthSupplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|http
operator|.
name|policy
operator|.
name|PolicyUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|https
operator|.
name|CertConstraints
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|https
operator|.
name|CertConstraintsInterceptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|https
operator|.
name|CertConstraintsJaxBUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|https
operator|.
name|HttpsURLConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transports
operator|.
name|http
operator|.
name|configuration
operator|.
name|HTTPClientPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|workqueue
operator|.
name|AutomaticWorkQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|workqueue
operator|.
name|WorkQueueManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|addressing
operator|.
name|EndpointReferenceType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|ws
operator|.
name|policy
operator|.
name|PolicyEngine
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|message
operator|.
name|Message
operator|.
name|DECOUPLED_CHANNEL_MESSAGE
import|;
end_import

begin_comment
comment|/*  * HTTP Conduit implementation.  *<p>  * This implementation is a based on the java.net.URLConnection interface and  * dependent upon installed implementations of that URLConnection,   * HttpURLConnection, and HttpsURLConnection. Currently, this implementation  * has been known to work with the Sun JDK 1.5 default implementations. The  * HttpsURLConnection is part of Sun's implementation of the JSSE.   * Presently, the source code for the Sun JSSE implementation is unavailable  * and therefore we may only lay a guess of whether its HttpsURLConnection  * implementation correctly works as far as security is concerned.  *<p>  * The Trust Decision. If a MessageTrustDecider is configured/set for the   * Conduit, it is called upon the first flush of the headers in the   * WrappedOutputStream. This reason for this approach is two-fold.   * Theoretically, in order to get connection information out of the   * URLConnection, it must be "connected". We assume that its implementation will  * only follow through up to the point at which it will be ready to send  * one byte of data down to the endpoint, but through proxies, and the   * commpletion of a TLS handshake in the case of HttpsURLConnection.   * However, if we force the connect() call right away, the default  * implementations will not allow any calls to add/setRequestProperty,  * throwing an exception that the URLConnection is already connected.   *<p>  * We need to keep the semantic that later CXF interceptors may add to the   * PROTOCOL_HEADERS in the Message. This architectual decision forces us to   * delay the connection until after that point, then pulling the trust decision.  *<p>  * The security caveat is that we don't really know when the connection is   * really established. The call to "connect" is stated to force the   * "connection," but it is a no-op if the connection was already established.   * It is entirely possible that an implementation of an URLConnection may   * indeed connect at will and start sending the headers down the connection   * during calls to add/setRequestProperty!  *<p>  * We know that the JDK 1.5 sun.com.net.www.HttpURLConnection does not send  * this information before the "connect" call, because we can look at the  * source code. However, we can only assume, not verify, that the JSSE 1.5   * HttpsURLConnection does the same, in that it is probable that the   * HttpsURLConnection shares the HttpURLConnection implementation.  *<p>  * Due to these implementations following redirects without trust checks, we  * force the URLConnection implementations not to follow redirects. If   * client side policy dictates that we follow redirects, trust decisions are  * placed before each retransmit. On a redirect, any authorization information  * dynamically acquired by a BasicAuth UserPass supplier is removed before  * being retransmitted, as it may no longer be applicable to the new url to  * which the connection is redirected.  */
end_comment

begin_comment
comment|/**  * This Conduit handles the "http" and "https" transport protocols. An  * instance is governed by policies either explicitly set or by   * configuration.  */
end_comment

begin_class
annotation|@
name|NoJSR250Annotations
specifier|public
class|class
name|HTTPConduit
extends|extends
name|AbstractConduit
implements|implements
name|Configurable
implements|,
name|Assertor
implements|,
name|PropertyChangeListener
block|{
comment|/**      *  This constant is the Message(Map) key for the HttpURLConnection that      *  is used to get the response.      */
specifier|public
specifier|static
specifier|final
name|String
name|KEY_HTTP_CONNECTION
init|=
literal|"http.connection"
decl_stmt|;
comment|/**      * This constant is the Message(Map) key for a list of visited URLs that      * is used in redirect loop protection.      */
specifier|private
specifier|static
specifier|final
name|String
name|KEY_VISITED_URLS
init|=
literal|"VisitedURLs"
decl_stmt|;
comment|/**      * This constant is the Message(Map) key for a list of URLs that      * is used in authorization loop protection.      */
specifier|private
specifier|static
specifier|final
name|String
name|KEY_AUTH_URLS
init|=
literal|"AuthURLs"
decl_stmt|;
comment|/**      * The Logger for this class.      */
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LogUtils
operator|.
name|getL7dLogger
argument_list|(
name|HTTPConduit
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * This constant holds the suffix ".http-conduit" that is appended to the       * Endpoint Qname to give the configuration name of this conduit.      */
specifier|private
specifier|static
specifier|final
name|String
name|SC_HTTP_CONDUIT_SUFFIX
init|=
literal|".http-conduit"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|HTTP_POST_METHOD
init|=
literal|"POST"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|HTTP_PUT_METHOD
init|=
literal|"PUT"
decl_stmt|;
comment|/**      * This field holds the connection factory, which primarily is used to       * factor out SSL specific code from this implementation.      *<p>      * This field is "protected" to facilitate some contrived UnitTesting so      * that an extended class may alter its value with an EasyMock URLConnection      * Factory.       */
specifier|protected
name|HttpsURLConnectionFactory
name|connectionFactory
decl_stmt|;
comment|/**      *  This field holds a reference to the CXF bus associated this conduit.      */
specifier|private
specifier|final
name|Bus
name|bus
decl_stmt|;
comment|/**      * This field is used for two reasons. First it provides the base name for      * the conduit for Spring configuration. The other is to hold default       * address information, should it not be supplied in the Message Map, by the       * Message.ENDPOINT_ADDRESS property.      */
specifier|private
specifier|final
name|EndpointInfo
name|endpointInfo
decl_stmt|;
comment|/**      * This field holds the "default" URL for this particular conduit, which      * is created on demand.      */
specifier|private
name|URL
name|defaultEndpointURL
decl_stmt|;
specifier|private
name|String
name|defaultEndpointURLString
decl_stmt|;
specifier|private
name|boolean
name|fromEndpointReferenceType
decl_stmt|;
specifier|private
name|ProxyFactory
name|proxyFactory
decl_stmt|;
comment|// Configurable values
comment|/**      * This field holds the QoS configuration settings for this conduit.      * This field is injected via spring configuration based on the conduit      * name.      */
specifier|private
name|HTTPClientPolicy
name|clientSidePolicy
decl_stmt|;
comment|/**      * This field holds the password authorization configuration.      * This field is injected via spring configuration based on the conduit       * name.     */
specifier|private
name|AuthorizationPolicy
name|authorizationPolicy
decl_stmt|;
comment|/**      * This field holds the password authorization configuration for the       * configured proxy. This field is injected via spring configuration based       * on the conduit name.      */
specifier|private
name|ProxyAuthorizationPolicy
name|proxyAuthorizationPolicy
decl_stmt|;
comment|/**      * This field holds the configuration TLS configuration which      * is programmatically configured.       */
specifier|private
name|TLSClientParameters
name|tlsClientParameters
decl_stmt|;
comment|/**      * This field contains the MessageTrustDecider.      */
specifier|private
name|MessageTrustDecider
name|trustDecider
decl_stmt|;
comment|/**      * Implements the authentication handling when talking to a server. If it is not set      * it will be created from the authorizationPolicy.authType      */
specifier|private
name|HttpAuthSupplier
name|authSupplier
decl_stmt|;
comment|/**      * Implements the proxy authentication handling. If it is not set      * it will be created from the proxyAuthorizationPolicy.authType      */
specifier|private
name|HttpAuthSupplier
name|proxyAuthSupplier
decl_stmt|;
specifier|private
name|Cookies
name|cookies
decl_stmt|;
specifier|private
name|CertConstraints
name|certConstraints
decl_stmt|;
comment|/**      * Constructor      *       * @param b the associated Bus      * @param ei the endpoint info of the initiator      * @throws IOException      */
specifier|public
name|HTTPConduit
parameter_list|(
name|Bus
name|b
parameter_list|,
name|EndpointInfo
name|ei
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|b
argument_list|,
name|ei
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor      *       * @param b the associated Bus.      * @param endpoint the endpoint info of the initiator.      * @param t the endpoint reference of the target.      * @throws IOException      */
specifier|public
name|HTTPConduit
parameter_list|(
name|Bus
name|b
parameter_list|,
name|EndpointInfo
name|ei
parameter_list|,
name|EndpointReferenceType
name|t
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|getTargetReference
argument_list|(
name|ei
argument_list|,
name|t
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|bus
operator|=
name|b
expr_stmt|;
name|endpointInfo
operator|=
name|ei
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|fromEndpointReferenceType
operator|=
literal|true
expr_stmt|;
block|}
name|proxyFactory
operator|=
operator|new
name|ProxyFactory
argument_list|()
expr_stmt|;
name|connectionFactory
operator|=
operator|new
name|HttpsURLConnectionFactory
argument_list|()
expr_stmt|;
name|cookies
operator|=
operator|new
name|Cookies
argument_list|()
expr_stmt|;
comment|// wsdl extensors are superseded by policies which in
comment|// turn are superseded by injection
name|PolicyEngine
name|pe
init|=
name|bus
operator|.
name|getExtension
argument_list|(
name|PolicyEngine
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|pe
operator|&&
name|pe
operator|.
name|isEnabled
argument_list|()
operator|&&
name|endpointInfo
operator|.
name|getService
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|clientSidePolicy
operator|=
name|PolicyUtils
operator|.
name|getClient
argument_list|(
name|pe
argument_list|,
name|endpointInfo
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|CXFAuthenticator
operator|.
name|addAuthenticator
argument_list|()
expr_stmt|;
block|}
comment|/**      * This method returns the registered Logger for this conduit.      */
specifier|protected
name|Logger
name|getLogger
parameter_list|()
block|{
return|return
name|LOG
return|;
block|}
comment|/**      * This method returns the name of the conduit, which is based on the      * endpoint name plus the SC_HTTP_CONDUIT_SUFFIX.      * @return      */
specifier|public
specifier|final
name|String
name|getConduitName
parameter_list|()
block|{
return|return
name|endpointInfo
operator|.
name|getName
argument_list|()
operator|+
name|SC_HTTP_CONDUIT_SUFFIX
return|;
block|}
specifier|private
specifier|static
name|void
name|configureConduitFromEndpointInfo
parameter_list|(
name|HTTPConduit
name|conduit
parameter_list|,
name|EndpointInfo
name|endpointInfo
parameter_list|)
block|{
if|if
condition|(
name|conduit
operator|.
name|getClient
argument_list|()
operator|==
literal|null
condition|)
block|{
name|conduit
operator|.
name|setClient
argument_list|(
name|endpointInfo
operator|.
name|getTraversedExtensor
argument_list|(
operator|new
name|HTTPClientPolicy
argument_list|()
argument_list|,
name|HTTPClientPolicy
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conduit
operator|.
name|getAuthorization
argument_list|()
operator|==
literal|null
condition|)
block|{
name|conduit
operator|.
name|setAuthorization
argument_list|(
name|endpointInfo
operator|.
name|getTraversedExtensor
argument_list|(
operator|new
name|AuthorizationPolicy
argument_list|()
argument_list|,
name|AuthorizationPolicy
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conduit
operator|.
name|getProxyAuthorization
argument_list|()
operator|==
literal|null
condition|)
block|{
name|conduit
operator|.
name|setProxyAuthorization
argument_list|(
name|endpointInfo
operator|.
name|getTraversedExtensor
argument_list|(
operator|new
name|ProxyAuthorizationPolicy
argument_list|()
argument_list|,
name|ProxyAuthorizationPolicy
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conduit
operator|.
name|getTlsClientParameters
argument_list|()
operator|==
literal|null
condition|)
block|{
name|conduit
operator|.
name|setTlsClientParameters
argument_list|(
name|endpointInfo
operator|.
name|getTraversedExtensor
argument_list|(
literal|null
argument_list|,
name|TLSClientParameters
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conduit
operator|.
name|getTrustDecider
argument_list|()
operator|==
literal|null
condition|)
block|{
name|conduit
operator|.
name|setTrustDecider
argument_list|(
name|endpointInfo
operator|.
name|getTraversedExtensor
argument_list|(
literal|null
argument_list|,
name|MessageTrustDecider
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conduit
operator|.
name|getAuthSupplier
argument_list|()
operator|==
literal|null
condition|)
block|{
name|conduit
operator|.
name|setAuthSupplier
argument_list|(
name|endpointInfo
operator|.
name|getTraversedExtensor
argument_list|(
literal|null
argument_list|,
name|HttpAuthSupplier
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|logConfig
parameter_list|()
block|{
if|if
condition|(
operator|!
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|trustDecider
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"No Trust Decider configured for Conduit '"
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Message Trust Decider of class '"
operator|+
name|trustDecider
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' with logical name of '"
operator|+
name|trustDecider
operator|.
name|getLogicalName
argument_list|()
operator|+
literal|"' has been configured for Conduit '"
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|authSupplier
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"No Auth Supplier configured for Conduit '"
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"HttpAuthSupplier of class '"
operator|+
name|authSupplier
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' has been configured for Conduit '"
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|tlsClientParameters
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Conduit '"
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"' has been configured for TLS "
operator|+
literal|"keyManagers "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|tlsClientParameters
operator|.
name|getKeyManagers
argument_list|()
argument_list|)
operator|+
literal|"trustManagers "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|tlsClientParameters
operator|.
name|getTrustManagers
argument_list|()
argument_list|)
operator|+
literal|"secureRandom "
operator|+
name|tlsClientParameters
operator|.
name|getSecureRandom
argument_list|()
operator|+
literal|"Disable Common Name (CN) Check: "
operator|+
name|tlsClientParameters
operator|.
name|isDisableCNCheck
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Conduit '"
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"' has been configured for plain http."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This call gets called by the HTTPTransportFactory after it      * causes an injection of the Spring configuration properties      * of this Conduit.      */
specifier|protected
name|void
name|finalizeConfig
parameter_list|()
block|{
comment|// See if not set by configuration, if there are defaults
comment|// in order from the Endpoint, Service, or Bus.
name|configureConduitFromEndpointInfo
argument_list|(
name|this
argument_list|,
name|endpointInfo
argument_list|)
expr_stmt|;
name|logConfig
argument_list|()
expr_stmt|;
if|if
condition|(
name|getClient
argument_list|()
operator|.
name|getDecoupledEndpoint
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|endpointInfo
operator|.
name|setProperty
argument_list|(
literal|"org.apache.cxf.ws.addressing.replyto"
argument_list|,
name|getClient
argument_list|()
operator|.
name|getDecoupledEndpoint
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clientSidePolicy
operator|!=
literal|null
condition|)
block|{
name|clientSidePolicy
operator|.
name|addPropertyChangeListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Allow access to the cookies that the conduit is maintaining      * @return the sessionCookies map      */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Cookie
argument_list|>
name|getCookies
parameter_list|()
block|{
return|return
name|cookies
operator|.
name|getSessionCookies
argument_list|()
return|;
block|}
specifier|private
name|HttpURLConnection
name|createConnection
parameter_list|(
name|Message
name|message
parameter_list|,
name|URL
name|url
parameter_list|)
throws|throws
name|IOException
block|{
name|HTTPClientPolicy
name|csPolicy
init|=
name|getClient
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|Proxy
name|proxy
init|=
name|proxyFactory
operator|.
name|createProxy
argument_list|(
name|csPolicy
argument_list|,
name|url
argument_list|)
decl_stmt|;
return|return
name|connectionFactory
operator|.
name|createConnection
argument_list|(
name|tlsClientParameters
argument_list|,
name|proxy
argument_list|,
name|url
argument_list|)
return|;
block|}
comment|/**      * Prepare to send an outbound HTTP message over this http conduit to a       * particular endpoint.      *<P>      * If the Message.PATH_INFO property is set it gets appended      * to the Conduit's endpoint URL. If the Message.QUERY_STRING      * property is set, it gets appended to the resultant URL following      * a "?".      *<P>      * If the Message.HTTP_REQUEST_METHOD property is NOT set, the      * Http request method defaults to "POST".      *<P>      * If the Message.PROTOCOL_HEADERS is not set on the message, it is      * initialized to an empty map.      *<P>      * This call creates the OutputStream for the content of the message.      * It also assigns the created Http(s)URLConnection to the Message      * Map.      *       * @param message The message to be sent.      */
specifier|public
name|void
name|prepare
parameter_list|(
name|Message
name|message
parameter_list|)
throws|throws
name|IOException
block|{
comment|// This call can possibly change the conduit endpoint address and
comment|// protocol from the default set in EndpointInfo that is associated
comment|// with the Conduit.
name|URL
name|currentURL
init|=
name|setupURL
argument_list|(
name|message
argument_list|)
decl_stmt|;
comment|// The need to cache the request is off by default
name|boolean
name|needToCacheRequest
init|=
literal|false
decl_stmt|;
name|HTTPClientPolicy
name|csPolicy
init|=
name|getClient
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|HttpURLConnection
name|connection
init|=
name|createConnection
argument_list|(
name|message
argument_list|,
name|currentURL
argument_list|)
decl_stmt|;
name|connection
operator|.
name|setDoOutput
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|int
name|ctimeout
init|=
name|determineConnectionTimeout
argument_list|(
name|message
argument_list|,
name|csPolicy
argument_list|)
decl_stmt|;
name|connection
operator|.
name|setConnectTimeout
argument_list|(
name|ctimeout
argument_list|)
expr_stmt|;
name|int
name|rtimeout
init|=
name|determineReceiveTimeout
argument_list|(
name|message
argument_list|,
name|csPolicy
argument_list|)
decl_stmt|;
name|connection
operator|.
name|setReadTimeout
argument_list|(
name|rtimeout
argument_list|)
expr_stmt|;
name|connection
operator|.
name|setUseCaches
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// We implement redirects in this conduit. We do not
comment|// rely on the underlying URLConnection implementation
comment|// because of trust issues.
name|connection
operator|.
name|setInstanceFollowRedirects
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// If the HTTP_REQUEST_METHOD is not set, the default is "POST".
name|String
name|httpRequestMethod
init|=
operator|(
name|String
operator|)
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|HTTP_REQUEST_METHOD
argument_list|)
decl_stmt|;
name|connection
operator|.
name|setRequestMethod
argument_list|(
operator|(
literal|null
operator|!=
name|httpRequestMethod
operator|)
condition|?
name|httpRequestMethod
else|:
literal|"POST"
argument_list|)
expr_stmt|;
name|boolean
name|isChunking
init|=
literal|false
decl_stmt|;
name|int
name|chunkThreshold
init|=
literal|0
decl_stmt|;
specifier|final
name|AuthorizationPolicy
name|effectiveAuthPolicy
init|=
name|getEffectiveAuthPolicy
argument_list|(
name|message
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|authSupplier
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|authSupplier
operator|=
name|createAuthSupplier
argument_list|(
name|effectiveAuthPolicy
operator|.
name|getAuthorizationType
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|proxyAuthSupplier
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|proxyAuthSupplier
operator|=
name|createAuthSupplier
argument_list|(
name|proxyAuthorizationPolicy
operator|.
name|getAuthorizationType
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|authSupplier
operator|.
name|requiresRequestCaching
argument_list|()
condition|)
block|{
name|needToCacheRequest
operator|=
literal|true
expr_stmt|;
name|isChunking
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Auth Supplier, but no Premeptive User Pass or Digest auth (nonce may be stale)"
operator|+
literal|" We must cache request."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csPolicy
operator|.
name|isAutoRedirect
argument_list|()
condition|)
block|{
name|needToCacheRequest
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"AutoRedirect is turned on."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csPolicy
operator|.
name|getMaxRetransmits
argument_list|()
operator|>
literal|0
condition|)
block|{
name|needToCacheRequest
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"MaxRetransmits is set> 0."
argument_list|)
expr_stmt|;
block|}
comment|// DELETE does not work and empty PUTs cause misleading exceptions
comment|// if chunking is enabled
comment|// TODO : ensure chunking can be enabled for non-empty PUTs - if requested
if|if
condition|(
name|csPolicy
operator|.
name|isAllowChunking
argument_list|()
operator|&&
name|isChunkingSupported
argument_list|(
name|message
argument_list|,
name|connection
operator|.
name|getRequestMethod
argument_list|()
argument_list|)
condition|)
block|{
comment|//TODO: The chunking mode be configured or at least some
comment|// documented client constant.
comment|//use -1 and allow the URL connection to pick a default value
name|isChunking
operator|=
literal|true
expr_stmt|;
name|chunkThreshold
operator|=
name|csPolicy
operator|.
name|getChunkingThreshold
argument_list|()
expr_stmt|;
if|if
condition|(
name|chunkThreshold
operator|<=
literal|0
condition|)
block|{
name|chunkThreshold
operator|=
literal|0
expr_stmt|;
name|connection
operator|.
name|setChunkedStreamingMode
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|cookies
operator|.
name|writeToMessageHeaders
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|// The trust decision is relegated to after the "flushing" of the
comment|// request headers.
comment|// We place the connection on the message to pick it up
comment|// in the WrappedOutputStream.
name|message
operator|.
name|put
argument_list|(
name|KEY_HTTP_CONNECTION
argument_list|,
name|connection
argument_list|)
expr_stmt|;
if|if
condition|(
name|certConstraints
operator|!=
literal|null
condition|)
block|{
name|message
operator|.
name|put
argument_list|(
name|CertConstraints
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|certConstraints
argument_list|)
expr_stmt|;
name|message
operator|.
name|getInterceptorChain
argument_list|()
operator|.
name|add
argument_list|(
name|CertConstraintsInterceptor
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
name|setHeadersByAuthorizationPolicy
argument_list|(
name|message
argument_list|,
name|currentURL
argument_list|)
expr_stmt|;
operator|new
name|Headers
argument_list|(
name|message
argument_list|)
operator|.
name|setFromClientPolicy
argument_list|(
name|getClient
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|.
name|setContent
argument_list|(
name|OutputStream
operator|.
name|class
argument_list|,
name|createOutputStream
argument_list|(
name|message
argument_list|,
name|connection
argument_list|,
name|needToCacheRequest
argument_list|,
name|isChunking
argument_list|,
name|chunkThreshold
argument_list|)
argument_list|)
expr_stmt|;
comment|// We are now "ready" to "send" the message.
block|}
specifier|protected
name|boolean
name|isChunkingSupported
parameter_list|(
name|Message
name|message
parameter_list|,
name|String
name|httpMethod
parameter_list|)
block|{
if|if
condition|(
name|HTTP_POST_METHOD
operator|.
name|equals
argument_list|(
name|httpMethod
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|HTTP_PUT_METHOD
operator|.
name|equals
argument_list|(
name|httpMethod
argument_list|)
condition|)
block|{
name|MessageContentsList
name|objs
init|=
name|MessageContentsList
operator|.
name|getContentsList
argument_list|(
name|message
argument_list|)
decl_stmt|;
if|if
condition|(
name|objs
operator|!=
literal|null
operator|&&
name|objs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Object
name|obj
init|=
name|objs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|obj
operator|.
name|getClass
argument_list|()
operator|!=
name|String
operator|.
name|class
operator|||
operator|(
name|obj
operator|.
name|getClass
argument_list|()
operator|==
name|String
operator|.
name|class
operator|&&
operator|(
operator|(
name|String
operator|)
name|obj
operator|)
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|protected
name|OutputStream
name|createOutputStream
parameter_list|(
name|Message
name|message
parameter_list|,
name|HttpURLConnection
name|connection
parameter_list|,
name|boolean
name|needToCacheRequest
parameter_list|,
name|boolean
name|isChunking
parameter_list|,
name|int
name|chunkThreshold
parameter_list|)
block|{
return|return
operator|new
name|WrappedOutputStream
argument_list|(
name|message
argument_list|,
name|connection
argument_list|,
name|needToCacheRequest
argument_list|,
name|isChunking
argument_list|,
name|chunkThreshold
argument_list|,
name|getConduitName
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|HttpAuthSupplier
name|createAuthSupplier
parameter_list|(
name|String
name|authType
parameter_list|)
block|{
if|if
condition|(
name|HttpAuthHeader
operator|.
name|AUTH_TYPE_NEGOTIATE
operator|.
name|equals
argument_list|(
name|authType
argument_list|)
condition|)
block|{
return|return
operator|new
name|SpnegoAuthSupplier
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|HttpAuthHeader
operator|.
name|AUTH_TYPE_DIGEST
operator|.
name|equals
argument_list|(
name|authType
argument_list|)
condition|)
block|{
return|return
operator|new
name|DigestAuthSupplier
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|new
name|DefaultBasicAuthSupplier
argument_list|()
return|;
block|}
block|}
specifier|private
specifier|static
name|int
name|determineReceiveTimeout
parameter_list|(
name|Message
name|message
parameter_list|,
name|HTTPClientPolicy
name|csPolicy
parameter_list|)
block|{
name|long
name|rtimeout
init|=
name|csPolicy
operator|.
name|getReceiveTimeout
argument_list|()
decl_stmt|;
if|if
condition|(
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|RECEIVE_TIMEOUT
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|Object
name|obj
init|=
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|RECEIVE_TIMEOUT
argument_list|)
decl_stmt|;
try|try
block|{
name|rtimeout
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|obj
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"INVALID_TIMEOUT_FORMAT"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|Message
operator|.
name|RECEIVE_TIMEOUT
block|,
name|obj
operator|.
name|toString
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rtimeout
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|rtimeout
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
return|return
operator|(
name|int
operator|)
name|rtimeout
return|;
block|}
specifier|private
specifier|static
name|int
name|determineConnectionTimeout
parameter_list|(
name|Message
name|message
parameter_list|,
name|HTTPClientPolicy
name|csPolicy
parameter_list|)
block|{
name|long
name|ctimeout
init|=
name|csPolicy
operator|.
name|getConnectionTimeout
argument_list|()
decl_stmt|;
if|if
condition|(
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|CONNECTION_TIMEOUT
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|Object
name|obj
init|=
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|CONNECTION_TIMEOUT
argument_list|)
decl_stmt|;
try|try
block|{
name|ctimeout
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|obj
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"INVALID_TIMEOUT_FORMAT"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|Message
operator|.
name|CONNECTION_TIMEOUT
block|,
name|obj
operator|.
name|toString
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ctimeout
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|ctimeout
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
return|return
operator|(
name|int
operator|)
name|ctimeout
return|;
block|}
specifier|public
name|void
name|close
parameter_list|(
name|Message
name|msg
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStream
name|in
init|=
name|msg
operator|.
name|getContent
argument_list|(
name|InputStream
operator|.
name|class
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|byte
name|buffer
index|[]
init|=
operator|new
name|byte
index|[
literal|1024
index|]
decl_stmt|;
while|while
condition|(
name|in
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|count
operator|<
literal|25
condition|)
block|{
comment|//don't do anything, we just need to pull off the unread data (like
comment|//closing tags that we didn't need to read
comment|//however, limit it so we don't read off gigabytes of data we won't use.
operator|++
name|count
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|super
operator|.
name|close
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This function sets up a URL based on ENDPOINT_ADDRESS, PATH_INFO,      * and QUERY_STRING properties in the Message. The QUERY_STRING gets      * added with a "?" after the PATH_INFO. If the ENDPOINT_ADDRESS is not      * set on the Message, the endpoint address is taken from the       * "defaultEndpointURL".      *<p>      * The PATH_INFO is only added to the endpoint address string should       * the PATH_INFO not equal the end of the endpoint address string.      *       * @param message The message holds the addressing information.      *       * @return The full URL specifying the HTTP request to the endpoint.      *       * @throws MalformedURLException      */
specifier|private
name|URL
name|setupURL
parameter_list|(
name|Message
name|message
parameter_list|)
throws|throws
name|MalformedURLException
block|{
name|String
name|result
init|=
operator|(
name|String
operator|)
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|ENDPOINT_ADDRESS
argument_list|)
decl_stmt|;
name|String
name|pathInfo
init|=
operator|(
name|String
operator|)
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|PATH_INFO
argument_list|)
decl_stmt|;
name|String
name|queryString
init|=
operator|(
name|String
operator|)
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|QUERY_STRING
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|pathInfo
operator|==
literal|null
operator|&&
name|queryString
operator|==
literal|null
condition|)
block|{
name|URL
name|url
init|=
name|getURL
argument_list|()
decl_stmt|;
name|message
operator|.
name|put
argument_list|(
name|Message
operator|.
name|ENDPOINT_ADDRESS
argument_list|,
name|defaultEndpointURLString
argument_list|)
expr_stmt|;
return|return
name|url
return|;
block|}
name|result
operator|=
name|getURL
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|message
operator|.
name|put
argument_list|(
name|Message
operator|.
name|ENDPOINT_ADDRESS
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
comment|// REVISIT: is this really correct?
if|if
condition|(
literal|null
operator|!=
name|pathInfo
operator|&&
operator|!
name|result
operator|.
name|endsWith
argument_list|(
name|pathInfo
argument_list|)
condition|)
block|{
name|result
operator|=
name|result
operator|+
name|pathInfo
expr_stmt|;
block|}
if|if
condition|(
name|queryString
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|result
operator|+
literal|"?"
operator|+
name|queryString
expr_stmt|;
block|}
return|return
operator|new
name|URL
argument_list|(
name|result
argument_list|)
return|;
block|}
comment|/**      * Close the conduit      */
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|defaultEndpointURL
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|URLConnection
name|connect
init|=
name|defaultEndpointURL
operator|.
name|openConnection
argument_list|()
decl_stmt|;
if|if
condition|(
name|connect
operator|instanceof
name|HttpURLConnection
condition|)
block|{
operator|(
operator|(
name|HttpURLConnection
operator|)
name|connect
operator|)
operator|.
name|disconnect
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|//ignore
block|}
comment|//defaultEndpointURL = null;
block|}
block|}
comment|/**      * @return the default target address      */
specifier|protected
name|String
name|getAddress
parameter_list|()
block|{
if|if
condition|(
name|defaultEndpointURL
operator|!=
literal|null
condition|)
block|{
return|return
name|defaultEndpointURLString
return|;
block|}
elseif|else
if|if
condition|(
name|fromEndpointReferenceType
condition|)
block|{
return|return
name|getTarget
argument_list|()
operator|.
name|getAddress
argument_list|()
operator|.
name|getValue
argument_list|()
return|;
block|}
return|return
name|endpointInfo
operator|.
name|getAddress
argument_list|()
return|;
block|}
comment|/**      * @return the default target URL      */
specifier|protected
name|URL
name|getURL
parameter_list|()
throws|throws
name|MalformedURLException
block|{
return|return
name|getURL
argument_list|(
literal|true
argument_list|)
return|;
block|}
comment|/**      * @param createOnDemand create URL on-demand if null      * @return the default target URL      */
specifier|protected
specifier|synchronized
name|URL
name|getURL
parameter_list|(
name|boolean
name|createOnDemand
parameter_list|)
throws|throws
name|MalformedURLException
block|{
if|if
condition|(
name|defaultEndpointURL
operator|==
literal|null
operator|&&
name|createOnDemand
condition|)
block|{
if|if
condition|(
name|fromEndpointReferenceType
operator|&&
name|getTarget
argument_list|()
operator|.
name|getAddress
argument_list|()
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|defaultEndpointURL
operator|=
operator|new
name|URL
argument_list|(
name|this
operator|.
name|getTarget
argument_list|()
operator|.
name|getAddress
argument_list|()
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|defaultEndpointURLString
operator|=
name|defaultEndpointURL
operator|.
name|toExternalForm
argument_list|()
expr_stmt|;
return|return
name|defaultEndpointURL
return|;
block|}
if|if
condition|(
name|endpointInfo
operator|.
name|getAddress
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|MalformedURLException
argument_list|(
literal|"Invalid address. Endpoint address cannot be null."
argument_list|)
throw|;
block|}
name|defaultEndpointURL
operator|=
operator|new
name|URL
argument_list|(
name|endpointInfo
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
name|defaultEndpointURLString
operator|=
name|defaultEndpointURL
operator|.
name|toExternalForm
argument_list|()
expr_stmt|;
block|}
return|return
name|defaultEndpointURL
return|;
block|}
comment|/**      * This call places HTTP Header strings into the headers that are relevant      * to the Authorization policies that are set on this conduit by      * configuration.      *<p>       * An AuthorizationPolicy may also be set on the message. If so, those      * policies are merged. A user name or password set on the messsage       * overrides settings in the AuthorizationPolicy is retrieved from the      * configuration.      *<p>      * The precedence is as follows:      * 1. AuthorizationPolicy that is set on the Message, if exists.      * 2. Authorization from AuthSupplier, if exists.      * 3. AuthorizationPolicy set/configured for conduit.      *       * REVISIT: Since the AuthorizationPolicy is set on the message by class, then      * how does one override the ProxyAuthorizationPolicy which is the same       * type?      *       * @param message      * @param headers      */
specifier|private
name|void
name|setHeadersByAuthorizationPolicy
parameter_list|(
name|Message
name|message
parameter_list|,
name|URL
name|url
parameter_list|)
block|{
name|Headers
name|headers
init|=
operator|new
name|Headers
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|AuthorizationPolicy
name|effectiveAuthPolicy
init|=
name|getEffectiveAuthPolicy
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|String
name|authString
init|=
name|authSupplier
operator|.
name|getAuthorization
argument_list|(
name|effectiveAuthPolicy
argument_list|,
name|url
argument_list|,
name|message
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|authString
operator|!=
literal|null
condition|)
block|{
name|headers
operator|.
name|setAuthorization
argument_list|(
name|authString
argument_list|)
expr_stmt|;
block|}
name|String
name|proxyAuthString
init|=
name|authSupplier
operator|.
name|getAuthorization
argument_list|(
name|proxyAuthorizationPolicy
argument_list|,
name|url
argument_list|,
name|message
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|proxyAuthString
operator|!=
literal|null
condition|)
block|{
name|headers
operator|.
name|setProxyAuthorization
argument_list|(
name|proxyAuthString
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This is part of the Configurable interface which retrieves the       * configuration from spring injection.      */
comment|// REVISIT:What happens when the endpoint/bean name is null?
specifier|public
name|String
name|getBeanName
parameter_list|()
block|{
if|if
condition|(
name|endpointInfo
operator|.
name|getName
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|endpointInfo
operator|.
name|getName
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|".http-conduit"
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Determines effective auth policy from message, conduit and empty default      * with priority from first to last      *       * @param message      * @return effective AthorizationPolicy      */
specifier|public
name|AuthorizationPolicy
name|getEffectiveAuthPolicy
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
name|AuthorizationPolicy
name|authPolicy
init|=
name|getAuthorization
argument_list|()
decl_stmt|;
name|AuthorizationPolicy
name|newPolicy
init|=
name|message
operator|.
name|get
argument_list|(
name|AuthorizationPolicy
operator|.
name|class
argument_list|)
decl_stmt|;
name|AuthorizationPolicy
name|effectivePolicy
init|=
name|newPolicy
decl_stmt|;
if|if
condition|(
name|effectivePolicy
operator|==
literal|null
condition|)
block|{
name|effectivePolicy
operator|=
name|authPolicy
expr_stmt|;
block|}
if|if
condition|(
name|effectivePolicy
operator|==
literal|null
condition|)
block|{
name|effectivePolicy
operator|=
operator|new
name|AuthorizationPolicy
argument_list|()
expr_stmt|;
block|}
return|return
name|effectivePolicy
return|;
block|}
comment|/**      * This method gets the Authorization Policy that was configured or       * explicitly set for this HTTPConduit.      */
specifier|public
name|AuthorizationPolicy
name|getAuthorization
parameter_list|()
block|{
return|return
name|authorizationPolicy
return|;
block|}
comment|/**      * This method is used to set the Authorization Policy for this conduit.      * Using this method will override any Authorization Policy set in       * configuration.      */
specifier|public
name|void
name|setAuthorization
parameter_list|(
name|AuthorizationPolicy
name|authorization
parameter_list|)
block|{
name|this
operator|.
name|authorizationPolicy
operator|=
name|authorization
expr_stmt|;
block|}
specifier|public
name|HTTPClientPolicy
name|getClient
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
return|return
name|PolicyUtils
operator|.
name|getClient
argument_list|(
name|message
argument_list|,
name|clientSidePolicy
argument_list|)
return|;
block|}
comment|/**      * This method retrieves the Client Side Policy set/configured for this      * HTTPConduit.      */
specifier|public
name|HTTPClientPolicy
name|getClient
parameter_list|()
block|{
return|return
name|clientSidePolicy
return|;
block|}
comment|/**      * This method sets the Client Side Policy for this HTTPConduit. Using this      * method will override any HTTPClientPolicy set in configuration.      */
specifier|public
name|void
name|setClient
parameter_list|(
name|HTTPClientPolicy
name|client
parameter_list|)
block|{
name|this
operator|.
name|clientSidePolicy
operator|=
name|client
expr_stmt|;
name|client
operator|.
name|addPropertyChangeListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|endpointInfo
operator|.
name|setProperty
argument_list|(
literal|"org.apache.cxf.ws.addressing.replyto"
argument_list|,
name|client
operator|.
name|getDecoupledEndpoint
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method retrieves the Proxy Authorization Policy for a proxy that is      * set/configured for this HTTPConduit.      */
specifier|public
name|ProxyAuthorizationPolicy
name|getProxyAuthorization
parameter_list|()
block|{
return|return
name|proxyAuthorizationPolicy
return|;
block|}
comment|/**      * This method sets the Proxy Authorization Policy for a specified proxy.       * Using this method overrides any Authorization Policy for the proxy       * that is set in the configuration.      */
specifier|public
name|void
name|setProxyAuthorization
parameter_list|(
name|ProxyAuthorizationPolicy
name|proxyAuthorization
parameter_list|)
block|{
name|this
operator|.
name|proxyAuthorizationPolicy
operator|=
name|proxyAuthorization
expr_stmt|;
block|}
comment|/**      * This method returns the TLS Client Parameters that is set/configured      * for this HTTPConduit.      */
specifier|public
name|TLSClientParameters
name|getTlsClientParameters
parameter_list|()
block|{
return|return
name|tlsClientParameters
return|;
block|}
comment|/**      * This method sets the TLS Client Parameters for this HTTPConduit.      * Using this method overrides any TLS Client Parameters that is configured      * for this HTTPConduit.      */
specifier|public
name|void
name|setTlsClientParameters
parameter_list|(
name|TLSClientParameters
name|params
parameter_list|)
block|{
name|this
operator|.
name|tlsClientParameters
operator|=
name|params
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|tlsClientParameters
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Conduit '"
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"' has been (re) configured for TLS "
operator|+
literal|"keyManagers "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|tlsClientParameters
operator|.
name|getKeyManagers
argument_list|()
argument_list|)
operator|+
literal|"trustManagers "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|tlsClientParameters
operator|.
name|getTrustManagers
argument_list|()
argument_list|)
operator|+
literal|"secureRandom "
operator|+
name|tlsClientParameters
operator|.
name|getSecureRandom
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|CertificateConstraintsType
name|constraints
init|=
name|params
operator|.
name|getCertConstraints
argument_list|()
decl_stmt|;
if|if
condition|(
name|constraints
operator|!=
literal|null
condition|)
block|{
name|certConstraints
operator|=
name|CertConstraintsJaxBUtils
operator|.
name|createCertConstraints
argument_list|(
name|constraints
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Conduit '"
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"' has been (re)configured for plain http."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * This method gets the Trust Decider that was set/configured for this       * HTTPConduit.      * @return The Message Trust Decider or null.      */
specifier|public
name|MessageTrustDecider
name|getTrustDecider
parameter_list|()
block|{
return|return
name|this
operator|.
name|trustDecider
return|;
block|}
comment|/**      * This method sets the Trust Decider for this HTTP Conduit.      * Using this method overrides any trust decider configured for this      * HTTPConduit.      */
specifier|public
name|void
name|setTrustDecider
parameter_list|(
name|MessageTrustDecider
name|decider
parameter_list|)
block|{
name|this
operator|.
name|trustDecider
operator|=
name|decider
expr_stmt|;
block|}
comment|/**      * This method gets the Auth Supplier that was set/configured for this       * HTTPConduit.      * @return The Auth Supplier or null.      */
specifier|public
name|HttpAuthSupplier
name|getAuthSupplier
parameter_list|()
block|{
return|return
name|this
operator|.
name|authSupplier
return|;
block|}
specifier|public
name|void
name|setAuthSupplier
parameter_list|(
name|HttpAuthSupplier
name|supplier
parameter_list|)
block|{
name|this
operator|.
name|authSupplier
operator|=
name|supplier
expr_stmt|;
block|}
specifier|public
name|HttpAuthSupplier
name|getProxyAuthSupplier
parameter_list|()
block|{
return|return
name|proxyAuthSupplier
return|;
block|}
specifier|public
name|void
name|setProxyAuthSupplier
parameter_list|(
name|HttpAuthSupplier
name|proxyAuthSupplier
parameter_list|)
block|{
name|this
operator|.
name|proxyAuthSupplier
operator|=
name|proxyAuthSupplier
expr_stmt|;
block|}
comment|/**      * This function processes any retransmits at the direction of redirections      * or "unauthorized" responses.      *<p>      * If the request was not retransmitted, it returns the given connection.       * If the request was retransmitted, it returns the new connection on      * which the request was sent.      *       * @param connection   The active URL connection.      * @param message      The outgoing message.      * @param cachedStream The cached request.      * @return      * @throws IOException      */
specifier|private
name|HttpURLConnection
name|processRetransmit
parameter_list|(
specifier|final
name|HttpURLConnection
name|origConnection
parameter_list|,
name|Message
name|message
parameter_list|,
name|CacheAndWriteOutputStream
name|cachedStream
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|responseCode
init|=
name|origConnection
operator|.
name|getResponseCode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|message
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|message
operator|.
name|getExchange
argument_list|()
operator|!=
literal|null
operator|)
condition|)
block|{
name|message
operator|.
name|getExchange
argument_list|()
operator|.
name|put
argument_list|(
name|Message
operator|.
name|RESPONSE_CODE
argument_list|,
name|responseCode
argument_list|)
expr_stmt|;
block|}
name|HttpURLConnection
name|connection
init|=
name|origConnection
decl_stmt|;
comment|// Process Redirects first.
switch|switch
condition|(
name|responseCode
condition|)
block|{
case|case
name|HttpURLConnection
operator|.
name|HTTP_MOVED_PERM
case|:
case|case
name|HttpURLConnection
operator|.
name|HTTP_MOVED_TEMP
case|:
case|case
literal|307
case|:
name|connection
operator|=
name|redirectRetransmit
argument_list|(
name|origConnection
argument_list|,
name|message
argument_list|,
name|cachedStream
argument_list|)
expr_stmt|;
break|break;
case|case
name|HttpURLConnection
operator|.
name|HTTP_UNAUTHORIZED
case|:
name|connection
operator|=
name|authorizationRetransmit
argument_list|(
name|origConnection
argument_list|,
name|message
argument_list|,
name|cachedStream
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|connection
return|;
block|}
comment|/**      * This method performs a redirection retransmit in response to      * a 302 or 305 response code.      *      * @param connection   The active URL connection      * @param message      The outbound message.      * @param cachedStream The cached request.      * @return This method returns the new HttpURLConnection if      *         redirected. If it cannot be redirected for some reason      *         the same connection is returned.      *               * @throws IOException      */
specifier|private
name|HttpURLConnection
name|redirectRetransmit
parameter_list|(
name|HttpURLConnection
name|connection
parameter_list|,
name|Message
name|message
parameter_list|,
name|CacheAndWriteOutputStream
name|cachedStream
parameter_list|)
throws|throws
name|IOException
block|{
comment|// If we are not redirecting by policy, then we don't.
if|if
condition|(
operator|!
name|getClient
argument_list|(
name|message
argument_list|)
operator|.
name|isAutoRedirect
argument_list|()
condition|)
block|{
return|return
name|connection
return|;
block|}
name|URL
name|newURL
init|=
name|extractLocation
argument_list|(
name|connection
operator|.
name|getHeaderFields
argument_list|()
argument_list|)
decl_stmt|;
name|detectRedirectLoop
argument_list|(
name|getConduitName
argument_list|()
argument_list|,
name|connection
operator|.
name|getURL
argument_list|()
argument_list|,
name|newURL
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|newURL
operator|!=
literal|null
condition|)
block|{
operator|new
name|Headers
argument_list|(
name|message
argument_list|)
operator|.
name|removeAuthorizationHeaders
argument_list|()
expr_stmt|;
comment|// If user configured this Conduit with preemptive authorization
comment|// it is meant to make it to the end. (Too bad that information
comment|// went to every URL along the way, but that's what the user
comment|// wants!
comment|// TODO: Make this issue a security release note.
name|setHeadersByAuthorizationPolicy
argument_list|(
name|message
argument_list|,
name|newURL
argument_list|)
expr_stmt|;
name|connection
operator|.
name|disconnect
argument_list|()
expr_stmt|;
return|return
name|retransmit
argument_list|(
name|newURL
argument_list|,
name|message
argument_list|,
name|cachedStream
argument_list|)
return|;
block|}
return|return
name|connection
return|;
block|}
comment|/**      * This method performs a retransmit for authorization information.      *       * @param connection The currently active connection.      * @param message The outbound message.      * @param cachedStream The cached request.      * @return A new connection if retransmitted. If not retransmitted      *         then this method returns the same connection.      * @throws IOException      */
specifier|private
name|HttpURLConnection
name|authorizationRetransmit
parameter_list|(
name|HttpURLConnection
name|connection
parameter_list|,
name|Message
name|message
parameter_list|,
name|CacheAndWriteOutputStream
name|cachedStream
parameter_list|)
throws|throws
name|IOException
block|{
name|HttpAuthHeader
name|authHeader
init|=
operator|new
name|HttpAuthHeader
argument_list|(
name|connection
operator|.
name|getHeaderField
argument_list|(
literal|"WWW-Authenticate"
argument_list|)
argument_list|)
decl_stmt|;
name|URL
name|currentURL
init|=
name|connection
operator|.
name|getURL
argument_list|()
decl_stmt|;
name|String
name|realm
init|=
name|authHeader
operator|.
name|getRealm
argument_list|()
decl_stmt|;
name|detectAuthorizationLoop
argument_list|(
name|getConduitName
argument_list|()
argument_list|,
name|message
argument_list|,
name|currentURL
argument_list|,
name|realm
argument_list|)
expr_stmt|;
name|AuthorizationPolicy
name|effectiveAthPolicy
init|=
name|getEffectiveAuthPolicy
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|String
name|authorizationToken
init|=
name|authSupplier
operator|.
name|getAuthorization
argument_list|(
name|effectiveAthPolicy
argument_list|,
name|currentURL
argument_list|,
name|message
argument_list|,
name|authHeader
operator|.
name|getFullHeader
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|authorizationToken
operator|==
literal|null
condition|)
block|{
comment|// authentication not possible => we give up
return|return
name|connection
return|;
block|}
operator|new
name|Headers
argument_list|(
name|message
argument_list|)
operator|.
name|setAuthorization
argument_list|(
name|authorizationToken
argument_list|)
expr_stmt|;
name|cookies
operator|.
name|writeToMessageHeaders
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|connection
operator|.
name|disconnect
argument_list|()
expr_stmt|;
return|return
name|retransmit
argument_list|(
name|currentURL
argument_list|,
name|message
argument_list|,
name|cachedStream
argument_list|)
return|;
block|}
comment|/**      * This method retransmits the request.      *       * @param connection The currently active connection.      * @param newURL     The newURL to connection to.      * @param message    The outbound message.      * @param stream     The cached request.      * @return           This function returns a new connection if      *                   retransmitted, otherwise it returns the given      *                   connection.      *                         * @throws IOException      */
specifier|private
name|HttpURLConnection
name|retransmit
parameter_list|(
name|URL
name|newURL
parameter_list|,
name|Message
name|message
parameter_list|,
name|CacheAndWriteOutputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|HTTPClientPolicy
name|cp
init|=
name|getClient
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|HttpURLConnection
name|connection
init|=
name|createConnection
argument_list|(
name|message
argument_list|,
name|newURL
argument_list|)
decl_stmt|;
name|connection
operator|.
name|setDoOutput
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// TODO: using Message context to decided HTTP send properties
name|connection
operator|.
name|setConnectTimeout
argument_list|(
operator|(
name|int
operator|)
name|cp
operator|.
name|getConnectionTimeout
argument_list|()
argument_list|)
expr_stmt|;
name|connection
operator|.
name|setReadTimeout
argument_list|(
operator|(
name|int
operator|)
name|cp
operator|.
name|getReceiveTimeout
argument_list|()
argument_list|)
expr_stmt|;
name|connection
operator|.
name|setUseCaches
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|connection
operator|.
name|setInstanceFollowRedirects
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// If the HTTP_REQUEST_METHOD is not set, the default is "POST".
name|String
name|httpRequestMethod
init|=
operator|(
name|String
operator|)
name|message
operator|.
name|get
argument_list|(
name|Message
operator|.
name|HTTP_REQUEST_METHOD
argument_list|)
decl_stmt|;
name|connection
operator|.
name|setRequestMethod
argument_list|(
operator|(
literal|null
operator|!=
name|httpRequestMethod
operator|)
condition|?
name|httpRequestMethod
else|:
literal|"POST"
argument_list|)
expr_stmt|;
name|message
operator|.
name|put
argument_list|(
name|KEY_HTTP_CONNECTION
argument_list|,
name|connection
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|!=
literal|null
operator|&&
name|stream
operator|.
name|size
argument_list|()
operator|<
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|connection
operator|.
name|setFixedLengthStreamingMode
argument_list|(
operator|(
name|int
operator|)
name|stream
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Need to set the headers before the trust decision
comment|// because they are set before the connect().
operator|new
name|Headers
argument_list|(
name|message
argument_list|)
operator|.
name|setProtocolHeadersInConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
comment|//
comment|// This point is where the trust decision is made because the
comment|// Sun implementation of URLConnection will not let us
comment|// set/addRequestProperty after a connect() call, and
comment|// makeTrustDecision needs to make a connect() call to
comment|// make sure the proper information is available.
comment|//
name|TrustDecisionUtil
operator|.
name|makeTrustDecision
argument_list|(
name|trustDecider
argument_list|,
name|message
argument_list|,
name|connection
argument_list|,
name|getConduitName
argument_list|()
argument_list|)
expr_stmt|;
comment|// If this is a GET method we must not touch the output
comment|// stream as this automagically turns the request into a POST.
if|if
condition|(
name|connection
operator|.
name|getRequestMethod
argument_list|()
operator|.
name|equals
argument_list|(
literal|"GET"
argument_list|)
condition|)
block|{
return|return
name|connection
return|;
block|}
comment|// Trust is okay, write the cached request
name|OutputStream
name|out
init|=
name|connection
operator|.
name|getOutputStream
argument_list|()
decl_stmt|;
name|stream
operator|.
name|writeCacheTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
literal|"Conduit \""
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"\" Retransmit message to: "
operator|+
name|connection
operator|.
name|getURL
argument_list|()
operator|+
literal|": "
operator|+
operator|new
name|String
argument_list|(
name|stream
operator|.
name|getBytes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|connection
return|;
block|}
specifier|private
specifier|static
name|void
name|detectAuthorizationLoop
parameter_list|(
name|String
name|conduitName
parameter_list|,
name|Message
name|message
parameter_list|,
name|URL
name|currentURL
parameter_list|,
name|String
name|realm
parameter_list|)
throws|throws
name|IOException
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Set
argument_list|<
name|String
argument_list|>
name|authURLs
init|=
operator|(
name|Set
argument_list|<
name|String
argument_list|>
operator|)
name|message
operator|.
name|get
argument_list|(
name|KEY_AUTH_URLS
argument_list|)
decl_stmt|;
if|if
condition|(
name|authURLs
operator|==
literal|null
condition|)
block|{
name|authURLs
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|message
operator|.
name|put
argument_list|(
name|KEY_AUTH_URLS
argument_list|,
name|authURLs
argument_list|)
expr_stmt|;
block|}
comment|// If we have been here (URL& Realm) before for this particular message
comment|// retransmit, it means we have already supplied information
comment|// which must have been wrong, or we wouldn't be here again.
comment|// Otherwise, the server may be 401 looping us around the realms.
if|if
condition|(
name|authURLs
operator|.
name|contains
argument_list|(
name|currentURL
operator|.
name|toString
argument_list|()
operator|+
name|realm
argument_list|)
condition|)
block|{
name|String
name|logMessage
init|=
literal|"Authorization loop detected on Conduit \""
operator|+
name|conduitName
operator|+
literal|"\" on URL \""
operator|+
name|currentURL
operator|+
literal|"\" with realm \""
operator|+
name|realm
operator|+
literal|"\""
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|INFO
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|INFO
argument_list|,
name|logMessage
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
name|logMessage
argument_list|)
throw|;
block|}
comment|// Register that we have been here before we go.
name|authURLs
operator|.
name|add
argument_list|(
name|currentURL
operator|.
name|toString
argument_list|()
operator|+
name|realm
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tracks the visited urls in the message header KEY_VISITED_URLS.      * If a URL is to be visited twice an exception is thrown      *       * @param conduitName      * @param lastURL      * @param newURL      * @param message      * @throws IOException      */
specifier|private
specifier|static
name|void
name|detectRedirectLoop
parameter_list|(
name|String
name|conduitName
parameter_list|,
name|URL
name|lastURL
parameter_list|,
name|URL
name|newURL
parameter_list|,
name|Message
name|message
parameter_list|)
throws|throws
name|IOException
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Set
argument_list|<
name|String
argument_list|>
name|visitedURLs
init|=
operator|(
name|Set
argument_list|<
name|String
argument_list|>
operator|)
name|message
operator|.
name|get
argument_list|(
name|KEY_VISITED_URLS
argument_list|)
decl_stmt|;
if|if
condition|(
name|visitedURLs
operator|==
literal|null
condition|)
block|{
name|visitedURLs
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|message
operator|.
name|put
argument_list|(
name|KEY_VISITED_URLS
argument_list|,
name|visitedURLs
argument_list|)
expr_stmt|;
block|}
name|visitedURLs
operator|.
name|add
argument_list|(
name|lastURL
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|newURL
operator|!=
literal|null
operator|&&
name|visitedURLs
operator|.
name|contains
argument_list|(
name|newURL
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
comment|// See if we are being redirected in a loop as best we can,
comment|// using string equality on URL.
comment|// We are in a redirect loop; -- bail
name|String
name|msg
init|=
literal|"Redirect loop detected on Conduit '"
operator|+
name|conduitName
operator|+
literal|"' on '"
operator|+
name|newURL
operator|+
literal|"'"
decl_stmt|;
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|INFO
argument_list|,
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
comment|/**      * This method extracts the value of the "Location" Http      * Response header.      *       * @param headers The Http response headers.      * @return The value of the "Location" header, null if non-existent.      * @throws MalformedURLException       */
specifier|private
name|URL
name|extractLocation
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|headers
parameter_list|)
throws|throws
name|MalformedURLException
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|head
range|:
name|headers
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
literal|"Location"
operator|.
name|equalsIgnoreCase
argument_list|(
name|head
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|locs
init|=
name|head
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|locs
operator|!=
literal|null
operator|&&
name|locs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
name|location
init|=
name|locs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|location
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|URL
argument_list|(
name|location
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Wrapper output stream responsible for flushing headers and handling      * the incoming HTTP-level response (not necessarily the MEP response).      */
specifier|protected
class|class
name|WrappedOutputStream
extends|extends
name|AbstractThresholdOutputStream
block|{
comment|/**          * This field contains the currently active connection.          */
specifier|protected
name|HttpURLConnection
name|connection
decl_stmt|;
comment|/**          * This boolean is true if the request must be cached.          */
specifier|protected
name|boolean
name|cachingForRetransmission
decl_stmt|;
comment|/**          * If we are going to be chunking, we won't flush till close which causes          * new chunks, small network packets, etc..          */
specifier|protected
specifier|final
name|boolean
name|chunking
decl_stmt|;
comment|/**          * This field contains the output stream with which we cache          * the request. It maybe null if we are not caching.          */
specifier|protected
name|CacheAndWriteOutputStream
name|cachedStream
decl_stmt|;
specifier|protected
name|Message
name|outMessage
decl_stmt|;
specifier|protected
name|String
name|conduitName
decl_stmt|;
specifier|protected
name|WrappedOutputStream
parameter_list|(
name|Message
name|outMessage
parameter_list|,
name|HttpURLConnection
name|connection
parameter_list|,
name|boolean
name|possibleRetransmit
parameter_list|,
name|boolean
name|isChunking
parameter_list|,
name|int
name|chunkThreshold
parameter_list|,
name|String
name|conduitName
parameter_list|)
block|{
name|super
argument_list|(
name|chunkThreshold
argument_list|)
expr_stmt|;
name|this
operator|.
name|outMessage
operator|=
name|outMessage
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|connection
expr_stmt|;
name|this
operator|.
name|cachingForRetransmission
operator|=
name|possibleRetransmit
expr_stmt|;
name|this
operator|.
name|chunking
operator|=
name|isChunking
expr_stmt|;
name|this
operator|.
name|conduitName
operator|=
name|conduitName
expr_stmt|;
block|}
comment|// This construction makes extending the HTTPConduit more easier
specifier|protected
name|WrappedOutputStream
parameter_list|(
name|WrappedOutputStream
name|wos
parameter_list|)
block|{
name|super
argument_list|(
name|wos
operator|.
name|threshold
argument_list|)
expr_stmt|;
name|this
operator|.
name|outMessage
operator|=
name|wos
operator|.
name|outMessage
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|wos
operator|.
name|connection
expr_stmt|;
name|this
operator|.
name|cachingForRetransmission
operator|=
name|wos
operator|.
name|cachingForRetransmission
expr_stmt|;
name|this
operator|.
name|chunking
operator|=
name|wos
operator|.
name|chunking
expr_stmt|;
name|this
operator|.
name|conduitName
operator|=
name|wos
operator|.
name|conduitName
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|thresholdNotReached
parameter_list|()
block|{
if|if
condition|(
name|chunking
condition|)
block|{
name|connection
operator|.
name|setFixedLengthStreamingMode
argument_list|(
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|thresholdReached
parameter_list|()
block|{
if|if
condition|(
name|chunking
condition|)
block|{
name|connection
operator|.
name|setChunkedStreamingMode
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Perform any actions required on stream flush (freeze headers,          * reset output stream ... etc.)          */
annotation|@
name|Override
specifier|protected
name|void
name|onFirstWrite
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|handleHeadersTrustCaching
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getMessage
argument_list|()
operator|!=
literal|null
operator|&&
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"HTTPS hostname wrong:"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The https URL hostname does not match the "
operator|+
literal|"Common Name (CN) on the server certificate.  To disable this check "
operator|+
literal|"(NOT recommended for production) set the CXF client TLS configuration "
operator|+
literal|"property \"disableCNCheck\" to true."
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
literal|"Sending "
operator|+
name|connection
operator|.
name|getRequestMethod
argument_list|()
operator|+
literal|" Message with Headers to "
operator|+
name|connection
operator|.
name|getURL
argument_list|()
operator|+
literal|" Conduit :"
operator|+
name|conduitName
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|handleHeadersTrustCaching
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Need to set the headers before the trust decision
comment|// because they are set before the connect().
operator|new
name|Headers
argument_list|(
name|outMessage
argument_list|)
operator|.
name|setProtocolHeadersInConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
comment|//
comment|// This point is where the trust decision is made because the
comment|// Sun implementation of URLConnection will not let us
comment|// set/addRequestProperty after a connect() call, and
comment|// makeTrustDecision needs to make a connect() call to
comment|// make sure the proper information is available.
comment|//
name|TrustDecisionUtil
operator|.
name|makeTrustDecision
argument_list|(
name|trustDecider
argument_list|,
name|outMessage
argument_list|,
name|connection
argument_list|,
name|conduitName
argument_list|)
expr_stmt|;
comment|// Trust is okay, set up for writing the request.
comment|// If this is a GET method we must not touch the output
comment|// stream as this automatically turns the request into a POST.
comment|// Nor it should be done in case of DELETE/HEAD/OPTIONS
comment|// - strangely, empty PUTs work ok
if|if
condition|(
operator|!
literal|"POST"
operator|.
name|equals
argument_list|(
name|connection
operator|.
name|getRequestMethod
argument_list|()
argument_list|)
operator|&&
operator|!
literal|"PUT"
operator|.
name|equals
argument_list|(
name|connection
operator|.
name|getRequestMethod
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|outMessage
operator|.
name|get
argument_list|(
literal|"org.apache.cxf.post.empty"
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
comment|// If we need to cache for retransmission, store data in a
comment|// CacheAndWriteOutputStream. Otherwise write directly to the output stream.
if|if
condition|(
name|cachingForRetransmission
condition|)
block|{
name|cachedStream
operator|=
operator|new
name|CacheAndWriteOutputStream
argument_list|(
name|connection
operator|.
name|getOutputStream
argument_list|()
argument_list|)
expr_stmt|;
name|wrappedStream
operator|=
name|cachedStream
expr_stmt|;
block|}
else|else
block|{
name|wrappedStream
operator|=
name|connection
operator|.
name|getOutputStream
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|chunking
condition|)
block|{
name|super
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**          * Perform any actions required on stream closure (handle response etc.)          */
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|buffer
operator|!=
literal|null
operator|&&
name|buffer
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|thresholdNotReached
argument_list|()
expr_stmt|;
name|LoadingByteArrayOutputStream
name|tmp
init|=
name|buffer
decl_stmt|;
name|buffer
operator|=
literal|null
expr_stmt|;
name|super
operator|.
name|write
argument_list|(
name|tmp
operator|.
name|getRawBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|tmp
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|written
condition|)
block|{
name|handleHeadersTrustCaching
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cachingForRetransmission
condition|)
block|{
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cachedStream
operator|!=
literal|null
condition|)
block|{
name|super
operator|.
name|flush
argument_list|()
expr_stmt|;
name|cachedStream
operator|.
name|getOut
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
name|cachedStream
operator|.
name|closeFlowthroughStream
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|handleResponse
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|cachingForRetransmission
operator|&&
name|cachedStream
operator|!=
literal|null
condition|)
block|{
name|cachedStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|HttpRetryException
name|e
parameter_list|)
block|{
name|handleHttpRetryException
argument_list|(
name|e
argument_list|,
name|connection
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|String
name|url
init|=
name|connection
operator|.
name|getURL
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|origMessage
init|=
name|e
operator|.
name|getMessage
argument_list|()
decl_stmt|;
if|if
condition|(
name|origMessage
operator|!=
literal|null
operator|&&
name|origMessage
operator|.
name|contains
argument_list|(
name|url
argument_list|)
condition|)
block|{
throw|throw
name|e
throw|;
block|}
throw|throw
name|mapException
argument_list|(
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" invoking "
operator|+
name|connection
operator|.
name|getURL
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|,
name|IOException
operator|.
name|class
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
name|mapException
argument_list|(
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" invoking "
operator|+
name|connection
operator|.
name|getURL
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|,
name|RuntimeException
operator|.
name|class
argument_list|)
throw|;
block|}
block|}
specifier|private
parameter_list|<
name|T
extends|extends
name|Exception
parameter_list|>
name|T
name|mapException
parameter_list|(
name|String
name|msg
parameter_list|,
name|T
name|ex
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|cls
parameter_list|)
block|{
name|T
name|ex2
init|=
name|ex
decl_stmt|;
try|try
block|{
name|ex2
operator|=
name|cls
operator|.
name|cast
argument_list|(
name|ex
operator|.
name|getClass
argument_list|()
operator|.
name|getConstructor
argument_list|(
name|String
operator|.
name|class
argument_list|)
operator|.
name|newInstance
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|ex2
operator|.
name|initCause
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|ex2
operator|=
name|ex
expr_stmt|;
block|}
return|return
name|ex2
return|;
block|}
comment|/**          * This procedure handles all retransmits, if any.          *          * @throws IOException          */
specifier|protected
name|void
name|handleRetransmits
parameter_list|()
throws|throws
name|IOException
block|{
comment|// If we have a cachedStream, we are caching the request.
if|if
condition|(
name|cachedStream
operator|!=
literal|null
operator|||
operator|(
literal|"GET"
operator|.
name|equals
argument_list|(
name|connection
operator|.
name|getRequestMethod
argument_list|()
argument_list|)
operator|&&
name|getClient
argument_list|()
operator|.
name|isAutoRedirect
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
operator|&&
name|cachedStream
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
literal|"Conduit \""
operator|+
name|getConduitName
argument_list|()
operator|+
literal|"\" Transmit cached message to: "
operator|+
name|connection
operator|.
name|getURL
argument_list|()
operator|+
literal|": "
operator|+
operator|new
name|String
argument_list|(
name|cachedStream
operator|.
name|getBytes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|maxRetransmits
init|=
name|getMaxRetransmits
argument_list|()
decl_stmt|;
name|cookies
operator|.
name|readFromConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|int
name|nretransmits
init|=
literal|0
decl_stmt|;
name|HttpURLConnection
name|oldcon
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|connection
operator|!=
name|oldcon
operator|&&
operator|(
name|maxRetransmits
operator|<
literal|0
operator|||
name|nretransmits
operator|<
name|maxRetransmits
operator|)
condition|)
block|{
name|nretransmits
operator|++
expr_stmt|;
name|oldcon
operator|=
name|connection
expr_stmt|;
name|connection
operator|=
name|processRetransmit
argument_list|(
name|connection
argument_list|,
name|outMessage
argument_list|,
name|cachedStream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|int
name|getMaxRetransmits
parameter_list|()
block|{
name|HTTPClientPolicy
name|policy
init|=
name|getClient
argument_list|(
name|outMessage
argument_list|)
decl_stmt|;
comment|// Default MaxRetransmits is -1 which means unlimited.
return|return
operator|(
name|policy
operator|==
literal|null
operator|)
condition|?
operator|-
literal|1
else|:
name|policy
operator|.
name|getMaxRetransmits
argument_list|()
return|;
block|}
comment|/**          * This procedure is called on the close of the output stream so          * we are ready to handle the response from the connection.           * We may retransmit until we finally get a response.          *           * @throws IOException          */
specifier|protected
name|void
name|handleResponse
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Process retransmits until we fall out.
name|handleRetransmits
argument_list|()
expr_stmt|;
if|if
condition|(
name|outMessage
operator|==
literal|null
operator|||
name|outMessage
operator|.
name|getExchange
argument_list|()
operator|==
literal|null
operator|||
name|outMessage
operator|.
name|getExchange
argument_list|()
operator|.
name|isSynchronous
argument_list|()
condition|)
block|{
name|handleResponseInternal
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Runnable
name|runnable
init|=
operator|new
name|Runnable
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|handleResponseInternal
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
operator|(
operator|(
name|PhaseInterceptorChain
operator|)
name|outMessage
operator|.
name|getInterceptorChain
argument_list|()
operator|)
operator|.
name|abort
argument_list|()
expr_stmt|;
operator|(
operator|(
name|PhaseInterceptorChain
operator|)
name|outMessage
operator|.
name|getInterceptorChain
argument_list|()
operator|)
operator|.
name|unwind
argument_list|(
name|outMessage
argument_list|)
expr_stmt|;
name|outMessage
operator|.
name|setContent
argument_list|(
name|Exception
operator|.
name|class
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|outMessage
operator|.
name|getInterceptorChain
argument_list|()
operator|.
name|getFaultObserver
argument_list|()
operator|.
name|onMessage
argument_list|(
name|outMessage
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
try|try
block|{
name|Executor
name|ex
init|=
name|outMessage
operator|.
name|getExchange
argument_list|()
operator|.
name|get
argument_list|(
name|Executor
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
name|WorkQueueManager
name|mgr
init|=
name|outMessage
operator|.
name|getExchange
argument_list|()
operator|.
name|get
argument_list|(
name|Bus
operator|.
name|class
argument_list|)
operator|.
name|getExtension
argument_list|(
name|WorkQueueManager
operator|.
name|class
argument_list|)
decl_stmt|;
name|AutomaticWorkQueue
name|qu
init|=
name|mgr
operator|.
name|getNamedWorkQueue
argument_list|(
literal|"http-conduit"
argument_list|)
decl_stmt|;
name|qu
operator|=
name|mgr
operator|.
name|getAutomaticWorkQueue
argument_list|()
expr_stmt|;
name|qu
operator|.
name|execute
argument_list|(
name|runnable
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outMessage
operator|.
name|getExchange
argument_list|()
operator|.
name|put
argument_list|(
name|Executor
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".USING_SPECIFIED"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|ex
operator|.
name|execute
argument_list|(
name|runnable
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RejectedExecutionException
name|rex
parameter_list|)
block|{
name|LOG
operator|.
name|warning
argument_list|(
literal|"EXECUTOR_FULL"
argument_list|)
expr_stmt|;
name|handleResponseInternal
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**          * This predicate returns true iff the exchange indicates           * a oneway MEP.          *           * @param exchange The exchange in question          */
specifier|private
name|boolean
name|isOneway
parameter_list|(
name|Exchange
name|exchange
parameter_list|)
block|{
return|return
name|exchange
operator|!=
literal|null
operator|&&
name|exchange
operator|.
name|isOneWay
argument_list|()
return|;
block|}
specifier|protected
name|void
name|handleResponseInternal
parameter_list|()
throws|throws
name|IOException
block|{
name|Exchange
name|exchange
init|=
name|outMessage
operator|.
name|getExchange
argument_list|()
decl_stmt|;
name|int
name|responseCode
init|=
name|connection
operator|.
name|getResponseCode
argument_list|()
decl_stmt|;
if|if
condition|(
name|outMessage
operator|!=
literal|null
operator|&&
name|exchange
operator|!=
literal|null
condition|)
block|{
name|exchange
operator|.
name|put
argument_list|(
name|Message
operator|.
name|RESPONSE_CODE
argument_list|,
name|responseCode
argument_list|)
expr_stmt|;
block|}
name|logResponseInfo
argument_list|(
name|responseCode
argument_list|)
expr_stmt|;
comment|// This property should be set in case the exceptions should not be handled here
comment|// For example jax rs uses this
name|boolean
name|noExceptions
init|=
name|MessageUtils
operator|.
name|isTrue
argument_list|(
name|outMessage
operator|.
name|getContextualProperty
argument_list|(
literal|"org.apache.cxf.http.no_io_exceptions"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|responseCode
operator|>=
literal|400
operator|&&
name|responseCode
operator|!=
literal|500
operator|&&
operator|!
name|noExceptions
condition|)
block|{
throw|throw
operator|new
name|HTTPException
argument_list|(
name|responseCode
argument_list|,
name|connection
operator|.
name|getResponseMessage
argument_list|()
argument_list|,
name|connection
operator|.
name|getURL
argument_list|()
argument_list|)
throw|;
block|}
name|InputStream
name|in
init|=
literal|null
decl_stmt|;
comment|// oneway or decoupled twoway calls may expect HTTP 202 with no content
if|if
condition|(
name|isOneway
argument_list|(
name|exchange
argument_list|)
operator|||
name|HttpURLConnection
operator|.
name|HTTP_ACCEPTED
operator|==
name|responseCode
condition|)
block|{
name|in
operator|=
name|ChunkedUtil
operator|.
name|getPartialResponse
argument_list|(
name|connection
argument_list|,
name|responseCode
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
comment|// oneway operation or decoupled MEP without
comment|// partial response
name|connection
operator|.
name|getInputStream
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
name|ClientCallback
name|cc
init|=
name|exchange
operator|.
name|get
argument_list|(
name|ClientCallback
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|cc
condition|)
block|{
comment|//REVISIT move the decoupled destination property name into api
name|Endpoint
name|ep
init|=
name|exchange
operator|.
name|getEndpoint
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|ep
operator|&&
literal|null
operator|!=
name|ep
operator|.
name|getEndpointInfo
argument_list|()
operator|&&
literal|null
operator|==
name|ep
operator|.
name|getEndpointInfo
argument_list|()
operator|.
name|getProperty
argument_list|(
literal|"org.apache.cxf.ws.addressing.MAPAggregator.decoupledDestination"
argument_list|)
condition|)
block|{
name|cc
operator|.
name|handleResponse
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
block|}
else|else
block|{
comment|//not going to be resending or anything, clear out the stuff in the out message
comment|//to free memory
name|outMessage
operator|.
name|removeContent
argument_list|(
name|OutputStream
operator|.
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|cachingForRetransmission
operator|&&
name|cachedStream
operator|!=
literal|null
condition|)
block|{
name|cachedStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|cachedStream
operator|=
literal|null
expr_stmt|;
block|}
name|Message
name|inMessage
init|=
operator|new
name|MessageImpl
argument_list|()
decl_stmt|;
name|inMessage
operator|.
name|setExchange
argument_list|(
name|exchange
argument_list|)
expr_stmt|;
operator|new
name|Headers
argument_list|(
name|inMessage
argument_list|)
operator|.
name|readFromConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|inMessage
operator|.
name|put
argument_list|(
name|Message
operator|.
name|RESPONSE_CODE
argument_list|,
name|responseCode
argument_list|)
expr_stmt|;
name|String
name|ct
init|=
name|connection
operator|.
name|getContentType
argument_list|()
decl_stmt|;
name|inMessage
operator|.
name|put
argument_list|(
name|Message
operator|.
name|CONTENT_TYPE
argument_list|,
name|ct
argument_list|)
expr_stmt|;
name|String
name|charset
init|=
name|HttpHeaderHelper
operator|.
name|findCharset
argument_list|(
name|ct
argument_list|)
decl_stmt|;
name|String
name|normalizedEncoding
init|=
name|HttpHeaderHelper
operator|.
name|mapCharset
argument_list|(
name|charset
argument_list|)
decl_stmt|;
if|if
condition|(
name|normalizedEncoding
operator|==
literal|null
condition|)
block|{
name|String
name|m
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|common
operator|.
name|i18n
operator|.
name|Message
argument_list|(
literal|"INVALID_ENCODING_MSG"
argument_list|,
name|LOG
argument_list|,
name|charset
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
name|m
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|m
argument_list|)
throw|;
block|}
name|inMessage
operator|.
name|put
argument_list|(
name|Message
operator|.
name|ENCODING
argument_list|,
name|normalizedEncoding
argument_list|)
expr_stmt|;
name|cookies
operator|.
name|readFromConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|responseCode
operator|>=
name|HttpURLConnection
operator|.
name|HTTP_BAD_REQUEST
condition|)
block|{
name|in
operator|=
name|connection
operator|.
name|getErrorStream
argument_list|()
expr_stmt|;
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
try|try
block|{
comment|// just in case - but this will most likely cause an exception
name|in
operator|=
name|connection
operator|.
name|getInputStream
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// ignore
block|}
block|}
block|}
else|else
block|{
name|in
operator|=
name|connection
operator|.
name|getInputStream
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
comment|// Create an empty stream to avoid NullPointerExceptions
name|in
operator|=
operator|new
name|ByteArrayInputStream
argument_list|(
operator|new
name|byte
index|[]
block|{}
argument_list|)
expr_stmt|;
block|}
name|inMessage
operator|.
name|setContent
argument_list|(
name|InputStream
operator|.
name|class
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|incomingObserver
operator|.
name|onMessage
argument_list|(
name|inMessage
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|logResponseInfo
parameter_list|(
name|int
name|responseCode
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fine
argument_list|(
literal|"Response Code: "
operator|+
name|responseCode
operator|+
literal|" Conduit: "
operator|+
name|conduitName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|fine
argument_list|(
literal|"Content length: "
operator|+
name|connection
operator|.
name|getContentLength
argument_list|()
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|headerFields
init|=
name|connection
operator|.
name|getHeaderFields
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|headerFields
condition|)
block|{
name|String
name|newLine
init|=
name|SystemPropertyAction
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"Header fields: "
operator|+
name|newLine
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|headerKey
range|:
name|headerFields
operator|.
name|keySet
argument_list|()
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"    "
operator|+
name|headerKey
operator|+
literal|": "
operator|+
name|headerFields
operator|.
name|get
argument_list|(
name|headerKey
argument_list|)
operator|+
name|newLine
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|fine
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Used to set appropriate message properties, exchange etc.      * as required for an incoming decoupled response (as opposed      * what's normally set by the Destination for an incoming      * request).      */
specifier|protected
class|class
name|InterposedMessageObserver
implements|implements
name|MessageObserver
block|{
comment|/**          * Called for an incoming message.          *           * @param inMessage          */
specifier|public
name|void
name|onMessage
parameter_list|(
name|Message
name|inMessage
parameter_list|)
block|{
comment|// disposable exchange, swapped with real Exchange on correlation
name|inMessage
operator|.
name|setExchange
argument_list|(
operator|new
name|ExchangeImpl
argument_list|()
argument_list|)
expr_stmt|;
name|inMessage
operator|.
name|getExchange
argument_list|()
operator|.
name|put
argument_list|(
name|Bus
operator|.
name|class
argument_list|,
name|bus
argument_list|)
expr_stmt|;
name|inMessage
operator|.
name|put
argument_list|(
name|DECOUPLED_CHANNEL_MESSAGE
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
comment|// REVISIT: how to get response headers?
comment|//inMessage.put(Message.PROTOCOL_HEADERS, req.getXXX());
name|Headers
operator|.
name|getSetProtocolHeaders
argument_list|(
name|inMessage
argument_list|)
expr_stmt|;
name|inMessage
operator|.
name|put
argument_list|(
name|Message
operator|.
name|RESPONSE_CODE
argument_list|,
name|HttpURLConnection
operator|.
name|HTTP_OK
argument_list|)
expr_stmt|;
comment|// remove server-specific properties
name|inMessage
operator|.
name|remove
argument_list|(
name|AbstractHTTPDestination
operator|.
name|HTTP_REQUEST
argument_list|)
expr_stmt|;
name|inMessage
operator|.
name|remove
argument_list|(
name|AbstractHTTPDestination
operator|.
name|HTTP_RESPONSE
argument_list|)
expr_stmt|;
name|inMessage
operator|.
name|remove
argument_list|(
name|Message
operator|.
name|ASYNC_POST_RESPONSE_DISPATCH
argument_list|)
expr_stmt|;
comment|//cache this inputstream since it's defer to use in case of async
try|try
block|{
name|InputStream
name|in
init|=
name|inMessage
operator|.
name|getContent
argument_list|(
name|InputStream
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
name|CachedOutputStream
name|cos
init|=
operator|new
name|CachedOutputStream
argument_list|()
decl_stmt|;
name|IOUtils
operator|.
name|copy
argument_list|(
name|in
argument_list|,
name|cos
argument_list|)
expr_stmt|;
name|inMessage
operator|.
name|setContent
argument_list|(
name|InputStream
operator|.
name|class
argument_list|,
name|cos
operator|.
name|getInputStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|incomingObserver
operator|.
name|onMessage
argument_list|(
name|inMessage
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|assertMessage
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
name|PolicyUtils
operator|.
name|assertClientPolicy
argument_list|(
name|message
argument_list|,
name|clientSidePolicy
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|canAssert
parameter_list|(
name|QName
name|type
parameter_list|)
block|{
return|return
name|PolicyUtils
operator|.
name|HTTPCLIENTPOLICY_ASSERTION_QNAME
operator|.
name|equals
argument_list|(
name|type
argument_list|)
return|;
block|}
specifier|public
name|void
name|propertyChange
parameter_list|(
name|PropertyChangeEvent
name|evt
parameter_list|)
block|{
if|if
condition|(
name|evt
operator|.
name|getSource
argument_list|()
operator|==
name|clientSidePolicy
operator|&&
literal|"decoupledEndpoint"
operator|.
name|equals
argument_list|(
name|evt
operator|.
name|getPropertyName
argument_list|()
argument_list|)
condition|)
block|{
name|this
operator|.
name|endpointInfo
operator|.
name|setProperty
argument_list|(
literal|"org.apache.cxf.ws.addressing.replyto"
argument_list|,
name|evt
operator|.
name|getNewValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|handleHttpRetryException
parameter_list|(
name|HttpRetryException
name|e
parameter_list|,
name|HttpURLConnection
name|connection
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|msg
init|=
literal|"HTTP response '"
operator|+
name|e
operator|.
name|responseCode
argument_list|()
operator|+
literal|": "
operator|+
name|connection
operator|.
name|getResponseMessage
argument_list|()
operator|+
literal|"' invoking "
operator|+
name|connection
operator|.
name|getURL
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|e
operator|.
name|responseCode
argument_list|()
condition|)
block|{
case|case
name|HttpURLConnection
operator|.
name|HTTP_MOVED_PERM
case|:
comment|// 301
case|case
name|HttpURLConnection
operator|.
name|HTTP_MOVED_TEMP
case|:
comment|// 302
case|case
literal|307
case|:
name|msg
operator|+=
literal|" that returned location header '"
operator|+
name|e
operator|.
name|getLocation
argument_list|()
operator|+
literal|"'"
expr_stmt|;
break|break;
case|case
name|HttpURLConnection
operator|.
name|HTTP_UNAUTHORIZED
case|:
comment|// 401
if|if
condition|(
name|authorizationPolicy
operator|==
literal|null
operator|||
name|authorizationPolicy
operator|.
name|getUserName
argument_list|()
operator|==
literal|null
condition|)
block|{
name|msg
operator|+=
literal|" with NO authorization username configured in conduit "
operator|+
name|getConduitName
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|+=
literal|" with authorization username '"
operator|+
name|authorizationPolicy
operator|.
name|getUserName
argument_list|()
operator|+
literal|"'"
expr_stmt|;
block|}
break|break;
case|case
name|HttpURLConnection
operator|.
name|HTTP_PROXY_AUTH
case|:
comment|// 407
if|if
condition|(
name|proxyAuthorizationPolicy
operator|==
literal|null
operator|||
name|proxyAuthorizationPolicy
operator|.
name|getUserName
argument_list|()
operator|==
literal|null
condition|)
block|{
name|msg
operator|+=
literal|" with NO proxy authorization configured in conduit "
operator|+
name|getConduitName
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|+=
literal|" with proxy authorization username '"
operator|+
name|proxyAuthorizationPolicy
operator|.
name|getUserName
argument_list|()
operator|+
literal|"'"
expr_stmt|;
block|}
if|if
condition|(
name|clientSidePolicy
operator|==
literal|null
operator|||
name|clientSidePolicy
operator|.
name|getProxyServer
argument_list|()
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|connection
operator|.
name|usingProxy
argument_list|()
condition|)
block|{
name|msg
operator|+=
literal|" using a proxy even if NONE is configured in CXF conduit "
operator|+
name|getConduitName
argument_list|()
operator|+
literal|" (maybe one is configured by java.net.ProxySelector)"
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|+=
literal|" but NO proxy was used by the connection (none configured in cxf "
operator|+
literal|"conduit and none selected by java.net.ProxySelector)"
expr_stmt|;
block|}
block|}
else|else
block|{
name|msg
operator|+=
literal|" using "
operator|+
name|clientSidePolicy
operator|.
name|getProxyServerType
argument_list|()
operator|+
literal|" proxy "
operator|+
name|clientSidePolicy
operator|.
name|getProxyServer
argument_list|()
operator|+
literal|":"
operator|+
name|clientSidePolicy
operator|.
name|getProxyServerPort
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
comment|// No other type of HttpRetryException should be thrown
break|break;
block|}
comment|// pass cause with initCause() instead of constructor for jdk 1.5 compatibility
throw|throw
operator|(
name|IOException
operator|)
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
end_class

end_unit

