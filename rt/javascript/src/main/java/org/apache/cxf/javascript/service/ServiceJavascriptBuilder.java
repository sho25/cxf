begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements. See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|javascript
operator|.
name|service
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|namespace
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|soap
operator|.
name|SoapBindingConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|soap
operator|.
name|SoapBindingFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|soap
operator|.
name|SoapVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|soap
operator|.
name|model
operator|.
name|SoapBindingInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|common
operator|.
name|WSDLConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|common
operator|.
name|i18n
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|common
operator|.
name|logging
operator|.
name|LogUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|common
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|common
operator|.
name|xmlschema
operator|.
name|SchemaCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|common
operator|.
name|xmlschema
operator|.
name|XmlSchemaUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|javascript
operator|.
name|JavascriptUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|javascript
operator|.
name|NameManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|javascript
operator|.
name|NamespacePrefixAccumulator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|javascript
operator|.
name|ParticleInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|javascript
operator|.
name|UnsupportedConstruct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|service
operator|.
name|ServiceModelVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|service
operator|.
name|model
operator|.
name|BindingInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|service
operator|.
name|model
operator|.
name|EndpointInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|service
operator|.
name|model
operator|.
name|FaultInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|service
operator|.
name|model
operator|.
name|InterfaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|service
operator|.
name|model
operator|.
name|MessageInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|service
operator|.
name|model
operator|.
name|MessagePartInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|service
operator|.
name|model
operator|.
name|OperationInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|service
operator|.
name|model
operator|.
name|ServiceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|transport
operator|.
name|local
operator|.
name|LocalTransportFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchemaAny
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchemaComplexType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchemaElement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchemaObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchemaParticle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchemaSequence
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchemaSequenceMember
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchemaSimpleType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchemaType
import|;
end_import

begin_comment
comment|/**  * Class to construct the JavaScript corresponding to a service.  */
end_comment

begin_class
specifier|public
class|class
name|ServiceJavascriptBuilder
extends|extends
name|ServiceModelVisitor
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LogUtils
operator|.
name|getL7dLogger
argument_list|(
name|ServiceJavascriptBuilder
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|SoapBindingInfo
name|soapBindingInfo
decl_stmt|;
specifier|private
name|JavascriptUtils
name|utils
decl_stmt|;
specifier|private
name|NameManager
name|nameManager
decl_stmt|;
specifier|private
name|StringBuilder
name|code
decl_stmt|;
specifier|private
name|String
name|currentInterfaceClassName
decl_stmt|;
specifier|private
name|OperationInfo
name|currentOperation
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|OperationInfo
argument_list|>
name|operationsWithNameConflicts
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|MessageInfo
argument_list|>
name|inputMessagesWithNameConflicts
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|MessageInfo
argument_list|>
name|outputMessagesWithNameConflicts
decl_stmt|;
specifier|private
name|SchemaCollection
name|xmlSchemaCollection
decl_stmt|;
comment|// When generating from a tool or ?js, we know the endpoint addr and can build it into the javascript.
specifier|private
name|String
name|endpointAddress
decl_stmt|;
specifier|private
name|boolean
name|isWrapped
decl_stmt|;
comment|// facts about the wrapper when there is one.
specifier|private
name|MessagePartInfo
name|inputWrapperPartInfo
decl_stmt|;
specifier|private
name|String
name|inputWrapperClassName
decl_stmt|;
specifier|private
name|XmlSchemaElement
name|inputWrapperElement
decl_stmt|;
specifier|private
name|XmlSchemaComplexType
name|inputWrapperComplexType
decl_stmt|;
specifier|private
name|MessagePartInfo
name|outputWrapperPartInfo
decl_stmt|;
specifier|private
name|XmlSchemaElement
name|outputWrapperElement
decl_stmt|;
specifier|private
name|XmlSchemaComplexType
name|outputWrapperComplexType
decl_stmt|;
comment|// Javascript parameter names for the input parameters,
comment|// derived from the parts.
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|inputParameterNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// when not wrapped, we use this to keep track of the bits.
specifier|private
name|List
argument_list|<
name|ParticleInfo
argument_list|>
name|unwrappedElementsAndNames
decl_stmt|;
specifier|private
name|NamespacePrefixAccumulator
name|prefixAccumulator
decl_stmt|;
specifier|private
name|BindingInfo
name|xmlBindingInfo
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|OperationInfo
argument_list|>
name|localOperationsNameMap
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|MessageInfo
argument_list|>
name|localInputMessagesNameMap
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|MessageInfo
argument_list|>
name|localOutputMessagesNameMap
decl_stmt|;
specifier|private
name|String
name|opFunctionPropertyName
decl_stmt|;
specifier|private
name|String
name|opFunctionGlobalName
decl_stmt|;
specifier|private
name|boolean
name|isInUnwrappedOperation
decl_stmt|;
specifier|private
name|boolean
name|nonVoidOutput
decl_stmt|;
specifier|private
name|boolean
name|isRPC
decl_stmt|;
comment|/**      * Construct builder object.      * @param serviceInfo CXF service model description of the service.      * @param endpointAddress http:// URL for the service, or null if not known.      * @param prefixAccumulator object that keeps track of prefixes through an entire WSDL.      * @param nameManager object that generates names for JavaScript objects.      */
specifier|public
name|ServiceJavascriptBuilder
parameter_list|(
name|ServiceInfo
name|serviceInfo
parameter_list|,
name|String
name|endpointAddress
parameter_list|,
name|NamespacePrefixAccumulator
name|prefixAccumulator
parameter_list|,
name|NameManager
name|nameManager
parameter_list|)
block|{
name|super
argument_list|(
name|serviceInfo
argument_list|)
expr_stmt|;
name|this
operator|.
name|endpointAddress
operator|=
name|endpointAddress
expr_stmt|;
name|code
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
name|utils
operator|=
operator|new
name|JavascriptUtils
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|this
operator|.
name|nameManager
operator|=
name|nameManager
expr_stmt|;
name|xmlSchemaCollection
operator|=
name|serviceInfo
operator|.
name|getXmlSchemaCollection
argument_list|()
expr_stmt|;
name|this
operator|.
name|prefixAccumulator
operator|=
name|prefixAccumulator
expr_stmt|;
block|}
specifier|public
name|String
name|getCode
parameter_list|()
block|{
return|return
name|code
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|begin
parameter_list|(
name|FaultInfo
name|fault
parameter_list|)
block|{     }
annotation|@
name|Override
specifier|public
name|void
name|begin
parameter_list|(
name|InterfaceInfo
name|intf
parameter_list|)
block|{
name|code
operator|.
name|append
argument_list|(
literal|"\n// Javascript for "
operator|+
name|intf
operator|.
name|getName
argument_list|()
operator|+
literal|"\n\n"
argument_list|)
expr_stmt|;
name|currentInterfaceClassName
operator|=
name|nameManager
operator|.
name|getJavascriptName
argument_list|(
name|intf
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|operationsWithNameConflicts
operator|=
operator|new
name|HashSet
argument_list|<
name|OperationInfo
argument_list|>
argument_list|()
expr_stmt|;
name|inputMessagesWithNameConflicts
operator|=
operator|new
name|HashSet
argument_list|<
name|MessageInfo
argument_list|>
argument_list|()
expr_stmt|;
name|outputMessagesWithNameConflicts
operator|=
operator|new
name|HashSet
argument_list|<
name|MessageInfo
argument_list|>
argument_list|()
expr_stmt|;
name|localOperationsNameMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|OperationInfo
argument_list|>
argument_list|()
expr_stmt|;
name|localInputMessagesNameMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|MessageInfo
argument_list|>
argument_list|()
expr_stmt|;
name|localOutputMessagesNameMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|MessageInfo
argument_list|>
argument_list|()
expr_stmt|;
name|code
operator|.
name|append
argument_list|(
literal|"function "
operator|+
name|currentInterfaceClassName
operator|+
literal|" () {\n"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.jsutils = new CxfApacheOrgUtil();"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.jsutils.interfaceObject = this;"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.synchronous = false;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|endpointAddress
operator|!=
literal|null
condition|)
block|{
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.url = '"
operator|+
name|endpointAddress
operator|+
literal|"';"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.url = null;"
argument_list|)
expr_stmt|;
block|}
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.client = null;"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.response = null;"
argument_list|)
expr_stmt|;
name|generateGlobalElementDictionary
argument_list|()
expr_stmt|;
name|code
operator|.
name|append
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|generateGlobalElementDictionary
parameter_list|()
block|{
comment|// to handle 'any', we need a dictionary of all the global elements of all the schemas.
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.globalElementSerializers = [];"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.globalElementDeserializers = [];"
argument_list|)
expr_stmt|;
for|for
control|(
name|XmlSchema
name|schemaInfo
range|:
name|xmlSchemaCollection
operator|.
name|getXmlSchemas
argument_list|()
control|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|QName
argument_list|,
name|XmlSchemaElement
argument_list|>
name|e
range|:
name|schemaInfo
operator|.
name|getElements
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|QName
name|name
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|XmlSchemaElement
name|element
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// For now, at least, don't handle elements with simple types.
comment|// That comes later to improve deserialization.
if|if
condition|(
name|JavascriptUtils
operator|.
name|notVeryComplexType
argument_list|(
name|element
operator|.
name|getSchemaType
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// If the element uses a named type, we use the functions for the type.
name|XmlSchemaComplexType
name|elementType
init|=
operator|(
name|XmlSchemaComplexType
operator|)
name|element
operator|.
name|getSchemaType
argument_list|()
decl_stmt|;
if|if
condition|(
name|elementType
operator|!=
literal|null
operator|&&
name|elementType
operator|.
name|getQName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|name
operator|=
name|elementType
operator|.
name|getQName
argument_list|()
expr_stmt|;
block|}
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.globalElementSerializers['"
operator|+
name|name
operator|.
name|toString
argument_list|()
operator|+
literal|"'] = "
operator|+
name|nameManager
operator|.
name|getJavascriptName
argument_list|(
name|name
argument_list|)
operator|+
literal|"_serialize;"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.globalElementDeserializers['"
operator|+
name|name
operator|.
name|toString
argument_list|()
operator|+
literal|"'] = "
operator|+
name|nameManager
operator|.
name|getJavascriptName
argument_list|(
name|name
argument_list|)
operator|+
literal|"_deserialize;"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|QName
argument_list|,
name|XmlSchemaType
argument_list|>
name|e
range|:
name|schemaInfo
operator|.
name|getSchemaTypes
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|QName
name|name
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|XmlSchemaType
name|type
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// For now, at least, don't handle simple types.
if|if
condition|(
name|JavascriptUtils
operator|.
name|notVeryComplexType
argument_list|(
name|type
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// the names are misleading, but that's OK.
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.globalElementSerializers['"
operator|+
name|name
operator|.
name|toString
argument_list|()
operator|+
literal|"'] = "
operator|+
name|nameManager
operator|.
name|getJavascriptName
argument_list|(
name|name
argument_list|)
operator|+
literal|"_serialize;"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.globalElementDeserializers['"
operator|+
name|name
operator|.
name|toString
argument_list|()
operator|+
literal|"'] = "
operator|+
name|nameManager
operator|.
name|getJavascriptName
argument_list|(
name|name
argument_list|)
operator|+
literal|"_deserialize;"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|String
name|getFunctionGlobalName
parameter_list|(
name|QName
name|itemName
parameter_list|,
name|String
name|itemType
parameter_list|)
block|{
return|return
name|nameManager
operator|.
name|getJavascriptName
argument_list|(
name|itemName
argument_list|)
operator|+
literal|"_"
operator|+
name|itemType
return|;
block|}
specifier|private
parameter_list|<
name|T
parameter_list|>
name|String
name|getFunctionPropertyName
parameter_list|(
name|Set
argument_list|<
name|T
argument_list|>
name|conflictMap
parameter_list|,
name|T
name|object
parameter_list|,
name|QName
name|fullName
parameter_list|)
block|{
name|boolean
name|needsLongName
init|=
name|conflictMap
operator|.
name|contains
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|String
name|functionName
decl_stmt|;
if|if
condition|(
name|needsLongName
condition|)
block|{
name|functionName
operator|=
name|nameManager
operator|.
name|getJavascriptName
argument_list|(
name|fullName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|functionName
operator|=
name|JavascriptUtils
operator|.
name|javaScriptNameToken
argument_list|(
name|fullName
operator|.
name|getLocalPart
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|functionName
return|;
block|}
comment|// we do this at the end so we can inventory name conflicts sooner.
annotation|@
name|Override
specifier|public
name|void
name|end
parameter_list|(
name|OperationInfo
name|op
parameter_list|)
block|{
comment|// we only process the wrapped operation, not the unwrapped alternative.
if|if
condition|(
name|op
operator|.
name|isUnwrapped
argument_list|()
condition|)
block|{
name|isInUnwrappedOperation
operator|=
literal|false
expr_stmt|;
return|return;
block|}
name|isWrapped
operator|=
name|op
operator|.
name|isUnwrappedCapable
argument_list|()
expr_stmt|;
name|StringBuilder
name|parameterList
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|inputParameterNames
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|isWrapped
condition|)
block|{
name|collectWrapperElementInfo
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|collectUnwrappedInputInfo
argument_list|()
expr_stmt|;
block|}
name|buildParameterList
argument_list|(
name|parameterList
argument_list|)
expr_stmt|;
name|MessageInfo
name|outputMessage
init|=
name|op
operator|.
name|getOutput
argument_list|()
decl_stmt|;
name|nonVoidOutput
operator|=
name|outputMessage
operator|!=
literal|null
operator|&&
name|outputMessage
operator|.
name|getMessageParts
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|op
operator|.
name|isOneWay
argument_list|()
condition|)
block|{
name|buildSuccessFunction
argument_list|(
name|outputMessage
argument_list|)
expr_stmt|;
name|buildErrorFunction
argument_list|()
expr_stmt|;
comment|// fault part some day.
block|}
name|buildOperationFunction
argument_list|(
name|parameterList
argument_list|)
expr_stmt|;
name|createInputSerializer
argument_list|()
expr_stmt|;
if|if
condition|(
name|nonVoidOutput
condition|)
block|{
name|createResponseDeserializer
argument_list|(
name|outputMessage
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * visit the input message parts and collect relevant data.      */
specifier|private
name|void
name|collectUnwrappedInputInfo
parameter_list|()
block|{
name|unwrappedElementsAndNames
operator|=
operator|new
name|ArrayList
argument_list|<
name|ParticleInfo
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentOperation
operator|.
name|getInput
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|getElementsForParts
argument_list|(
name|currentOperation
operator|.
name|getInput
argument_list|()
argument_list|,
name|unwrappedElementsAndNames
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ParticleInfo
name|ean
range|:
name|unwrappedElementsAndNames
control|)
block|{
name|inputParameterNames
operator|.
name|add
argument_list|(
name|ean
operator|.
name|getJavascriptName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|buildOperationFunction
parameter_list|(
name|StringBuilder
name|parameterList
parameter_list|)
block|{
name|String
name|responseCallbackParams
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|!
name|currentOperation
operator|.
name|isOneWay
argument_list|()
condition|)
block|{
name|responseCallbackParams
operator|=
literal|"successCallback, errorCallback"
expr_stmt|;
block|}
name|MessageInfo
name|inputMessage
init|=
name|currentOperation
operator|.
name|getInput
argument_list|()
decl_stmt|;
name|code
operator|.
name|append
argument_list|(
literal|"//\n"
argument_list|)
expr_stmt|;
name|code
operator|.
name|append
argument_list|(
literal|"// Operation "
operator|+
name|currentOperation
operator|.
name|getName
argument_list|()
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isWrapped
condition|)
block|{
name|code
operator|.
name|append
argument_list|(
literal|"// - bare operation. Parameters:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ParticleInfo
name|ei
range|:
name|unwrappedElementsAndNames
control|)
block|{
name|code
operator|.
name|append
argument_list|(
literal|"// - "
operator|+
name|getElementObjectName
argument_list|(
name|ei
argument_list|)
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|code
operator|.
name|append
argument_list|(
literal|"// Wrapped operation.\n"
argument_list|)
expr_stmt|;
name|QName
name|contextQName
init|=
name|inputWrapperComplexType
operator|.
name|getQName
argument_list|()
decl_stmt|;
if|if
condition|(
name|contextQName
operator|==
literal|null
condition|)
block|{
name|contextQName
operator|=
name|inputWrapperElement
operator|.
name|getQName
argument_list|()
expr_stmt|;
block|}
name|XmlSchemaSequence
name|sequence
init|=
name|XmlSchemaUtils
operator|.
name|getSequence
argument_list|(
name|inputWrapperComplexType
argument_list|)
decl_stmt|;
name|XmlSchema
name|wrapperSchema
init|=
name|xmlSchemaCollection
operator|.
name|getSchemaByTargetNamespace
argument_list|(
name|contextQName
operator|.
name|getNamespaceURI
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sequence
operator|.
name|getItems
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|code
operator|.
name|append
argument_list|(
literal|"// parameter "
operator|+
name|inputParameterNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|XmlSchemaSequenceMember
name|sequenceItem
init|=
name|sequence
operator|.
name|getItems
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ParticleInfo
name|itemInfo
init|=
name|ParticleInfo
operator|.
name|forLocalItem
argument_list|(
operator|(
name|XmlSchemaObject
operator|)
name|sequenceItem
argument_list|,
name|wrapperSchema
argument_list|,
name|xmlSchemaCollection
argument_list|,
name|prefixAccumulator
argument_list|,
name|contextQName
argument_list|)
decl_stmt|;
if|if
condition|(
name|itemInfo
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|code
operator|.
name|append
argument_list|(
literal|"// - array\n"
argument_list|)
expr_stmt|;
block|}
name|XmlSchemaType
name|type
init|=
name|itemInfo
operator|.
name|getType
argument_list|()
decl_stmt|;
comment|// null for an any.
if|if
condition|(
name|type
operator|instanceof
name|XmlSchemaComplexType
condition|)
block|{
name|QName
name|baseName
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|getQName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|baseName
operator|=
name|type
operator|.
name|getQName
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|baseName
operator|=
operator|(
operator|(
name|XmlSchemaElement
operator|)
name|sequenceItem
operator|)
operator|.
name|getQName
argument_list|()
expr_stmt|;
block|}
name|code
operator|.
name|append
argument_list|(
literal|"// - Object constructor is "
operator|+
name|nameManager
operator|.
name|getJavascriptName
argument_list|(
name|baseName
argument_list|)
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
name|code
operator|.
name|append
argument_list|(
literal|"// - simple type "
operator|+
name|type
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|code
operator|.
name|append
argument_list|(
literal|"//\n"
argument_list|)
expr_stmt|;
name|code
operator|.
name|append
argument_list|(
literal|"function "
operator|+
name|opFunctionGlobalName
operator|+
literal|"("
operator|+
name|responseCallbackParams
operator|+
operator|(
operator|(
name|parameterList
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|currentOperation
operator|.
name|isOneWay
argument_list|()
operator|)
condition|?
literal|", "
else|:
literal|""
operator|)
operator|+
name|parameterList
operator|+
literal|") {\n"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.client = new CxfApacheOrgClient(this.jsutils);"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"var xml = null;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputMessage
operator|!=
literal|null
condition|)
block|{
name|utils
operator|.
name|appendLine
argument_list|(
literal|"var args = new Array("
operator|+
name|inputParameterNames
operator|.
name|size
argument_list|()
operator|+
literal|");"
argument_list|)
expr_stmt|;
name|int
name|px
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|param
range|:
name|inputParameterNames
control|)
block|{
name|utils
operator|.
name|appendLine
argument_list|(
literal|"args["
operator|+
name|px
operator|+
literal|"] = "
operator|+
name|param
operator|+
literal|";"
argument_list|)
expr_stmt|;
name|px
operator|++
expr_stmt|;
block|}
name|utils
operator|.
name|appendLine
argument_list|(
literal|"xml = this."
operator|+
name|getFunctionPropertyName
argument_list|(
name|inputMessagesWithNameConflicts
argument_list|,
name|inputMessage
argument_list|,
name|inputMessage
operator|.
name|getName
argument_list|()
argument_list|)
operator|+
literal|"_serializeInput"
operator|+
literal|"(this.jsutils, args);"
argument_list|)
expr_stmt|;
block|}
comment|// we need to pass the caller's callback functions to our callback
comment|// functions.
if|if
condition|(
operator|!
name|currentOperation
operator|.
name|isOneWay
argument_list|()
condition|)
block|{
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.client.user_onsuccess = successCallback;"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.client.user_onerror = errorCallback;"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"var closureThis = this;"
argument_list|)
expr_stmt|;
comment|// client will pass itself and the response XML.
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.client.onsuccess = function(client, responseXml) { closureThis."
operator|+
name|opFunctionPropertyName
operator|+
literal|"_onsuccess(client, responseXml); };"
argument_list|)
expr_stmt|;
comment|// client will pass itself.
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.client.onerror = function(client) { closureThis."
operator|+
name|opFunctionPropertyName
operator|+
literal|"_onerror(client); };"
argument_list|)
expr_stmt|;
block|}
name|utils
operator|.
name|appendLine
argument_list|(
literal|"var requestHeaders = [];"
argument_list|)
expr_stmt|;
if|if
condition|(
name|soapBindingInfo
operator|!=
literal|null
condition|)
block|{
name|String
name|action
init|=
name|soapBindingInfo
operator|.
name|getSoapAction
argument_list|(
name|currentOperation
argument_list|)
decl_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"requestHeaders['SOAPAction'] = '"
operator|+
name|action
operator|+
literal|"';"
argument_list|)
expr_stmt|;
block|}
comment|// default 'method' by passing null. Is there some place this lives in the
comment|// service model?
name|String
name|syncAsyncFlag
decl_stmt|;
if|if
condition|(
name|currentOperation
operator|.
name|isOneWay
argument_list|()
condition|)
block|{
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.jsutils.trace('oneway operation');"
argument_list|)
expr_stmt|;
name|syncAsyncFlag
operator|=
literal|"false"
expr_stmt|;
block|}
else|else
block|{
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.jsutils.trace('synchronous = ' + this.synchronous);"
argument_list|)
expr_stmt|;
name|syncAsyncFlag
operator|=
literal|"this.synchronous"
expr_stmt|;
block|}
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.client.request(this.url, xml, null, "
operator|+
name|syncAsyncFlag
operator|+
literal|", requestHeaders);"
argument_list|)
expr_stmt|;
name|code
operator|.
name|append
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
name|code
operator|.
name|append
argument_list|(
name|currentInterfaceClassName
operator|+
literal|".prototype."
operator|+
name|opFunctionPropertyName
operator|+
literal|" = "
operator|+
name|opFunctionGlobalName
operator|+
literal|";\n\n"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|buildErrorFunction
parameter_list|()
block|{
name|String
name|errorFunctionPropertyName
init|=
name|opFunctionPropertyName
operator|+
literal|"_onerror"
decl_stmt|;
name|String
name|errorFunctionGlobalName
init|=
name|opFunctionGlobalName
operator|+
literal|"_onerror"
decl_stmt|;
name|code
operator|.
name|append
argument_list|(
literal|"function "
operator|+
name|errorFunctionGlobalName
operator|+
literal|"(client) {\n"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|startIf
argument_list|(
literal|"client.user_onerror"
argument_list|)
expr_stmt|;
comment|// Is this a good set of parameters for the error function?
comment|// Not if we want to process faults, it isn't. To be revisited.
name|utils
operator|.
name|appendLine
argument_list|(
literal|"var httpStatus;"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"var httpStatusText;"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"try {"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|" httpStatus = client.req.status;"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|" httpStatusText = client.req.statusText;"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"} catch(e) {"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|" httpStatus = -1;"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|" httpStatusText = 'Error opening connection to server';"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"client.user_onerror(httpStatus, httpStatusText);"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|endBlock
argument_list|()
expr_stmt|;
name|code
operator|.
name|append
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
name|code
operator|.
name|append
argument_list|(
name|currentInterfaceClassName
operator|+
literal|".prototype."
operator|+
name|errorFunctionPropertyName
operator|+
literal|" = "
operator|+
name|errorFunctionGlobalName
operator|+
literal|";\n\n"
argument_list|)
expr_stmt|;
block|}
comment|// Note: the response XML that we get from the XMLHttpRequest is the document element,
comment|// not the root element.
specifier|private
name|void
name|buildSuccessFunction
parameter_list|(
name|MessageInfo
name|outputMessage
parameter_list|)
block|{
comment|// Here are the success and error callbacks. They have the job of
comment|// calling callbacks provided to the operation function with appropriate
comment|// parameters.
name|String
name|successFunctionGlobalName
init|=
name|opFunctionGlobalName
operator|+
literal|"_onsuccess"
decl_stmt|;
name|String
name|successFunctionPropertyName
init|=
name|opFunctionPropertyName
operator|+
literal|"_onsuccess"
decl_stmt|;
name|String
name|arglist
init|=
literal|"(client)"
decl_stmt|;
if|if
condition|(
name|nonVoidOutput
condition|)
block|{
name|arglist
operator|=
literal|"(client, responseXml)"
expr_stmt|;
block|}
name|code
operator|.
name|append
argument_list|(
literal|"function "
operator|+
name|successFunctionGlobalName
operator|+
name|arglist
operator|+
literal|" {\n"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|startIf
argument_list|(
literal|"client.user_onsuccess"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"var responseObject = null;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonVoidOutput
condition|)
block|{
name|utils
operator|.
name|appendLine
argument_list|(
literal|"var element = responseXml.documentElement;"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.jsutils.trace('responseXml: ' "
operator|+
literal|"+ this.jsutils.traceElementName(element));"
argument_list|)
expr_stmt|;
if|if
condition|(
name|soapBindingInfo
operator|!=
literal|null
condition|)
block|{
comment|// soap
comment|// The following code is probably only right for basic
comment|// Doc/Literal/Wrapped services.
comment|// the top element should be the Envelope, then the Body, then
comment|// the actual response item.
name|utils
operator|.
name|appendLine
argument_list|(
literal|"element = this.jsutils.getFirstElementChild(element);"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.jsutils.trace('first element child: ' "
operator|+
literal|"+ this.jsutils.traceElementName(element));"
argument_list|)
expr_stmt|;
comment|// loop to find the body.
name|utils
operator|.
name|startWhile
argument_list|(
literal|"!this.jsutils.isNodeNamedNS(element, "
operator|+
literal|"'http://schemas.xmlsoap.org/soap/envelope/', 'Body')"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"element = this.jsutils.getNextElementSibling(element);"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|startIf
argument_list|(
literal|"element == null"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"throw 'No env:Body in message.'"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|endBlock
argument_list|()
expr_stmt|;
name|utils
operator|.
name|endBlock
argument_list|()
expr_stmt|;
comment|// Go down one more from the body to the response item.
name|utils
operator|.
name|appendLine
argument_list|(
literal|"element = this.jsutils.getFirstElementChild(element);"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.jsutils.trace('part element: ' "
operator|+
literal|"+ this.jsutils.traceElementName(element));"
argument_list|)
expr_stmt|;
block|}
name|String
name|deserializerFunctionName
init|=
name|outputDeserializerFunctionName
argument_list|(
name|outputMessage
argument_list|)
decl_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"this.jsutils.trace('calling "
operator|+
name|deserializerFunctionName
operator|+
literal|"');"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"responseObject = "
operator|+
name|deserializerFunctionName
operator|+
literal|"(this.jsutils, element);"
argument_list|)
expr_stmt|;
block|}
name|utils
operator|.
name|appendLine
argument_list|(
literal|"client.user_onsuccess(responseObject);"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|endBlock
argument_list|()
expr_stmt|;
name|code
operator|.
name|append
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
name|code
operator|.
name|append
argument_list|(
name|currentInterfaceClassName
operator|+
literal|".prototype."
operator|+
name|successFunctionPropertyName
operator|+
literal|" = "
operator|+
name|successFunctionGlobalName
operator|+
literal|";\n\n"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|buildParameterList
parameter_list|(
name|StringBuilder
name|parameterList
parameter_list|)
block|{
for|for
control|(
name|String
name|param
range|:
name|inputParameterNames
control|)
block|{
name|parameterList
operator|.
name|append
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|parameterList
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
comment|// trim last comma.
if|if
condition|(
name|parameterList
operator|.
name|length
argument_list|()
operator|>
literal|2
condition|)
block|{
name|parameterList
operator|.
name|setLength
argument_list|(
name|parameterList
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|String
name|outputDeserializerFunctionName
parameter_list|(
name|MessageInfo
name|message
parameter_list|)
block|{
return|return
name|getFunctionGlobalName
argument_list|(
name|message
operator|.
name|getName
argument_list|()
argument_list|,
literal|"deserializeResponse"
argument_list|)
return|;
block|}
comment|// This ignores 'wrapped', because it assumes one part that we can use one way or
comment|// the other. For simple cases, this is certainly OK.
specifier|private
name|void
name|createResponseDeserializer
parameter_list|(
name|MessageInfo
name|outputMessage
parameter_list|)
block|{
name|List
argument_list|<
name|MessagePartInfo
argument_list|>
name|parts
init|=
name|outputMessage
operator|.
name|getMessageParts
argument_list|()
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|unsupportedConstruct
argument_list|(
literal|"MULTIPLE_OUTPUTS"
argument_list|,
name|outputMessage
operator|.
name|getName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|ParticleInfo
argument_list|>
name|elements
init|=
operator|new
name|ArrayList
argument_list|<
name|ParticleInfo
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|functionName
init|=
name|outputDeserializerFunctionName
argument_list|(
name|outputMessage
argument_list|)
decl_stmt|;
name|code
operator|.
name|append
argument_list|(
literal|"function "
operator|+
name|functionName
operator|+
literal|"(cxfjsutils, partElement) {\n"
argument_list|)
expr_stmt|;
name|getElementsForParts
argument_list|(
name|outputMessage
argument_list|,
name|elements
argument_list|)
expr_stmt|;
name|ParticleInfo
name|element
init|=
name|elements
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|XmlSchemaType
name|type
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isRPC
condition|)
block|{
name|utils
operator|.
name|appendLine
argument_list|(
literal|"cxfjsutils.trace('rpc element: ' + cxfjsutils.traceElementName(partElement));"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"partElement = cxfjsutils.getFirstElementChild(partElement);"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"cxfjsutils.trace('rpc element: ' + cxfjsutils.traceElementName(partElement));"
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|element
operator|.
name|getType
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|element
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|type
operator|instanceof
name|XmlSchemaComplexType
condition|)
block|{
name|String
name|typeObjectName
init|=
name|nameManager
operator|.
name|getJavascriptName
argument_list|(
name|element
operator|.
name|getControllingName
argument_list|()
argument_list|)
decl_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"var returnObject = "
operator|+
name|typeObjectName
operator|+
literal|"_deserialize (cxfjsutils, partElement);\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|XmlSchemaSimpleType
condition|)
block|{
name|XmlSchemaSimpleType
name|simpleType
init|=
operator|(
name|XmlSchemaSimpleType
operator|)
name|type
decl_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"var returnText = cxfjsutils.getNodeText(partElement);"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"var returnObject = "
operator|+
name|utils
operator|.
name|javascriptParseExpression
argument_list|(
name|simpleType
argument_list|,
literal|"returnText"
argument_list|)
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
name|utils
operator|.
name|appendLine
argument_list|(
literal|"return returnObject;"
argument_list|)
expr_stmt|;
block|}
name|code
operator|.
name|append
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|String
name|getElementObjectName
parameter_list|(
name|ParticleInfo
name|element
parameter_list|)
block|{
name|XmlSchemaType
name|type
init|=
name|element
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|element
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|type
operator|instanceof
name|XmlSchemaComplexType
condition|)
block|{
return|return
name|nameManager
operator|.
name|getJavascriptName
argument_list|(
name|element
operator|.
name|getControllingName
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|"type "
operator|+
name|type
operator|.
name|getQName
argument_list|()
return|;
comment|// could it be anonymous?
block|}
block|}
else|else
block|{
return|return
literal|"empty element?"
return|;
block|}
block|}
specifier|private
name|void
name|createInputSerializer
parameter_list|()
block|{
comment|// If are working on a wrapped method, then we use the wrapper element.
comment|// If we are working on an unwrapped method, we will have to work from the unwrapped parts.
name|MessageInfo
name|message
init|=
name|currentOperation
operator|.
name|getInput
argument_list|()
decl_stmt|;
name|String
name|serializerFunctionGlobalName
init|=
name|getFunctionGlobalName
argument_list|(
name|message
operator|.
name|getName
argument_list|()
argument_list|,
literal|"serializeInput"
argument_list|)
decl_stmt|;
name|String
name|serializerFunctionPropertyName
init|=
name|getFunctionPropertyName
argument_list|(
name|inputMessagesWithNameConflicts
argument_list|,
name|message
argument_list|,
name|message
operator|.
name|getName
argument_list|()
argument_list|)
operator|+
literal|"_serializeInput"
decl_stmt|;
name|code
operator|.
name|append
argument_list|(
literal|"function "
operator|+
name|serializerFunctionGlobalName
operator|+
literal|"(cxfjsutils, args) {\n"
argument_list|)
expr_stmt|;
name|String
name|wrapperXmlElementName
init|=
literal|null
decl_stmt|;
comment|// for the wrapped case, we can name the object for Javascript after whatever we like.
comment|// we could use the wrapped part, or we could use a conventional name.
if|if
condition|(
name|isWrapped
condition|)
block|{
name|wrapperXmlElementName
operator|=
name|prefixAccumulator
operator|.
name|xmlElementString
argument_list|(
name|inputWrapperPartInfo
operator|.
name|getConcreteName
argument_list|()
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"var wrapperObj = new "
operator|+
name|inputWrapperClassName
operator|+
literal|"();"
argument_list|)
expr_stmt|;
name|int
name|px
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|param
range|:
name|inputParameterNames
control|)
block|{
name|utils
operator|.
name|appendLine
argument_list|(
literal|"wrapperObj.set"
operator|+
name|StringUtils
operator|.
name|capitalize
argument_list|(
name|param
argument_list|)
operator|+
literal|"(args["
operator|+
name|px
operator|+
literal|"]);"
argument_list|)
expr_stmt|;
name|px
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|soapBindingInfo
operator|!=
literal|null
condition|)
block|{
name|SoapVersion
name|soapVersion
init|=
name|soapBindingInfo
operator|.
name|getSoapVersion
argument_list|()
decl_stmt|;
assert|assert
name|soapVersion
operator|.
name|getVersion
argument_list|()
operator|==
literal|1.1
assert|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"var xml;"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"xml = cxfjsutils.beginSoap11Message(\""
operator|+
name|prefixAccumulator
operator|.
name|getAttributes
argument_list|()
operator|+
literal|"\");"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// other alternative is XML, which isn't really all here yet.
name|unsupportedConstruct
argument_list|(
literal|"XML_BINDING"
argument_list|,
name|currentInterfaceClassName
argument_list|,
name|xmlBindingInfo
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|utils
operator|.
name|setXmlStringAccumulator
argument_list|(
literal|"xml"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isWrapped
condition|)
block|{
name|ParticleInfo
name|elementInfo
init|=
name|ParticleInfo
operator|.
name|forPartElement
argument_list|(
name|inputWrapperElement
argument_list|,
name|xmlSchemaCollection
argument_list|,
literal|"wrapperObj"
argument_list|,
name|wrapperXmlElementName
argument_list|)
decl_stmt|;
name|elementInfo
operator|.
name|setContainingType
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|utils
operator|.
name|generateCodeToSerializeElement
argument_list|(
name|elementInfo
argument_list|,
literal|""
argument_list|,
name|xmlSchemaCollection
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|operationXmlElement
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isRPC
condition|)
block|{
name|operationXmlElement
operator|=
name|prefixAccumulator
operator|.
name|xmlElementString
argument_list|(
name|currentOperation
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// RPC has a level of element for the entire operation.
comment|// we might have some schema to model this, but the following seems
comment|// sufficient.
name|utils
operator|.
name|appendString
argument_list|(
literal|"<"
operator|+
name|operationXmlElement
operator|+
literal|">"
argument_list|)
expr_stmt|;
block|}
name|int
name|px
init|=
literal|0
decl_stmt|;
comment|// Multiple parts for document violates WS-I, but we can still do them.
comment|// They are normal for RPC.
comment|// Parts are top-level elements. As such, they cannot, directly, be arrays.
comment|// If a part is declared as an array type, the schema has a non-array element
comment|// with a complex type consisting of an element with array bounds. We don't
comment|// want the JavasSript programmer to have to concoct an extra level of object
comment|// (though if the same sort of thing happens elsewhere due to an XmlRootElement,
comment|// the JavaScript programmer is stuck with the situation).
for|for
control|(
name|ParticleInfo
name|ean
range|:
name|unwrappedElementsAndNames
control|)
block|{
name|String
name|savedjsName
init|=
name|ean
operator|.
name|getJavascriptName
argument_list|()
decl_stmt|;
try|try
block|{
name|ean
operator|.
name|setJavascriptName
argument_list|(
literal|"args["
operator|+
name|px
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|generateCodeToSerializeElement
argument_list|(
name|ean
argument_list|,
literal|""
argument_list|,
name|xmlSchemaCollection
argument_list|)
expr_stmt|;
name|px
operator|++
expr_stmt|;
block|}
finally|finally
block|{
name|ean
operator|.
name|setJavascriptName
argument_list|(
name|savedjsName
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isRPC
condition|)
block|{
name|utils
operator|.
name|appendString
argument_list|(
literal|"</"
operator|+
name|operationXmlElement
operator|+
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
name|utils
operator|.
name|appendLine
argument_list|(
literal|"xml = xml + cxfjsutils.endSoap11Message();"
argument_list|)
expr_stmt|;
name|utils
operator|.
name|appendLine
argument_list|(
literal|"return xml;"
argument_list|)
expr_stmt|;
name|code
operator|.
name|append
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
name|code
operator|.
name|append
argument_list|(
name|currentInterfaceClassName
operator|+
literal|".prototype."
operator|+
name|serializerFunctionPropertyName
operator|+
literal|" = "
operator|+
name|serializerFunctionGlobalName
operator|+
literal|";\n\n"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|XmlSchemaSequence
name|getTypeSequence
parameter_list|(
name|XmlSchemaComplexType
name|type
parameter_list|,
name|QName
name|parentName
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|type
operator|.
name|getParticle
argument_list|()
operator|instanceof
name|XmlSchemaSequence
operator|)
condition|)
block|{
name|unsupportedConstruct
argument_list|(
literal|"NON_SEQUENCE_PARTICLE"
argument_list|,
name|type
operator|.
name|getQName
argument_list|()
operator|!=
literal|null
condition|?
name|type
operator|.
name|getQName
argument_list|()
else|:
name|parentName
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|XmlSchemaSequence
operator|)
name|type
operator|.
name|getParticle
argument_list|()
return|;
block|}
specifier|private
name|boolean
name|isEmptyType
parameter_list|(
name|XmlSchemaType
name|type
parameter_list|,
name|QName
name|parentName
parameter_list|)
block|{
if|if
condition|(
name|type
operator|instanceof
name|XmlSchemaComplexType
condition|)
block|{
name|XmlSchemaComplexType
name|complexType
init|=
operator|(
name|XmlSchemaComplexType
operator|)
name|type
decl_stmt|;
if|if
condition|(
name|complexType
operator|.
name|getParticle
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
name|XmlSchemaSequence
name|sequence
init|=
name|getTypeSequence
argument_list|(
name|complexType
argument_list|,
name|parentName
argument_list|)
decl_stmt|;
if|if
condition|(
name|sequence
operator|.
name|getItems
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|XmlSchemaParticle
name|getBuriedElement
parameter_list|(
name|XmlSchemaComplexType
name|type
parameter_list|,
name|QName
name|parentName
parameter_list|)
block|{
name|XmlSchemaSequence
name|sequence
init|=
name|getTypeSequence
argument_list|(
name|type
argument_list|,
name|parentName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|XmlSchemaSequenceMember
argument_list|>
name|insides
init|=
name|sequence
operator|.
name|getItems
argument_list|()
decl_stmt|;
if|if
condition|(
name|insides
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|XmlSchemaSequenceMember
name|item
init|=
name|insides
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|instanceof
name|XmlSchemaElement
operator|||
name|item
operator|instanceof
name|XmlSchemaAny
condition|)
block|{
return|return
operator|(
name|XmlSchemaParticle
operator|)
name|item
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Collect information about the parts of an unwrapped message.      * @param parts      * @param elements      */
specifier|private
name|void
name|getElementsForParts
parameter_list|(
name|MessageInfo
name|message
parameter_list|,
name|List
argument_list|<
name|ParticleInfo
argument_list|>
name|elements
parameter_list|)
block|{
for|for
control|(
name|MessagePartInfo
name|mpi
range|:
name|message
operator|.
name|getMessageParts
argument_list|()
control|)
block|{
name|XmlSchemaElement
name|element
init|=
literal|null
decl_stmt|;
name|XmlSchemaType
name|type
init|=
literal|null
decl_stmt|;
name|QName
name|diagnosticName
init|=
name|mpi
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|mpi
operator|.
name|isElement
argument_list|()
condition|)
block|{
name|element
operator|=
operator|(
name|XmlSchemaElement
operator|)
name|mpi
operator|.
name|getXmlSchema
argument_list|()
expr_stmt|;
if|if
condition|(
name|element
operator|==
literal|null
condition|)
block|{
name|element
operator|=
name|XmlSchemaUtils
operator|.
name|findElementByRefName
argument_list|(
name|xmlSchemaCollection
argument_list|,
name|mpi
operator|.
name|getElementQName
argument_list|()
argument_list|,
name|serviceInfo
operator|.
name|getTargetNamespace
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|diagnosticName
operator|=
name|element
operator|.
name|getQName
argument_list|()
expr_stmt|;
name|type
operator|=
name|element
operator|.
name|getSchemaType
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
name|type
operator|=
name|XmlSchemaUtils
operator|.
name|getElementType
argument_list|(
name|xmlSchemaCollection
argument_list|,
literal|null
argument_list|,
name|element
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// RPC (!isElement)
name|type
operator|=
operator|(
name|XmlSchemaType
operator|)
name|mpi
operator|.
name|getXmlSchema
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
name|type
operator|=
name|xmlSchemaCollection
operator|.
name|getTypeByQName
argument_list|(
name|mpi
operator|.
name|getTypeQName
argument_list|()
argument_list|)
expr_stmt|;
name|diagnosticName
operator|=
name|type
operator|.
name|getQName
argument_list|()
expr_stmt|;
block|}
block|}
name|boolean
name|empty
init|=
name|isEmptyType
argument_list|(
name|type
argument_list|,
name|diagnosticName
argument_list|)
decl_stmt|;
comment|// There's something funny about doc/bare. Since it's doc, there is no
comment|// element in the part. There is a type. However, for some reason,
comment|// it tends to be an anonymous complex type containing an element, and that
comment|// element corresponds to the type of the parameter. So, we refocus on that.
if|if
condition|(
operator|!
name|empty
operator|&&
name|type
operator|instanceof
name|XmlSchemaComplexType
operator|&&
name|type
operator|.
name|getName
argument_list|()
operator|==
literal|null
operator|&&
operator|!
name|isWrapped
condition|)
block|{
name|XmlSchemaParticle
name|betterElement
init|=
name|getBuriedElement
argument_list|(
operator|(
name|XmlSchemaComplexType
operator|)
name|type
argument_list|,
name|diagnosticName
argument_list|)
decl_stmt|;
if|if
condition|(
name|betterElement
operator|instanceof
name|XmlSchemaElement
condition|)
block|{
name|element
operator|=
operator|(
name|XmlSchemaElement
operator|)
name|betterElement
expr_stmt|;
if|if
condition|(
name|element
operator|.
name|getSchemaType
argument_list|()
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|element
operator|.
name|getSchemaTypeName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|element
operator|.
name|setSchemaType
argument_list|(
name|xmlSchemaCollection
operator|.
name|getTypeByQName
argument_list|(
name|element
operator|.
name|getSchemaTypeName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|.
name|getRef
argument_list|()
operator|.
name|getTargetQName
argument_list|()
operator|!=
literal|null
operator|&&
name|element
operator|.
name|getRef
argument_list|()
operator|.
name|getTarget
argument_list|()
operator|.
name|getSchemaTypeName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|element
operator|=
name|element
operator|.
name|getRef
argument_list|()
operator|.
name|getTarget
argument_list|()
expr_stmt|;
name|element
operator|.
name|setSchemaType
argument_list|(
name|xmlSchemaCollection
operator|.
name|getTypeByQName
argument_list|(
name|element
operator|.
name|getSchemaTypeName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|type
operator|=
name|element
operator|.
name|getSchemaType
argument_list|()
expr_stmt|;
block|}
block|}
name|String
name|partJavascriptVar
init|=
name|JavascriptUtils
operator|.
name|javaScriptNameToken
argument_list|(
name|mpi
operator|.
name|getConcreteName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|elementXmlRef
init|=
name|prefixAccumulator
operator|.
name|xmlElementString
argument_list|(
name|mpi
operator|.
name|getConcreteName
argument_list|()
argument_list|)
decl_stmt|;
name|ParticleInfo
name|elementInfo
init|=
name|ParticleInfo
operator|.
name|forPartElement
argument_list|(
name|element
argument_list|,
name|xmlSchemaCollection
argument_list|,
name|partJavascriptVar
argument_list|,
name|elementXmlRef
argument_list|)
decl_stmt|;
comment|// the type may have been recalculated above.
name|elementInfo
operator|.
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|elementInfo
operator|.
name|setEmpty
argument_list|(
name|empty
argument_list|)
expr_stmt|;
name|elements
operator|.
name|add
argument_list|(
name|elementInfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|// This function finds all the information for the wrapper.
specifier|private
name|void
name|collectWrapperElementInfo
parameter_list|()
block|{
if|if
condition|(
name|currentOperation
operator|.
name|getInput
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|inputWrapperPartInfo
operator|=
name|currentOperation
operator|.
name|getInput
argument_list|()
operator|.
name|getMessagePart
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|MessagePartInfo
argument_list|>
name|unwrappedParts
init|=
name|currentOperation
operator|.
name|getUnwrappedOperation
argument_list|()
operator|.
name|getInput
argument_list|()
operator|.
name|getMessageParts
argument_list|()
decl_stmt|;
for|for
control|(
name|MessagePartInfo
name|mpi
range|:
name|unwrappedParts
control|)
block|{
name|String
name|jsParamName
init|=
name|JavascriptUtils
operator|.
name|javaScriptNameToken
argument_list|(
name|mpi
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
argument_list|)
decl_stmt|;
name|inputParameterNames
operator|.
name|add
argument_list|(
name|jsParamName
argument_list|)
expr_stmt|;
block|}
name|inputWrapperPartInfo
operator|=
name|currentOperation
operator|.
name|getInput
argument_list|()
operator|.
name|getMessagePart
argument_list|(
literal|0
argument_list|)
expr_stmt|;
assert|assert
name|inputWrapperPartInfo
operator|.
name|isElement
argument_list|()
assert|;
name|inputWrapperElement
operator|=
operator|(
name|XmlSchemaElement
operator|)
name|inputWrapperPartInfo
operator|.
name|getXmlSchema
argument_list|()
expr_stmt|;
if|if
condition|(
name|inputWrapperElement
operator|==
literal|null
condition|)
block|{
name|inputWrapperElement
operator|=
name|XmlSchemaUtils
operator|.
name|findElementByRefName
argument_list|(
name|xmlSchemaCollection
argument_list|,
name|inputWrapperPartInfo
operator|.
name|getElementQName
argument_list|()
argument_list|,
name|serviceInfo
operator|.
name|getTargetNamespace
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|inputWrapperComplexType
operator|=
operator|(
name|XmlSchemaComplexType
operator|)
name|inputWrapperElement
operator|.
name|getSchemaType
argument_list|()
expr_stmt|;
comment|// the null name is probably something awful in RFSB.
if|if
condition|(
name|inputWrapperComplexType
operator|==
literal|null
condition|)
block|{
name|inputWrapperComplexType
operator|=
operator|(
name|XmlSchemaComplexType
operator|)
name|XmlSchemaUtils
operator|.
name|getElementType
argument_list|(
name|xmlSchemaCollection
argument_list|,
name|serviceInfo
operator|.
name|getTargetNamespace
argument_list|()
argument_list|,
name|inputWrapperElement
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inputWrapperComplexType
operator|==
literal|null
condition|)
block|{
name|unsupportedConstruct
argument_list|(
literal|"MISSING_WRAPPER_TYPE"
argument_list|,
name|currentOperation
operator|.
name|getInterface
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|currentOperation
operator|.
name|getName
argument_list|()
argument_list|,
name|inputWrapperPartInfo
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inputWrapperComplexType
operator|.
name|getQName
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// we should be ignoring this for zero-argument wrappers.
if|if
condition|(
name|inputWrapperPartInfo
operator|.
name|isElement
argument_list|()
condition|)
block|{
name|inputWrapperClassName
operator|=
name|nameManager
operator|.
name|getJavascriptName
argument_list|(
name|inputWrapperPartInfo
operator|.
name|getElementQName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsupportedConstruct
argument_list|(
literal|"NON_ELEMENT_ANON_TYPE_PART"
argument_list|,
name|inputWrapperPartInfo
operator|.
name|getMessageInfo
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|inputWrapperPartInfo
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|inputWrapperClassName
operator|=
name|nameManager
operator|.
name|getJavascriptName
argument_list|(
name|inputWrapperComplexType
operator|.
name|getQName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|currentOperation
operator|.
name|getOutput
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|outputWrapperPartInfo
operator|=
name|currentOperation
operator|.
name|getOutput
argument_list|()
operator|.
name|getMessagePart
argument_list|(
literal|0
argument_list|)
expr_stmt|;
assert|assert
name|outputWrapperPartInfo
operator|.
name|isElement
argument_list|()
assert|;
name|outputWrapperElement
operator|=
operator|(
name|XmlSchemaElement
operator|)
name|outputWrapperPartInfo
operator|.
name|getXmlSchema
argument_list|()
expr_stmt|;
if|if
condition|(
name|outputWrapperElement
operator|==
literal|null
condition|)
block|{
name|outputWrapperElement
operator|=
name|XmlSchemaUtils
operator|.
name|findElementByRefName
argument_list|(
name|xmlSchemaCollection
argument_list|,
name|outputWrapperPartInfo
operator|.
name|getElementQName
argument_list|()
argument_list|,
name|serviceInfo
operator|.
name|getTargetNamespace
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|outputWrapperComplexType
operator|=
operator|(
name|XmlSchemaComplexType
operator|)
name|outputWrapperElement
operator|.
name|getSchemaType
argument_list|()
expr_stmt|;
if|if
condition|(
name|outputWrapperComplexType
operator|==
literal|null
condition|)
block|{
name|outputWrapperComplexType
operator|=
operator|(
name|XmlSchemaComplexType
operator|)
name|XmlSchemaUtils
operator|.
name|getElementType
argument_list|(
name|xmlSchemaCollection
argument_list|,
name|serviceInfo
operator|.
name|getTargetNamespace
argument_list|()
argument_list|,
name|outputWrapperElement
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|begin
parameter_list|(
name|ServiceInfo
name|service
parameter_list|)
block|{
name|code
operator|.
name|append
argument_list|(
literal|"//\n"
argument_list|)
expr_stmt|;
name|code
operator|.
name|append
argument_list|(
literal|"// Definitions for service: "
operator|+
name|service
operator|.
name|getName
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
name|code
operator|.
name|append
argument_list|(
literal|"//\n"
argument_list|)
expr_stmt|;
name|BindingInfo
name|xml
init|=
literal|null
decl_stmt|;
comment|// assume only one soap binding.
comment|// until further consideration.
comment|// hypothetically, we could generate two different JavaScript classes,
comment|// one for each.
for|for
control|(
name|BindingInfo
name|bindingInfo
range|:
name|service
operator|.
name|getBindings
argument_list|()
control|)
block|{
comment|// there is a JIRA about the confusion / profusion of URLS here.
if|if
condition|(
name|SoapBindingConstants
operator|.
name|SOAP11_BINDING_ID
operator|.
name|equals
argument_list|(
name|bindingInfo
operator|.
name|getBindingId
argument_list|()
argument_list|)
operator|||
name|SoapBindingConstants
operator|.
name|SOAP12_BINDING_ID
operator|.
name|equals
argument_list|(
name|bindingInfo
operator|.
name|getBindingId
argument_list|()
argument_list|)
operator|||
name|SoapBindingFactory
operator|.
name|SOAP_11_BINDING
operator|.
name|equals
argument_list|(
name|bindingInfo
operator|.
name|getBindingId
argument_list|()
argument_list|)
operator|||
name|SoapBindingFactory
operator|.
name|SOAP_12_BINDING
operator|.
name|equals
argument_list|(
name|bindingInfo
operator|.
name|getBindingId
argument_list|()
argument_list|)
condition|)
block|{
name|SoapBindingInfo
name|sbi
init|=
operator|(
name|SoapBindingInfo
operator|)
name|bindingInfo
decl_stmt|;
if|if
condition|(
name|WSDLConstants
operator|.
name|NS_SOAP11_HTTP_TRANSPORT
operator|.
name|equals
argument_list|(
name|sbi
operator|.
name|getTransportURI
argument_list|()
argument_list|)
operator|||
name|WSDLConstants
operator|.
name|NS_SOAP12_HTTP_BINDING
operator|.
name|equals
argument_list|(
name|sbi
operator|.
name|getTransportURI
argument_list|()
argument_list|)
comment|// we may want this for testing.
operator|||
name|LocalTransportFactory
operator|.
name|TRANSPORT_ID
operator|.
name|equals
argument_list|(
name|sbi
operator|.
name|getTransportURI
argument_list|()
argument_list|)
condition|)
block|{
name|soapBindingInfo
operator|=
name|sbi
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|WSDLConstants
operator|.
name|NS_BINDING_XML
operator|.
name|equals
argument_list|(
name|bindingInfo
operator|.
name|getBindingId
argument_list|()
argument_list|)
condition|)
block|{
name|xml
operator|=
name|bindingInfo
expr_stmt|;
block|}
block|}
comment|// For now, we use soap if its available, and XML if it isn't.\
if|if
condition|(
name|soapBindingInfo
operator|==
literal|null
operator|&&
name|xml
operator|==
literal|null
condition|)
block|{
name|unsupportedConstruct
argument_list|(
literal|"NO_USABLE_BINDING"
argument_list|,
name|service
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|soapBindingInfo
operator|!=
literal|null
condition|)
block|{
name|isRPC
operator|=
name|WSDLConstants
operator|.
name|RPC
operator|.
name|equals
argument_list|(
name|soapBindingInfo
operator|.
name|getStyle
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xml
operator|!=
literal|null
condition|)
block|{
name|xmlBindingInfo
operator|=
name|xml
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|end
parameter_list|(
name|FaultInfo
name|fault
parameter_list|)
block|{     }
annotation|@
name|Override
specifier|public
name|void
name|end
parameter_list|(
name|InterfaceInfo
name|intf
parameter_list|)
block|{     }
annotation|@
name|Override
specifier|public
name|void
name|end
parameter_list|(
name|MessageInfo
name|msg
parameter_list|)
block|{     }
annotation|@
name|Override
specifier|public
name|void
name|end
parameter_list|(
name|MessagePartInfo
name|part
parameter_list|)
block|{     }
annotation|@
name|Override
specifier|public
name|void
name|end
parameter_list|(
name|ServiceInfo
name|service
parameter_list|)
block|{
name|LOG
operator|.
name|finer
argument_list|(
name|getCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|unsupportedConstruct
parameter_list|(
name|String
name|messageKey
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
name|Message
name|message
init|=
operator|new
name|Message
argument_list|(
name|messageKey
argument_list|,
name|LOG
argument_list|,
name|args
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|UnsupportedConstruct
argument_list|(
name|message
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|begin
parameter_list|(
name|OperationInfo
name|op
parameter_list|)
block|{
if|if
condition|(
name|op
operator|.
name|isUnwrapped
argument_list|()
condition|)
block|{
name|isInUnwrappedOperation
operator|=
literal|true
expr_stmt|;
return|return;
block|}
name|currentOperation
operator|=
name|op
expr_stmt|;
name|OperationInfo
name|conflict
init|=
name|localOperationsNameMap
operator|.
name|get
argument_list|(
name|op
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|conflict
operator|!=
literal|null
condition|)
block|{
name|operationsWithNameConflicts
operator|.
name|add
argument_list|(
name|conflict
argument_list|)
expr_stmt|;
name|operationsWithNameConflicts
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
name|localOperationsNameMap
operator|.
name|put
argument_list|(
name|op
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|opFunctionPropertyName
operator|=
name|getFunctionPropertyName
argument_list|(
name|operationsWithNameConflicts
argument_list|,
name|op
argument_list|,
name|op
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|opFunctionGlobalName
operator|=
name|getFunctionGlobalName
argument_list|(
name|op
operator|.
name|getName
argument_list|()
argument_list|,
literal|"op"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|begin
parameter_list|(
name|MessageInfo
name|msg
parameter_list|)
block|{
if|if
condition|(
name|isInUnwrappedOperation
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|fine
argument_list|(
literal|"Message "
operator|+
name|msg
operator|.
name|getName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|MessageInfo
argument_list|>
name|nameMap
decl_stmt|;
name|Set
argument_list|<
name|MessageInfo
argument_list|>
name|conflicts
decl_stmt|;
if|if
condition|(
name|msg
operator|.
name|getType
argument_list|()
operator|==
name|MessageInfo
operator|.
name|Type
operator|.
name|INPUT
condition|)
block|{
name|nameMap
operator|=
name|localInputMessagesNameMap
expr_stmt|;
name|conflicts
operator|=
name|inputMessagesWithNameConflicts
expr_stmt|;
block|}
else|else
block|{
name|nameMap
operator|=
name|localOutputMessagesNameMap
expr_stmt|;
name|conflicts
operator|=
name|outputMessagesWithNameConflicts
expr_stmt|;
block|}
name|MessageInfo
name|conflict
init|=
name|nameMap
operator|.
name|get
argument_list|(
name|msg
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|conflict
operator|!=
literal|null
condition|)
block|{
name|conflicts
operator|.
name|add
argument_list|(
name|conflict
argument_list|)
expr_stmt|;
name|conflicts
operator|.
name|add
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
name|nameMap
operator|.
name|put
argument_list|(
name|msg
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|begin
parameter_list|(
name|EndpointInfo
name|endpointInfo
parameter_list|)
block|{
name|String
name|address
init|=
name|endpointInfo
operator|.
name|getAddress
argument_list|()
decl_stmt|;
name|String
name|portClassName
init|=
name|currentInterfaceClassName
operator|+
literal|"_"
operator|+
name|nameManager
operator|.
name|getJavascriptName
argument_list|(
name|endpointInfo
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|code
operator|.
name|append
argument_list|(
literal|"function "
operator|+
name|portClassName
operator|+
literal|" () {\n"
argument_list|)
expr_stmt|;
name|code
operator|.
name|append
argument_list|(
literal|"  this.url = '"
operator|+
name|address
operator|+
literal|"';\n"
argument_list|)
expr_stmt|;
name|code
operator|.
name|append
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
name|code
operator|.
name|append
argument_list|(
name|portClassName
operator|+
literal|".prototype = new "
operator|+
name|currentInterfaceClassName
operator|+
literal|";\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

