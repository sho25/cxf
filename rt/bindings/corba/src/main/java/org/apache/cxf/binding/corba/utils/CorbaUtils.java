begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements. See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|utils
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|namespace
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|CorbaBindingException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|CorbaStreamable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|CorbaTypeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Alias
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Anonarray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Anonfixed
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Anonsequence
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Anonstring
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Anonwstring
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|CaseType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|CorbaConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|CorbaType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|CorbaTypeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Enum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Enumerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Exception
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Fixed
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|MemberType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Sequence
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Struct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|TypeMappingType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Union
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Unionbranch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|common
operator|.
name|logging
operator|.
name|LogUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|common
operator|.
name|xmlschema
operator|.
name|SchemaCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|service
operator|.
name|model
operator|.
name|SchemaInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|service
operator|.
name|model
operator|.
name|ServiceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchemaElement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchemaExternal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchemaForm
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchemaType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|Any
import|;
end_import

begin_import
import|import
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|NVList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|ORB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|StructMember
import|;
end_import

begin_import
import|import
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|TCKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|TypeCode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|UnionMember
import|;
end_import

begin_class
specifier|public
specifier|final
class|class
name|CorbaUtils
block|{
specifier|static
specifier|final
name|QName
name|EMPTY_QNAME
init|=
operator|new
name|QName
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|)
decl_stmt|;
specifier|static
specifier|final
name|Map
argument_list|<
name|QName
argument_list|,
name|TCKind
argument_list|>
name|PRIMITIVE_TYPECODES
init|=
operator|new
name|HashMap
argument_list|<
name|QName
argument_list|,
name|TCKind
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LogUtils
operator|.
name|getL7dLogger
argument_list|(
name|CorbaUtils
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
class|class
name|LastExport
block|{
specifier|private
specifier|final
name|String
name|ior
decl_stmt|;
specifier|private
specifier|final
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|Object
name|ref
decl_stmt|;
name|LastExport
parameter_list|(
name|String
name|iors
parameter_list|,
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|Object
name|oref
parameter_list|)
block|{
name|ior
operator|=
name|iors
expr_stmt|;
name|ref
operator|=
name|oref
expr_stmt|;
block|}
name|String
name|getIor
parameter_list|()
block|{
return|return
name|ior
return|;
block|}
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|Object
name|getRef
parameter_list|()
block|{
return|return
name|ref
return|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|LastExport
argument_list|>
name|LAST_EXPORT_CACHE
init|=
operator|new
name|ThreadLocal
argument_list|<
name|LastExport
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|CorbaUtils
parameter_list|()
block|{
comment|//utility class
block|}
specifier|public
specifier|static
name|QName
name|getEmptyQName
parameter_list|()
block|{
return|return
name|EMPTY_QNAME
return|;
block|}
specifier|public
specifier|static
name|TypeCode
name|getTypeCode
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|QName
name|type
parameter_list|,
name|CorbaTypeMap
name|typeMap
parameter_list|)
block|{
name|Stack
argument_list|<
name|QName
argument_list|>
name|seenTypes
init|=
operator|new
name|Stack
argument_list|<
name|QName
argument_list|>
argument_list|()
decl_stmt|;
return|return
name|getTypeCode
argument_list|(
name|orb
argument_list|,
name|type
argument_list|,
literal|null
argument_list|,
name|typeMap
argument_list|,
name|seenTypes
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|TypeCode
name|getTypeCode
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|QName
name|type
parameter_list|,
name|CorbaTypeMap
name|typeMap
parameter_list|,
name|Stack
argument_list|<
name|QName
argument_list|>
name|seenTypes
parameter_list|)
block|{
return|return
name|getTypeCode
argument_list|(
name|orb
argument_list|,
name|type
argument_list|,
literal|null
argument_list|,
name|typeMap
argument_list|,
name|seenTypes
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|TypeCode
name|getTypeCode
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|QName
name|type
parameter_list|,
name|CorbaType
name|obj
parameter_list|,
name|CorbaTypeMap
name|typeMap
parameter_list|)
block|{
name|Stack
argument_list|<
name|QName
argument_list|>
name|seenTypes
init|=
operator|new
name|Stack
argument_list|<
name|QName
argument_list|>
argument_list|()
decl_stmt|;
return|return
name|getTypeCode
argument_list|(
name|orb
argument_list|,
name|type
argument_list|,
name|obj
argument_list|,
name|typeMap
argument_list|,
name|seenTypes
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|TypeCode
name|getTypeCode
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|QName
name|type
parameter_list|,
name|CorbaType
name|obj
parameter_list|,
name|CorbaTypeMap
name|typeMap
parameter_list|,
name|Stack
argument_list|<
name|QName
argument_list|>
name|seenTypes
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CorbaBindingException
argument_list|(
literal|"corba:typemap type or elemtype information required"
operator|+
operator|(
name|obj
operator|==
literal|null
condition|?
literal|""
else|:
literal|" for "
operator|+
name|obj
operator|)
operator|+
operator|(
name|seenTypes
operator|.
name|empty
argument_list|()
condition|?
literal|""
else|:
literal|", Enclosing type: "
operator|+
name|seenTypes
operator|.
name|elementAt
argument_list|(
literal|0
argument_list|)
operator|)
argument_list|)
throw|;
block|}
name|TypeCode
name|tc
init|=
literal|null
decl_stmt|;
comment|// first see if it is a primitive
name|tc
operator|=
name|getPrimitiveTypeCode
argument_list|(
name|orb
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc
operator|==
literal|null
operator|&&
name|type
operator|.
name|equals
argument_list|(
name|CorbaConstants
operator|.
name|NT_CORBA_ANY
argument_list|)
condition|)
block|{
comment|// Anys are handled in a special way
name|tc
operator|=
name|orb
operator|.
name|get_primitive_tc
argument_list|(
name|TCKind
operator|.
name|from_int
argument_list|(
name|TCKind
operator|.
name|_tk_any
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tc
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|typeMap
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CorbaBindingException
argument_list|(
literal|"Unable to locate typemap for namespace \""
operator|+
name|type
operator|.
name|getNamespaceURI
argument_list|()
operator|+
literal|"\""
argument_list|)
throw|;
block|}
name|tc
operator|=
name|typeMap
operator|.
name|getTypeCode
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
name|obj
operator|=
name|typeMap
operator|.
name|getType
argument_list|(
name|type
operator|.
name|getLocalPart
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CorbaBindingException
argument_list|(
literal|"Unable to locate object definition"
argument_list|)
throw|;
block|}
block|}
name|tc
operator|=
name|getComplexTypeCode
argument_list|(
name|orb
argument_list|,
name|type
argument_list|,
name|obj
argument_list|,
name|typeMap
argument_list|,
name|seenTypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc
operator|!=
literal|null
condition|)
block|{
name|typeMap
operator|.
name|addTypeCode
argument_list|(
name|type
argument_list|,
name|tc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tc
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CorbaBindingException
argument_list|(
literal|"Corba type node with qname "
operator|+
name|type
operator|+
literal|" is not supported"
argument_list|)
throw|;
block|}
return|return
name|tc
return|;
block|}
specifier|public
specifier|static
name|TypeCode
name|getPrimitiveTypeCode
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|QName
name|type
parameter_list|)
block|{
name|TCKind
name|kind
init|=
name|PRIMITIVE_TYPECODES
operator|.
name|get
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|kind
operator|!=
literal|null
condition|)
block|{
return|return
name|orb
operator|.
name|get_primitive_tc
argument_list|(
name|kind
argument_list|)
return|;
block|}
comment|// There is a possiblitity that the idl type will not have its namespace URI set if it has
comment|// been read directly from the WSDL file as a string. Try with the standard corba namespace URI.
if|if
condition|(
name|type
operator|.
name|getNamespaceURI
argument_list|()
operator|==
literal|null
condition|)
block|{
name|QName
name|uriIdltype
init|=
operator|new
name|QName
argument_list|(
name|CorbaConstants
operator|.
name|NU_WSDL_CORBA
argument_list|,
name|type
operator|.
name|getLocalPart
argument_list|()
argument_list|,
name|type
operator|.
name|getPrefix
argument_list|()
argument_list|)
decl_stmt|;
name|kind
operator|=
name|PRIMITIVE_TYPECODES
operator|.
name|get
argument_list|(
name|uriIdltype
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
literal|null
condition|)
block|{
return|return
name|orb
operator|.
name|get_primitive_tc
argument_list|(
name|kind
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
specifier|static
name|TypeCode
name|getComplexTypeCode
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|QName
name|type
parameter_list|,
name|Object
name|obj
parameter_list|,
name|CorbaTypeMap
name|typeMap
parameter_list|,
name|Stack
argument_list|<
name|QName
argument_list|>
name|seenTypes
parameter_list|)
block|{
name|TypeCode
name|tc
init|=
name|getAnonTypeCode
argument_list|(
name|orb
argument_list|,
name|type
argument_list|,
name|obj
argument_list|,
name|typeMap
argument_list|,
name|seenTypes
argument_list|)
decl_stmt|;
if|if
condition|(
name|tc
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|Alias
condition|)
block|{
name|Alias
name|aliasType
init|=
operator|(
name|Alias
operator|)
name|obj
decl_stmt|;
name|tc
operator|=
name|orb
operator|.
name|create_alias_tc
argument_list|(
name|aliasType
operator|.
name|getRepositoryID
argument_list|()
argument_list|,
name|getTypeCodeName
argument_list|(
name|aliasType
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|getTypeCode
argument_list|(
name|orb
argument_list|,
name|aliasType
operator|.
name|getBasetype
argument_list|()
argument_list|,
name|typeMap
argument_list|,
name|seenTypes
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Array
condition|)
block|{
name|Array
name|arrayType
init|=
operator|(
name|Array
operator|)
name|obj
decl_stmt|;
name|tc
operator|=
name|orb
operator|.
name|create_array_tc
argument_list|(
operator|(
name|int
operator|)
name|arrayType
operator|.
name|getBound
argument_list|()
argument_list|,
name|getTypeCode
argument_list|(
name|orb
argument_list|,
name|arrayType
operator|.
name|getElemtype
argument_list|()
argument_list|,
name|typeMap
argument_list|,
name|seenTypes
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Enum
condition|)
block|{
name|Enum
name|enumType
init|=
operator|(
name|Enum
operator|)
name|obj
decl_stmt|;
name|String
name|name
init|=
name|enumType
operator|.
name|getName
argument_list|()
decl_stmt|;
name|List
name|enums
init|=
name|enumType
operator|.
name|getEnumerator
argument_list|()
decl_stmt|;
name|String
index|[]
name|members
init|=
operator|new
name|String
index|[
name|enums
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|members
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|members
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|Enumerator
operator|)
name|enums
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
name|name
operator|=
name|getTypeCodeName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|tc
operator|=
name|orb
operator|.
name|create_enum_tc
argument_list|(
name|enumType
operator|.
name|getRepositoryID
argument_list|()
argument_list|,
name|name
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Exception
condition|)
block|{
name|Exception
name|exceptType
init|=
operator|(
name|Exception
operator|)
name|obj
decl_stmt|;
comment|// TODO: check to see if this is a recursive type.
name|List
name|list
init|=
name|exceptType
operator|.
name|getMember
argument_list|()
decl_stmt|;
name|StructMember
index|[]
name|members
init|=
operator|new
name|StructMember
index|[
name|list
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|members
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|MemberType
name|member
init|=
operator|(
name|MemberType
operator|)
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|members
index|[
name|i
index|]
operator|=
operator|new
name|StructMember
argument_list|(
name|member
operator|.
name|getName
argument_list|()
argument_list|,
name|getTypeCode
argument_list|(
name|orb
argument_list|,
name|member
operator|.
name|getIdltype
argument_list|()
argument_list|,
name|typeMap
argument_list|,
name|seenTypes
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|String
name|name
init|=
name|getTypeCodeName
argument_list|(
name|exceptType
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|tc
operator|=
name|orb
operator|.
name|create_exception_tc
argument_list|(
name|exceptType
operator|.
name|getRepositoryID
argument_list|()
argument_list|,
name|name
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Fixed
condition|)
block|{
name|Fixed
name|fixedType
init|=
operator|(
name|Fixed
operator|)
name|obj
decl_stmt|;
name|tc
operator|=
name|orb
operator|.
name|create_fixed_tc
argument_list|(
operator|(
name|short
operator|)
name|fixedType
operator|.
name|getDigits
argument_list|()
argument_list|,
operator|(
name|short
operator|)
name|fixedType
operator|.
name|getScale
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Object
condition|)
block|{
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Object
name|objType
init|=
operator|(
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Object
operator|)
name|obj
decl_stmt|;
if|if
condition|(
name|objType
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"CORBA.Object"
argument_list|)
condition|)
block|{
name|tc
operator|=
name|orb
operator|.
name|create_interface_tc
argument_list|(
name|objType
operator|.
name|getRepositoryID
argument_list|()
argument_list|,
literal|"Object"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tc
operator|=
name|orb
operator|.
name|create_interface_tc
argument_list|(
name|objType
operator|.
name|getRepositoryID
argument_list|()
argument_list|,
name|getTypeCodeName
argument_list|(
name|objType
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Sequence
condition|)
block|{
name|Sequence
name|seqType
init|=
operator|(
name|Sequence
operator|)
name|obj
decl_stmt|;
name|tc
operator|=
name|orb
operator|.
name|create_sequence_tc
argument_list|(
operator|(
name|int
operator|)
name|seqType
operator|.
name|getBound
argument_list|()
argument_list|,
name|getTypeCode
argument_list|(
name|orb
argument_list|,
name|seqType
operator|.
name|getElemtype
argument_list|()
argument_list|,
name|typeMap
argument_list|,
name|seenTypes
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Struct
condition|)
block|{
name|Struct
name|structType
init|=
operator|(
name|Struct
operator|)
name|obj
decl_stmt|;
comment|// TODO: check to see if this is a recursive type.
if|if
condition|(
name|seenTypes
operator|.
name|contains
argument_list|(
operator|new
name|QName
argument_list|(
name|structType
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
name|tc
operator|=
name|orb
operator|.
name|create_recursive_tc
argument_list|(
name|structType
operator|.
name|getRepositoryID
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|seenTypes
operator|.
name|push
argument_list|(
operator|new
name|QName
argument_list|(
name|structType
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|List
name|list
init|=
name|structType
operator|.
name|getMember
argument_list|()
decl_stmt|;
name|StructMember
index|[]
name|members
init|=
operator|new
name|StructMember
index|[
name|list
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|members
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|MemberType
name|member
init|=
operator|(
name|MemberType
operator|)
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|members
index|[
name|i
index|]
operator|=
operator|new
name|StructMember
argument_list|(
name|member
operator|.
name|getName
argument_list|()
argument_list|,
name|getTypeCode
argument_list|(
name|orb
argument_list|,
name|member
operator|.
name|getIdltype
argument_list|()
argument_list|,
name|typeMap
argument_list|,
name|seenTypes
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|String
name|name
init|=
name|getTypeCodeName
argument_list|(
name|structType
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|tc
operator|=
name|orb
operator|.
name|create_struct_tc
argument_list|(
name|structType
operator|.
name|getRepositoryID
argument_list|()
argument_list|,
name|name
argument_list|,
name|members
argument_list|)
expr_stmt|;
name|seenTypes
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Union
condition|)
block|{
name|tc
operator|=
name|getUnionTypeCode
argument_list|(
name|orb
argument_list|,
name|obj
argument_list|,
name|typeMap
argument_list|,
name|seenTypes
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tc
return|;
block|}
specifier|private
specifier|static
name|TypeCode
name|getAnonTypeCode
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|QName
name|type
parameter_list|,
name|Object
name|obj
parameter_list|,
name|CorbaTypeMap
name|typeMap
parameter_list|,
name|Stack
argument_list|<
name|QName
argument_list|>
name|seenTypes
parameter_list|)
block|{
name|TypeCode
name|tc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|obj
operator|instanceof
name|Anonarray
condition|)
block|{
name|Anonarray
name|anonArrayType
init|=
operator|(
name|Anonarray
operator|)
name|obj
decl_stmt|;
name|tc
operator|=
name|orb
operator|.
name|create_array_tc
argument_list|(
operator|(
name|int
operator|)
name|anonArrayType
operator|.
name|getBound
argument_list|()
argument_list|,
name|getTypeCode
argument_list|(
name|orb
argument_list|,
name|anonArrayType
operator|.
name|getElemtype
argument_list|()
argument_list|,
name|typeMap
argument_list|,
name|seenTypes
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Anonfixed
condition|)
block|{
name|Anonfixed
name|anonFixedType
init|=
operator|(
name|Anonfixed
operator|)
name|obj
decl_stmt|;
name|tc
operator|=
name|orb
operator|.
name|create_fixed_tc
argument_list|(
operator|(
name|short
operator|)
name|anonFixedType
operator|.
name|getDigits
argument_list|()
argument_list|,
operator|(
name|short
operator|)
name|anonFixedType
operator|.
name|getScale
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Anonsequence
condition|)
block|{
name|Anonsequence
name|anonSeqType
init|=
operator|(
name|Anonsequence
operator|)
name|obj
decl_stmt|;
name|tc
operator|=
name|orb
operator|.
name|create_sequence_tc
argument_list|(
operator|(
name|int
operator|)
name|anonSeqType
operator|.
name|getBound
argument_list|()
argument_list|,
name|getTypeCode
argument_list|(
name|orb
argument_list|,
name|anonSeqType
operator|.
name|getElemtype
argument_list|()
argument_list|,
name|typeMap
argument_list|,
name|seenTypes
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Anonstring
condition|)
block|{
name|Anonstring
name|anonStringType
init|=
operator|(
name|Anonstring
operator|)
name|obj
decl_stmt|;
name|tc
operator|=
name|orb
operator|.
name|create_string_tc
argument_list|(
operator|(
name|int
operator|)
name|anonStringType
operator|.
name|getBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Anonwstring
condition|)
block|{
name|Anonwstring
name|anonWStringType
init|=
operator|(
name|Anonwstring
operator|)
name|obj
decl_stmt|;
name|tc
operator|=
name|orb
operator|.
name|create_wstring_tc
argument_list|(
operator|(
name|int
operator|)
name|anonWStringType
operator|.
name|getBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|tc
return|;
block|}
specifier|public
specifier|static
name|TypeCode
name|getUnionTypeCode
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|Object
name|obj
parameter_list|,
name|CorbaTypeMap
name|typeMap
parameter_list|,
name|Stack
argument_list|<
name|QName
argument_list|>
name|seenTypes
parameter_list|)
block|{
name|Union
name|unionType
init|=
operator|(
name|Union
operator|)
name|obj
decl_stmt|;
if|if
condition|(
name|seenTypes
operator|.
name|contains
argument_list|(
operator|new
name|QName
argument_list|(
name|unionType
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|orb
operator|.
name|create_recursive_tc
argument_list|(
name|unionType
operator|.
name|getRepositoryID
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
name|seenTypes
operator|.
name|push
argument_list|(
operator|new
name|QName
argument_list|(
name|unionType
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|TypeCode
name|discTC
init|=
name|getTypeCode
argument_list|(
name|orb
argument_list|,
name|unionType
operator|.
name|getDiscriminator
argument_list|()
argument_list|,
name|typeMap
argument_list|,
name|seenTypes
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|UnionMember
argument_list|>
name|members
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|UnionMember
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Unionbranch
argument_list|>
name|branches
init|=
name|unionType
operator|.
name|getUnionbranch
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Unionbranch
argument_list|>
name|branchIter
init|=
name|branches
operator|.
name|iterator
argument_list|()
init|;
name|branchIter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Unionbranch
name|branch
init|=
name|branchIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|CaseType
argument_list|>
name|cases
init|=
name|branch
operator|.
name|getCase
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|CaseType
argument_list|>
name|caseIter
init|=
name|cases
operator|.
name|iterator
argument_list|()
init|;
name|caseIter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|CaseType
name|cs
init|=
name|caseIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|members
operator|.
name|containsKey
argument_list|(
name|cs
operator|.
name|getLabel
argument_list|()
argument_list|)
condition|)
block|{
name|UnionMember
name|member
init|=
operator|new
name|UnionMember
argument_list|()
decl_stmt|;
name|member
operator|.
name|name
operator|=
name|branch
operator|.
name|getName
argument_list|()
expr_stmt|;
name|member
operator|.
name|type
operator|=
name|getTypeCode
argument_list|(
name|orb
argument_list|,
name|branch
operator|.
name|getIdltype
argument_list|()
argument_list|,
name|typeMap
argument_list|,
name|seenTypes
argument_list|)
expr_stmt|;
name|member
operator|.
name|label
operator|=
name|orb
operator|.
name|create_any
argument_list|()
expr_stmt|;
comment|// We need to insert the labels in a way that depends on the type of the
comment|// discriminator.  According to the CORBA specification, the following types
comment|// are permissable as discriminator types:
comment|//    * signed& unsigned short
comment|//    * signed& unsigned long
comment|//    * signed& unsigned long long
comment|//    * char
comment|//    * boolean
comment|//    * enum
switch|switch
condition|(
name|discTC
operator|.
name|kind
argument_list|()
operator|.
name|value
argument_list|()
condition|)
block|{
case|case
name|TCKind
operator|.
name|_tk_short
case|:
name|member
operator|.
name|label
operator|.
name|insert_short
argument_list|(
name|Short
operator|.
name|parseShort
argument_list|(
name|cs
operator|.
name|getLabel
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_ushort
case|:
name|member
operator|.
name|label
operator|.
name|insert_ushort
argument_list|(
name|Short
operator|.
name|parseShort
argument_list|(
name|cs
operator|.
name|getLabel
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_long
case|:
name|member
operator|.
name|label
operator|.
name|insert_long
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|cs
operator|.
name|getLabel
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_ulong
case|:
name|member
operator|.
name|label
operator|.
name|insert_ulong
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|cs
operator|.
name|getLabel
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_longlong
case|:
name|member
operator|.
name|label
operator|.
name|insert_longlong
argument_list|(
name|Long
operator|.
name|parseLong
argument_list|(
name|cs
operator|.
name|getLabel
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_ulonglong
case|:
name|member
operator|.
name|label
operator|.
name|insert_ulonglong
argument_list|(
name|Long
operator|.
name|parseLong
argument_list|(
name|cs
operator|.
name|getLabel
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_char
case|:
name|member
operator|.
name|label
operator|.
name|insert_char
argument_list|(
name|cs
operator|.
name|getLabel
argument_list|()
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_boolean
case|:
name|member
operator|.
name|label
operator|.
name|insert_boolean
argument_list|(
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|cs
operator|.
name|getLabel
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_enum
case|:
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|portable
operator|.
name|OutputStream
name|out
init|=
name|member
operator|.
name|label
operator|.
name|create_output_stream
argument_list|()
decl_stmt|;
name|Enum
name|enumVal
init|=
operator|(
name|Enum
operator|)
name|getCorbaType
argument_list|(
name|unionType
operator|.
name|getDiscriminator
argument_list|()
argument_list|,
name|typeMap
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Enumerator
argument_list|>
name|enumerators
init|=
name|enumVal
operator|.
name|getEnumerator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|enumerators
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Enumerator
name|e
init|=
name|enumerators
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|cs
operator|.
name|getLabel
argument_list|()
argument_list|)
condition|)
block|{
name|out
operator|.
name|write_long
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|member
operator|.
name|label
operator|.
name|read_value
argument_list|(
name|out
operator|.
name|create_input_stream
argument_list|()
argument_list|,
name|discTC
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|CorbaBindingException
argument_list|(
literal|"Unsupported discriminator type"
argument_list|)
throw|;
block|}
comment|// Some orbs are strict on how the case labels are stored for
comment|// each member.  So we can't
comment|// simply insert the labels as strings
name|members
operator|.
name|put
argument_list|(
name|cs
operator|.
name|getLabel
argument_list|()
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|seenTypes
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
name|orb
operator|.
name|create_union_tc
argument_list|(
name|unionType
operator|.
name|getRepositoryID
argument_list|()
argument_list|,
name|getTypeCodeName
argument_list|(
name|unionType
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|discTC
argument_list|,
operator|(
name|UnionMember
index|[]
operator|)
name|members
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|UnionMember
index|[
name|members
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
name|String
name|getTypeCodeName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|int
name|pos
init|=
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|"."
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isPrimitiveIdlType
parameter_list|(
name|QName
name|idltype
parameter_list|)
block|{
name|TCKind
name|kind
init|=
name|PRIMITIVE_TYPECODES
operator|.
name|get
argument_list|(
name|idltype
argument_list|)
decl_stmt|;
if|if
condition|(
name|kind
operator|!=
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// There is a possiblitity that the idl type will not have its namespace URI set if it has
comment|// been read directly from the WSDL file as a string. Try with the standard corba namespace URI.
if|if
condition|(
name|idltype
operator|.
name|getNamespaceURI
argument_list|()
operator|==
literal|null
condition|)
block|{
name|QName
name|uriIdltype
init|=
operator|new
name|QName
argument_list|(
name|CorbaConstants
operator|.
name|NU_WSDL_CORBA
argument_list|,
name|idltype
operator|.
name|getLocalPart
argument_list|()
argument_list|,
name|idltype
operator|.
name|getPrefix
argument_list|()
argument_list|)
decl_stmt|;
name|kind
operator|=
name|PRIMITIVE_TYPECODES
operator|.
name|get
argument_list|(
name|uriIdltype
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isPrimitiveTypeCode
parameter_list|(
name|TypeCode
name|tc
parameter_list|)
block|{
return|return
name|PRIMITIVE_TYPECODES
operator|.
name|values
argument_list|()
operator|.
name|contains
argument_list|(
name|tc
operator|.
name|kind
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|CorbaTypeImpl
name|getCorbaType
parameter_list|(
name|QName
name|idlType
parameter_list|,
name|CorbaTypeMap
name|typeMap
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isPrimitiveIdlType
argument_list|(
name|idlType
argument_list|)
operator|&&
operator|(
name|typeMap
operator|!=
literal|null
operator|)
condition|)
block|{
return|return
operator|(
name|CorbaTypeImpl
operator|)
name|typeMap
operator|.
name|getType
argument_list|(
name|idlType
operator|.
name|getLocalPart
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
specifier|static
name|CorbaTypeMap
name|createCorbaTypeMap
parameter_list|(
name|List
argument_list|<
name|TypeMappingType
argument_list|>
name|tmTypes
parameter_list|)
block|{
name|CorbaTypeMap
name|map
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|tmTypes
operator|!=
literal|null
condition|)
block|{
comment|//Currently, only one type map
name|TypeMappingType
name|tmType
init|=
name|tmTypes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|map
operator|=
operator|new
name|CorbaTypeMap
argument_list|(
name|tmType
operator|.
name|getTargetNamespace
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|CorbaTypeImpl
argument_list|>
name|types
init|=
name|tmType
operator|.
name|getStructOrExceptionOrUnion
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|fine
argument_list|(
literal|"Found "
operator|+
name|types
operator|.
name|size
argument_list|()
operator|+
literal|" types defined in the typemap"
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|CorbaTypeImpl
argument_list|>
name|it
init|=
name|types
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|CorbaTypeImpl
name|corbaType
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|corbaType
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// There can be some instances where a prefix is added to the name by the tool
comment|// (e.g. Object Reference Names).  Since the name is read as a string, this
comment|// prefix is added to the types name.  Remove this as it is not needed.
name|int
name|pos
init|=
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|corbaType
operator|.
name|setName
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|map
operator|.
name|addType
argument_list|(
name|name
argument_list|,
name|corbaType
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|fine
argument_list|(
literal|"Adding type "
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|map
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isValidURL
parameter_list|(
name|String
name|url
parameter_list|)
block|{
if|if
condition|(
operator|(
name|url
operator|.
name|startsWith
argument_list|(
literal|"ior:"
argument_list|)
operator|)
operator|||
operator|(
name|url
operator|.
name|startsWith
argument_list|(
literal|"IOR:"
argument_list|)
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|url
operator|.
name|startsWith
argument_list|(
literal|"file:"
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|url
operator|.
name|startsWith
argument_list|(
literal|"corbaloc:"
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|url
operator|.
name|startsWith
argument_list|(
literal|"corbaname:"
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
specifier|static
name|String
name|getUniquePOAName
parameter_list|(
name|QName
name|serviceName
parameter_list|,
name|String
name|portName
parameter_list|,
name|String
name|poaName
parameter_list|)
block|{
comment|//Create a unique name of the form
comment|//"{namespace_uri}service_name#port_name#user_provided_name"
comment|//The last part is only appended if it is non empty
comment|//
name|String
name|result
init|=
literal|"{"
operator|+
name|serviceName
operator|.
name|getNamespaceURI
argument_list|()
operator|+
literal|"}"
operator|+
name|serviceName
operator|.
name|getLocalPart
argument_list|()
operator|+
literal|"#"
operator|+
name|portName
decl_stmt|;
if|if
condition|(
name|poaName
operator|!=
literal|null
condition|)
block|{
name|result
operator|+=
literal|"#"
operator|+
name|poaName
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isIOR
parameter_list|(
name|String
name|location
parameter_list|)
block|{
if|if
condition|(
operator|(
name|location
operator|.
name|startsWith
argument_list|(
literal|"ior:"
argument_list|)
operator|)
operator|||
operator|(
name|location
operator|.
name|startsWith
argument_list|(
literal|"IOR:"
argument_list|)
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
specifier|static
name|String
name|exportObjectReference
parameter_list|(
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|Object
name|obj
parameter_list|,
name|ORB
name|orb
parameter_list|)
block|{
name|String
name|ior
init|=
name|orb
operator|.
name|object_to_string
argument_list|(
name|obj
argument_list|)
decl_stmt|;
name|LAST_EXPORT_CACHE
operator|.
name|set
argument_list|(
operator|new
name|LastExport
argument_list|(
name|ior
argument_list|,
name|obj
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ior
return|;
block|}
specifier|public
specifier|static
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|Object
name|importObjectReference
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|String
name|url
parameter_list|)
block|{
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|Object
name|result
decl_stmt|;
if|if
condition|(
name|url
operator|.
name|startsWith
argument_list|(
literal|"file:"
argument_list|)
condition|)
block|{
return|return
name|importObjectReferenceFromFile
argument_list|(
name|orb
argument_list|,
name|url
operator|.
name|substring
argument_list|(
literal|5
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
literal|"IOR:"
operator|.
name|equalsIgnoreCase
argument_list|(
name|url
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Proxy not initialized. URL contains a invalid ior"
argument_list|)
throw|;
block|}
name|String
name|trimmedUrl
init|=
name|url
operator|.
name|trim
argument_list|()
decl_stmt|;
name|LastExport
name|last
init|=
name|LAST_EXPORT_CACHE
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|last
operator|!=
literal|null
operator|&&
name|trimmedUrl
operator|.
name|equals
argument_list|(
name|last
operator|.
name|getIor
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|last
operator|.
name|getRef
argument_list|()
return|;
block|}
try|try
block|{
name|result
operator|=
name|orb
operator|.
name|string_to_object
argument_list|(
name|trimmedUrl
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
specifier|public
specifier|static
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|Object
name|importObjectReferenceFromFile
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|String
name|url
parameter_list|)
block|{
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|Object
name|result
decl_stmt|;
try|try
block|{
name|java
operator|.
name|io
operator|.
name|File
name|file
init|=
operator|new
name|java
operator|.
name|io
operator|.
name|File
argument_list|(
name|url
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not find file "
operator|+
name|url
operator|+
literal|" to read the object reference"
argument_list|)
throw|;
block|}
name|java
operator|.
name|io
operator|.
name|BufferedReader
name|reader
init|=
operator|new
name|java
operator|.
name|io
operator|.
name|BufferedReader
argument_list|(
operator|new
name|java
operator|.
name|io
operator|.
name|FileReader
argument_list|(
name|file
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|ior
init|=
name|reader
operator|.
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|ior
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid object reference found in file "
operator|+
name|url
argument_list|)
throw|;
block|}
name|result
operator|=
name|orb
operator|.
name|string_to_object
argument_list|(
name|ior
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
specifier|public
specifier|static
name|XmlSchemaType
name|getXmlSchemaType
parameter_list|(
name|ServiceInfo
name|serviceInfo
parameter_list|,
name|QName
name|name
parameter_list|)
block|{
name|XmlSchemaType
name|result
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|name
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|serviceInfo
operator|!=
literal|null
operator|)
condition|)
block|{
name|SchemaCollection
name|col
init|=
name|serviceInfo
operator|.
name|getXmlSchemaCollection
argument_list|()
decl_stmt|;
name|result
operator|=
name|col
operator|.
name|getTypeByQName
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
comment|//check the name, if it is an element
name|XmlSchemaElement
name|el
init|=
name|col
operator|.
name|getElementByQName
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|el
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|el
operator|.
name|getSchemaType
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
comment|//Change this method to access the XmlSchemaCollection.
specifier|public
specifier|static
name|boolean
name|isElementFormQualified
parameter_list|(
name|ServiceInfo
name|serviceInfo
parameter_list|,
name|String
name|uri
parameter_list|)
block|{
if|if
condition|(
name|uri
operator|!=
literal|null
condition|)
block|{
name|SchemaInfo
name|schemaInfo
init|=
name|serviceInfo
operator|.
name|getSchema
argument_list|(
name|uri
argument_list|)
decl_stmt|;
if|if
condition|(
name|schemaInfo
operator|!=
literal|null
condition|)
block|{
return|return
name|schemaInfo
operator|.
name|isElementFormQualified
argument_list|()
return|;
block|}
name|Iterator
argument_list|<
name|SchemaInfo
argument_list|>
name|it
init|=
name|serviceInfo
operator|.
name|getSchemas
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|XmlSchema
name|schema
init|=
name|it
operator|.
name|next
argument_list|()
operator|.
name|getSchema
argument_list|()
decl_stmt|;
return|return
name|isElementFormQualified
argument_list|(
name|schema
argument_list|,
name|uri
argument_list|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|//Change this method to access the XmlSchemaCollection.
specifier|private
specifier|static
name|boolean
name|isElementFormQualified
parameter_list|(
name|XmlSchema
name|schema
parameter_list|,
name|String
name|uri
parameter_list|)
block|{
if|if
condition|(
name|uri
operator|.
name|equals
argument_list|(
name|schema
operator|.
name|getTargetNamespace
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|schema
operator|.
name|getElementFormDefault
argument_list|()
operator|==
name|XmlSchemaForm
operator|.
name|QUALIFIED
return|;
block|}
for|for
control|(
name|XmlSchemaExternal
name|extSchema
range|:
name|schema
operator|.
name|getExternals
argument_list|()
control|)
block|{
return|return
name|isElementFormQualified
argument_list|(
name|extSchema
operator|.
name|getSchema
argument_list|()
argument_list|,
name|uri
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
comment|//Change this method to access the XmlSchemaCollection.
specifier|public
specifier|static
name|boolean
name|isAttributeFormQualified
parameter_list|(
name|ServiceInfo
name|serviceInfo
parameter_list|,
name|String
name|uri
parameter_list|)
block|{
if|if
condition|(
name|uri
operator|!=
literal|null
condition|)
block|{
name|SchemaInfo
name|schemaInfo
init|=
name|serviceInfo
operator|.
name|getSchema
argument_list|(
name|uri
argument_list|)
decl_stmt|;
if|if
condition|(
name|schemaInfo
operator|!=
literal|null
condition|)
block|{
return|return
name|schemaInfo
operator|.
name|isAttributeFormQualified
argument_list|()
return|;
block|}
name|Iterator
argument_list|<
name|SchemaInfo
argument_list|>
name|it
init|=
name|serviceInfo
operator|.
name|getSchemas
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|XmlSchema
name|schema
init|=
name|it
operator|.
name|next
argument_list|()
operator|.
name|getSchema
argument_list|()
decl_stmt|;
return|return
name|isAttributeFormQualified
argument_list|(
name|schema
argument_list|,
name|uri
argument_list|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|//Change this method to access the XmlSchemaCollection.
specifier|private
specifier|static
name|boolean
name|isAttributeFormQualified
parameter_list|(
name|XmlSchema
name|schema
parameter_list|,
name|String
name|uri
parameter_list|)
block|{
if|if
condition|(
name|uri
operator|.
name|equals
argument_list|(
name|schema
operator|.
name|getTargetNamespace
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|schema
operator|.
name|getAttributeFormDefault
argument_list|()
operator|==
name|XmlSchemaForm
operator|.
name|QUALIFIED
return|;
block|}
for|for
control|(
name|XmlSchemaExternal
name|extSchema
range|:
name|schema
operator|.
name|getExternals
argument_list|()
control|)
block|{
return|return
name|isAttributeFormQualified
argument_list|(
name|extSchema
operator|.
name|getSchema
argument_list|()
argument_list|,
name|uri
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
specifier|static
name|QName
name|processQName
parameter_list|(
name|QName
name|qname
parameter_list|,
name|ServiceInfo
name|serviceInfo
parameter_list|)
block|{
name|QName
name|result
init|=
name|qname
decl_stmt|;
if|if
condition|(
operator|(
name|qname
operator|.
name|getNamespaceURI
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|qname
operator|.
name|getNamespaceURI
argument_list|()
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|isElementFormQualified
argument_list|(
name|serviceInfo
argument_list|,
name|qname
operator|.
name|getNamespaceURI
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|result
operator|=
operator|new
name|QName
argument_list|(
literal|""
argument_list|,
name|qname
operator|.
name|getLocalPart
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|public
specifier|static
name|NVList
name|nvListFromStreamables
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|CorbaStreamable
index|[]
name|streamables
parameter_list|)
block|{
name|NVList
name|list
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|streamables
operator|!=
literal|null
operator|&&
name|streamables
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|list
operator|=
name|orb
operator|.
name|create_list
argument_list|(
name|streamables
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|streamables
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|Any
name|value
init|=
name|orb
operator|.
name|create_any
argument_list|()
decl_stmt|;
name|value
operator|.
name|insert_Streamable
argument_list|(
name|streamables
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|list
operator|.
name|add_value
argument_list|(
name|streamables
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
argument_list|,
name|value
argument_list|,
name|streamables
index|[
name|i
index|]
operator|.
name|getMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|list
operator|=
name|orb
operator|.
name|create_list
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
static|static
block|{
name|PRIMITIVE_TYPECODES
operator|.
name|put
argument_list|(
name|CorbaConstants
operator|.
name|NT_CORBA_BOOLEAN
argument_list|,
name|TCKind
operator|.
name|from_int
argument_list|(
name|TCKind
operator|.
name|_tk_boolean
argument_list|)
argument_list|)
expr_stmt|;
name|PRIMITIVE_TYPECODES
operator|.
name|put
argument_list|(
name|CorbaConstants
operator|.
name|NT_CORBA_CHAR
argument_list|,
name|TCKind
operator|.
name|from_int
argument_list|(
name|TCKind
operator|.
name|_tk_char
argument_list|)
argument_list|)
expr_stmt|;
name|PRIMITIVE_TYPECODES
operator|.
name|put
argument_list|(
name|CorbaConstants
operator|.
name|NT_CORBA_WCHAR
argument_list|,
name|TCKind
operator|.
name|from_int
argument_list|(
name|TCKind
operator|.
name|_tk_wchar
argument_list|)
argument_list|)
expr_stmt|;
name|PRIMITIVE_TYPECODES
operator|.
name|put
argument_list|(
name|CorbaConstants
operator|.
name|NT_CORBA_OCTET
argument_list|,
name|TCKind
operator|.
name|from_int
argument_list|(
name|TCKind
operator|.
name|_tk_octet
argument_list|)
argument_list|)
expr_stmt|;
name|PRIMITIVE_TYPECODES
operator|.
name|put
argument_list|(
name|CorbaConstants
operator|.
name|NT_CORBA_USHORT
argument_list|,
name|TCKind
operator|.
name|from_int
argument_list|(
name|TCKind
operator|.
name|_tk_ushort
argument_list|)
argument_list|)
expr_stmt|;
name|PRIMITIVE_TYPECODES
operator|.
name|put
argument_list|(
name|CorbaConstants
operator|.
name|NT_CORBA_SHORT
argument_list|,
name|TCKind
operator|.
name|from_int
argument_list|(
name|TCKind
operator|.
name|_tk_short
argument_list|)
argument_list|)
expr_stmt|;
name|PRIMITIVE_TYPECODES
operator|.
name|put
argument_list|(
name|CorbaConstants
operator|.
name|NT_CORBA_LONG
argument_list|,
name|TCKind
operator|.
name|from_int
argument_list|(
name|TCKind
operator|.
name|_tk_long
argument_list|)
argument_list|)
expr_stmt|;
name|PRIMITIVE_TYPECODES
operator|.
name|put
argument_list|(
name|CorbaConstants
operator|.
name|NT_CORBA_ULONG
argument_list|,
name|TCKind
operator|.
name|from_int
argument_list|(
name|TCKind
operator|.
name|_tk_ulong
argument_list|)
argument_list|)
expr_stmt|;
name|PRIMITIVE_TYPECODES
operator|.
name|put
argument_list|(
name|CorbaConstants
operator|.
name|NT_CORBA_LONGLONG
argument_list|,
name|TCKind
operator|.
name|from_int
argument_list|(
name|TCKind
operator|.
name|_tk_longlong
argument_list|)
argument_list|)
expr_stmt|;
name|PRIMITIVE_TYPECODES
operator|.
name|put
argument_list|(
name|CorbaConstants
operator|.
name|NT_CORBA_ULONGLONG
argument_list|,
name|TCKind
operator|.
name|from_int
argument_list|(
name|TCKind
operator|.
name|_tk_ulonglong
argument_list|)
argument_list|)
expr_stmt|;
name|PRIMITIVE_TYPECODES
operator|.
name|put
argument_list|(
name|CorbaConstants
operator|.
name|NT_CORBA_FLOAT
argument_list|,
name|TCKind
operator|.
name|from_int
argument_list|(
name|TCKind
operator|.
name|_tk_float
argument_list|)
argument_list|)
expr_stmt|;
name|PRIMITIVE_TYPECODES
operator|.
name|put
argument_list|(
name|CorbaConstants
operator|.
name|NT_CORBA_DOUBLE
argument_list|,
name|TCKind
operator|.
name|from_int
argument_list|(
name|TCKind
operator|.
name|_tk_double
argument_list|)
argument_list|)
expr_stmt|;
name|PRIMITIVE_TYPECODES
operator|.
name|put
argument_list|(
name|CorbaConstants
operator|.
name|NT_CORBA_STRING
argument_list|,
name|TCKind
operator|.
name|from_int
argument_list|(
name|TCKind
operator|.
name|_tk_string
argument_list|)
argument_list|)
expr_stmt|;
name|PRIMITIVE_TYPECODES
operator|.
name|put
argument_list|(
name|CorbaConstants
operator|.
name|NT_CORBA_WSTRING
argument_list|,
name|TCKind
operator|.
name|from_int
argument_list|(
name|TCKind
operator|.
name|_tk_wstring
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

