begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements. See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied. See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|types
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|namespace
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|CorbaBindingException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|CorbaTypeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|utils
operator|.
name|CorbaUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Alias
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Anonarray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Anonsequence
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|CorbaType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Exception
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|MemberType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Sequence
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Struct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Union
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|Unionbranch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|binding
operator|.
name|corba
operator|.
name|wsdl
operator|.
name|W3CConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cxf
operator|.
name|service
operator|.
name|model
operator|.
name|ServiceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchemaComplexType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchemaElement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchemaObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchemaParticle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ws
operator|.
name|commons
operator|.
name|schema
operator|.
name|XmlSchemaSequence
import|;
end_import

begin_import
import|import
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|ORB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|TCKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|omg
operator|.
name|CORBA
operator|.
name|TypeCode
import|;
end_import

begin_class
specifier|public
specifier|final
class|class
name|CorbaHandlerUtils
block|{
specifier|private
name|CorbaHandlerUtils
parameter_list|()
block|{
comment|//utility class
block|}
specifier|public
specifier|static
name|CorbaObjectHandler
name|createTypeHandler
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|QName
name|name
parameter_list|,
name|QName
name|idlType
parameter_list|,
name|CorbaTypeMap
name|typeMap
parameter_list|)
block|{
name|CorbaObjectHandler
name|handler
init|=
literal|null
decl_stmt|;
name|TypeCode
name|tc
init|=
name|CorbaUtils
operator|.
name|getTypeCode
argument_list|(
name|orb
argument_list|,
name|idlType
argument_list|,
name|typeMap
argument_list|)
decl_stmt|;
try|try
block|{
while|while
condition|(
name|tc
operator|.
name|kind
argument_list|()
operator|.
name|value
argument_list|()
operator|==
name|TCKind
operator|.
name|_tk_alias
condition|)
block|{
name|Alias
name|alias
init|=
operator|(
name|Alias
operator|)
name|CorbaUtils
operator|.
name|getCorbaType
argument_list|(
name|idlType
argument_list|,
name|typeMap
argument_list|)
decl_stmt|;
if|if
condition|(
name|alias
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CorbaBindingException
argument_list|(
literal|"Couldn't find corba alias type: "
operator|+
name|idlType
argument_list|)
throw|;
block|}
name|tc
operator|=
name|tc
operator|.
name|content_type
argument_list|()
expr_stmt|;
name|idlType
operator|=
name|alias
operator|.
name|getBasetype
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|CorbaBindingException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
if|if
condition|(
name|CorbaUtils
operator|.
name|isPrimitiveIdlType
argument_list|(
name|idlType
argument_list|)
condition|)
block|{
name|handler
operator|=
operator|new
name|CorbaPrimitiveHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tc
operator|.
name|kind
argument_list|()
operator|.
name|value
argument_list|()
operator|==
name|TCKind
operator|.
name|_tk_any
condition|)
block|{
comment|// Any is a special kind of primitive so it gets its own handler
name|handler
operator|=
operator|new
name|CorbaAnyHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
literal|null
argument_list|)
expr_stmt|;
operator|(
operator|(
name|CorbaAnyHandler
operator|)
name|handler
operator|)
operator|.
name|setTypeMap
argument_list|(
name|typeMap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CorbaType
name|type
init|=
name|CorbaUtils
operator|.
name|getCorbaType
argument_list|(
name|idlType
argument_list|,
name|typeMap
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|tc
operator|.
name|kind
argument_list|()
operator|.
name|value
argument_list|()
condition|)
block|{
case|case
name|TCKind
operator|.
name|_tk_array
case|:
name|handler
operator|=
operator|new
name|CorbaArrayHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_enum
case|:
name|handler
operator|=
operator|new
name|CorbaEnumHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_except
case|:
name|handler
operator|=
operator|new
name|CorbaExceptionHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_fixed
case|:
name|handler
operator|=
operator|new
name|CorbaFixedHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_sequence
case|:
if|if
condition|(
name|isOctets
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|handler
operator|=
operator|new
name|CorbaOctetSequenceHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|handler
operator|=
operator|new
name|CorbaSequenceHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TCKind
operator|.
name|_tk_struct
case|:
name|handler
operator|=
operator|new
name|CorbaStructHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_union
case|:
name|handler
operator|=
operator|new
name|CorbaUnionHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_string
case|:
case|case
name|TCKind
operator|.
name|_tk_wstring
case|:
comment|// These need to be here to catch the anonymous string types.
name|handler
operator|=
operator|new
name|CorbaPrimitiveHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_objref
case|:
name|handler
operator|=
operator|new
name|CorbaObjectReferenceHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|handler
operator|=
operator|new
name|CorbaObjectHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|handler
return|;
block|}
specifier|public
specifier|static
name|CorbaObjectHandler
name|initializeObjectHandler
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|QName
name|name
parameter_list|,
name|QName
name|idlType
parameter_list|,
name|CorbaTypeMap
name|typeMap
parameter_list|,
name|ServiceInfo
name|serviceInfo
parameter_list|)
block|{
name|Map
argument_list|<
name|QName
argument_list|,
name|CorbaObjectHandler
argument_list|>
name|seenTypes
init|=
operator|new
name|HashMap
argument_list|<
name|QName
argument_list|,
name|CorbaObjectHandler
argument_list|>
argument_list|()
decl_stmt|;
return|return
name|initializeObjectHandler
argument_list|(
name|orb
argument_list|,
name|name
argument_list|,
name|idlType
argument_list|,
name|typeMap
argument_list|,
name|serviceInfo
argument_list|,
name|seenTypes
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|CorbaObjectHandler
name|initializeObjectHandler
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|QName
name|name
parameter_list|,
name|QName
name|idlType
parameter_list|,
name|CorbaTypeMap
name|typeMap
parameter_list|,
name|ServiceInfo
name|serviceInfo
parameter_list|,
name|Map
argument_list|<
name|QName
argument_list|,
name|CorbaObjectHandler
argument_list|>
name|seenTypes
parameter_list|)
block|{
name|CorbaObjectHandler
name|obj
init|=
name|createTypeHandler
argument_list|(
name|orb
argument_list|,
name|name
argument_list|,
name|idlType
argument_list|,
name|typeMap
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|CorbaUtils
operator|.
name|isPrimitiveIdlType
argument_list|(
name|idlType
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|obj
operator|.
name|getTypeCode
argument_list|()
operator|.
name|kind
argument_list|()
operator|.
name|value
argument_list|()
condition|)
block|{
case|case
name|TCKind
operator|.
name|_tk_any
case|:
operator|(
operator|(
name|CorbaAnyHandler
operator|)
name|obj
operator|)
operator|.
name|setValue
argument_list|(
name|orb
operator|.
name|create_any
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_array
case|:
name|initializeArrayHandler
argument_list|(
name|orb
argument_list|,
name|obj
argument_list|,
name|typeMap
argument_list|,
name|serviceInfo
argument_list|,
name|seenTypes
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_except
case|:
name|initializeExceptionHandler
argument_list|(
name|orb
argument_list|,
name|obj
argument_list|,
name|typeMap
argument_list|,
name|serviceInfo
argument_list|,
name|seenTypes
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_sequence
case|:
if|if
condition|(
operator|!
name|isOctets
argument_list|(
name|obj
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|initializeSequenceHandler
argument_list|(
name|orb
argument_list|,
name|obj
argument_list|,
name|typeMap
argument_list|,
name|serviceInfo
argument_list|,
name|seenTypes
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TCKind
operator|.
name|_tk_struct
case|:
name|initializeStructHandler
argument_list|(
name|orb
argument_list|,
name|obj
argument_list|,
name|typeMap
argument_list|,
name|serviceInfo
argument_list|,
name|seenTypes
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_union
case|:
name|initializeUnionHandler
argument_list|(
name|orb
argument_list|,
name|obj
argument_list|,
name|typeMap
argument_list|,
name|serviceInfo
argument_list|,
name|seenTypes
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// TODO: Should we raise an exception or log?
block|}
block|}
return|return
name|obj
return|;
block|}
specifier|public
specifier|static
name|void
name|initializeArrayHandler
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|CorbaObjectHandler
name|obj
parameter_list|,
name|CorbaTypeMap
name|typeMap
parameter_list|,
name|ServiceInfo
name|serviceInfo
parameter_list|,
name|Map
argument_list|<
name|QName
argument_list|,
name|CorbaObjectHandler
argument_list|>
name|seenTypes
parameter_list|)
block|{
name|QName
name|arrayElementType
init|=
literal|null
decl_stmt|;
name|long
name|arrayBound
init|=
literal|0
decl_stmt|;
name|CorbaType
name|baseType
init|=
name|obj
operator|.
name|getType
argument_list|()
decl_stmt|;
name|QName
name|elementName
decl_stmt|;
if|if
condition|(
name|baseType
operator|instanceof
name|Array
condition|)
block|{
name|Array
name|arrayType
init|=
operator|(
name|Array
operator|)
name|baseType
decl_stmt|;
name|arrayElementType
operator|=
name|arrayType
operator|.
name|getElemtype
argument_list|()
expr_stmt|;
name|arrayBound
operator|=
name|arrayType
operator|.
name|getBound
argument_list|()
expr_stmt|;
name|elementName
operator|=
name|arrayType
operator|.
name|getElemname
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Anonarray
name|anonArrayType
init|=
operator|(
name|Anonarray
operator|)
name|baseType
decl_stmt|;
name|arrayElementType
operator|=
name|anonArrayType
operator|.
name|getElemtype
argument_list|()
expr_stmt|;
name|arrayBound
operator|=
name|anonArrayType
operator|.
name|getBound
argument_list|()
expr_stmt|;
name|elementName
operator|=
name|anonArrayType
operator|.
name|getElemname
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arrayBound
condition|;
operator|++
name|i
control|)
block|{
name|CorbaObjectHandler
name|elementObj
init|=
name|initializeObjectHandler
argument_list|(
name|orb
argument_list|,
name|elementName
argument_list|,
name|arrayElementType
argument_list|,
name|typeMap
argument_list|,
name|serviceInfo
argument_list|,
name|seenTypes
argument_list|)
decl_stmt|;
operator|(
operator|(
name|CorbaArrayHandler
operator|)
name|obj
operator|)
operator|.
name|addElement
argument_list|(
name|elementObj
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|void
name|initializeExceptionHandler
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|CorbaObjectHandler
name|obj
parameter_list|,
name|CorbaTypeMap
name|typeMap
parameter_list|,
name|ServiceInfo
name|serviceInfo
parameter_list|,
name|Map
argument_list|<
name|QName
argument_list|,
name|CorbaObjectHandler
argument_list|>
name|seenTypes
parameter_list|)
block|{
name|Exception
name|exceptType
init|=
operator|(
name|Exception
operator|)
name|obj
operator|.
name|getType
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|MemberType
argument_list|>
name|exceptMembers
init|=
name|exceptType
operator|.
name|getMember
argument_list|()
decl_stmt|;
name|QName
name|typeName
init|=
name|exceptType
operator|.
name|getType
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exceptMembers
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|MemberType
name|member
init|=
name|exceptMembers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QName
name|memberName
decl_stmt|;
if|if
condition|(
name|member
operator|.
name|isSetQualified
argument_list|()
operator|&&
name|member
operator|.
name|isQualified
argument_list|()
operator|&&
operator|(
name|typeName
operator|!=
literal|null
operator|)
condition|)
block|{
name|memberName
operator|=
operator|new
name|QName
argument_list|(
name|typeName
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|member
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memberName
operator|=
operator|new
name|QName
argument_list|(
literal|""
argument_list|,
name|member
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QName
name|memberType
init|=
name|member
operator|.
name|getIdltype
argument_list|()
decl_stmt|;
name|CorbaObjectHandler
name|memberObj
init|=
name|initializeObjectHandler
argument_list|(
name|orb
argument_list|,
name|memberName
argument_list|,
name|memberType
argument_list|,
name|typeMap
argument_list|,
name|serviceInfo
argument_list|,
name|seenTypes
argument_list|)
decl_stmt|;
operator|(
operator|(
name|CorbaExceptionHandler
operator|)
name|obj
operator|)
operator|.
name|addMember
argument_list|(
name|memberObj
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|void
name|initializeSequenceHandler
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|CorbaObjectHandler
name|obj
parameter_list|,
name|CorbaTypeMap
name|typeMap
parameter_list|,
name|ServiceInfo
name|serviceInfo
parameter_list|,
name|Map
argument_list|<
name|QName
argument_list|,
name|CorbaObjectHandler
argument_list|>
name|seenTypes
parameter_list|)
block|{
name|QName
name|seqElementType
init|=
literal|null
decl_stmt|;
name|long
name|seqBound
init|=
literal|0
decl_stmt|;
name|CorbaType
name|baseType
init|=
name|obj
operator|.
name|getType
argument_list|()
decl_stmt|;
name|QName
name|elementName
decl_stmt|;
if|if
condition|(
name|baseType
operator|instanceof
name|Sequence
condition|)
block|{
name|Sequence
name|seqType
init|=
operator|(
name|Sequence
operator|)
name|baseType
decl_stmt|;
name|seqElementType
operator|=
name|seqType
operator|.
name|getElemtype
argument_list|()
expr_stmt|;
name|seqBound
operator|=
name|seqType
operator|.
name|getBound
argument_list|()
expr_stmt|;
name|elementName
operator|=
name|seqType
operator|.
name|getElemname
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Anonsequence
name|seqType
init|=
operator|(
name|Anonsequence
operator|)
name|baseType
decl_stmt|;
name|seqElementType
operator|=
name|seqType
operator|.
name|getElemtype
argument_list|()
expr_stmt|;
name|seqBound
operator|=
name|seqType
operator|.
name|getBound
argument_list|()
expr_stmt|;
name|elementName
operator|=
name|seqType
operator|.
name|getElemname
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|seqBound
operator|==
literal|0
condition|)
block|{
comment|// This is an unbounded sequence.  Store a 'template' object that we can use to create
comment|// new objects as needed
name|CorbaObjectHandler
name|elementObj
init|=
literal|null
decl_stmt|;
comment|// Check for a recursive type
if|if
condition|(
name|seenTypes
operator|.
name|get
argument_list|(
name|seqElementType
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|elementObj
operator|=
name|seenTypes
operator|.
name|get
argument_list|(
name|seqElementType
argument_list|)
expr_stmt|;
name|elementObj
operator|.
name|setRecursive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
operator|(
operator|(
name|CorbaSequenceHandler
operator|)
name|obj
operator|)
operator|.
name|hasRecursiveTypeElement
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elementObj
operator|=
name|initializeObjectHandler
argument_list|(
name|orb
argument_list|,
name|elementName
argument_list|,
name|seqElementType
argument_list|,
name|typeMap
argument_list|,
name|serviceInfo
argument_list|,
name|seenTypes
argument_list|)
expr_stmt|;
block|}
operator|(
operator|(
name|CorbaSequenceHandler
operator|)
name|obj
operator|)
operator|.
name|setTemplateElement
argument_list|(
name|elementObj
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|seqBound
condition|;
operator|++
name|i
control|)
block|{
name|CorbaObjectHandler
name|elementObj
init|=
literal|null
decl_stmt|;
comment|// Check for a recursive type
if|if
condition|(
name|seenTypes
operator|.
name|get
argument_list|(
name|seqElementType
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// Even though this is bounded, if we have a recursive type, we'll still use the
comment|// template object so that we don't overwrite the value of the element.
name|elementObj
operator|=
name|seenTypes
operator|.
name|get
argument_list|(
name|seqElementType
argument_list|)
expr_stmt|;
name|elementObj
operator|.
name|setRecursive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
operator|(
operator|(
name|CorbaSequenceHandler
operator|)
name|obj
operator|)
operator|.
name|hasRecursiveTypeElement
argument_list|(
literal|true
argument_list|)
expr_stmt|;
operator|(
operator|(
name|CorbaSequenceHandler
operator|)
name|obj
operator|)
operator|.
name|setTemplateElement
argument_list|(
name|elementObj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elementObj
operator|=
name|initializeObjectHandler
argument_list|(
name|orb
argument_list|,
name|elementName
argument_list|,
name|seqElementType
argument_list|,
name|typeMap
argument_list|,
name|serviceInfo
argument_list|,
name|seenTypes
argument_list|)
expr_stmt|;
operator|(
operator|(
name|CorbaSequenceHandler
operator|)
name|obj
operator|)
operator|.
name|addElement
argument_list|(
name|elementObj
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
specifier|static
name|void
name|initializeStructHandler
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|CorbaObjectHandler
name|obj
parameter_list|,
name|CorbaTypeMap
name|typeMap
parameter_list|,
name|ServiceInfo
name|serviceInfo
parameter_list|,
name|Map
argument_list|<
name|QName
argument_list|,
name|CorbaObjectHandler
argument_list|>
name|seenTypes
parameter_list|)
block|{
name|Struct
name|structType
init|=
operator|(
name|Struct
operator|)
name|obj
operator|.
name|getType
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|MemberType
argument_list|>
name|structMembers
init|=
name|structType
operator|.
name|getMember
argument_list|()
decl_stmt|;
name|QName
name|typeName
init|=
name|structType
operator|.
name|getType
argument_list|()
decl_stmt|;
name|seenTypes
operator|.
name|put
argument_list|(
name|obj
operator|.
name|getIdlType
argument_list|()
argument_list|,
name|obj
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|structMembers
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|MemberType
name|member
init|=
name|structMembers
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QName
name|memberName
decl_stmt|;
if|if
condition|(
name|member
operator|.
name|isSetQualified
argument_list|()
operator|&&
name|member
operator|.
name|isQualified
argument_list|()
operator|&&
operator|(
name|typeName
operator|!=
literal|null
operator|)
condition|)
block|{
name|memberName
operator|=
operator|new
name|QName
argument_list|(
name|typeName
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|member
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memberName
operator|=
operator|new
name|QName
argument_list|(
literal|""
argument_list|,
name|member
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QName
name|memberType
init|=
name|member
operator|.
name|getIdltype
argument_list|()
decl_stmt|;
name|CorbaObjectHandler
name|memberObj
init|=
name|initializeObjectHandler
argument_list|(
name|orb
argument_list|,
name|memberName
argument_list|,
name|memberType
argument_list|,
name|typeMap
argument_list|,
name|serviceInfo
argument_list|,
name|seenTypes
argument_list|)
decl_stmt|;
if|if
condition|(
name|member
operator|.
name|isSetAnonschematype
argument_list|()
operator|&&
name|member
operator|.
name|isAnonschematype
argument_list|()
condition|)
block|{
name|memberObj
operator|.
name|setAnonymousType
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
operator|(
operator|(
name|CorbaStructHandler
operator|)
name|obj
operator|)
operator|.
name|addMember
argument_list|(
name|memberObj
argument_list|)
expr_stmt|;
block|}
name|seenTypes
operator|.
name|remove
argument_list|(
name|obj
operator|.
name|getIdlType
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|initializeUnionHandler
parameter_list|(
name|ORB
name|orb
parameter_list|,
name|CorbaObjectHandler
name|obj
parameter_list|,
name|CorbaTypeMap
name|typeMap
parameter_list|,
name|ServiceInfo
name|serviceInfo
parameter_list|,
name|Map
argument_list|<
name|QName
argument_list|,
name|CorbaObjectHandler
argument_list|>
name|seenTypes
parameter_list|)
block|{
name|Union
name|unionType
init|=
operator|(
name|Union
operator|)
name|obj
operator|.
name|getType
argument_list|()
decl_stmt|;
comment|// First handle the discriminator
name|CorbaObjectHandler
name|discObj
init|=
name|initializeObjectHandler
argument_list|(
name|orb
argument_list|,
operator|new
name|QName
argument_list|(
literal|"discriminator"
argument_list|)
argument_list|,
name|unionType
operator|.
name|getDiscriminator
argument_list|()
argument_list|,
name|typeMap
argument_list|,
name|serviceInfo
argument_list|,
name|seenTypes
argument_list|)
decl_stmt|;
operator|(
operator|(
name|CorbaUnionHandler
operator|)
name|obj
operator|)
operator|.
name|setDiscriminator
argument_list|(
name|discObj
argument_list|)
expr_stmt|;
name|QName
name|typeName
init|=
name|unionType
operator|.
name|getType
argument_list|()
decl_stmt|;
name|seenTypes
operator|.
name|put
argument_list|(
name|obj
operator|.
name|getIdlType
argument_list|()
argument_list|,
name|obj
argument_list|)
expr_stmt|;
comment|// Now handle all of the branches
name|List
argument_list|<
name|Unionbranch
argument_list|>
name|unionBranches
init|=
name|unionType
operator|.
name|getUnionbranch
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|unionBranches
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Unionbranch
name|branch
init|=
name|unionBranches
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QName
name|branchName
decl_stmt|;
if|if
condition|(
name|branch
operator|.
name|isSetQualified
argument_list|()
operator|&&
name|branch
operator|.
name|isQualified
argument_list|()
operator|&&
operator|(
name|typeName
operator|!=
literal|null
operator|)
condition|)
block|{
name|branchName
operator|=
operator|new
name|QName
argument_list|(
name|typeName
operator|.
name|getNamespaceURI
argument_list|()
argument_list|,
name|branch
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|branchName
operator|=
operator|new
name|QName
argument_list|(
literal|""
argument_list|,
name|branch
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QName
name|branchIdlType
init|=
name|branch
operator|.
name|getIdltype
argument_list|()
decl_stmt|;
name|CorbaObjectHandler
name|branchObj
init|=
name|initializeObjectHandler
argument_list|(
name|orb
argument_list|,
name|branchName
argument_list|,
name|branchIdlType
argument_list|,
name|typeMap
argument_list|,
name|serviceInfo
argument_list|,
name|seenTypes
argument_list|)
decl_stmt|;
operator|(
operator|(
name|CorbaUnionHandler
operator|)
name|obj
operator|)
operator|.
name|addCase
argument_list|(
name|branchObj
argument_list|)
expr_stmt|;
block|}
name|seenTypes
operator|.
name|remove
argument_list|(
name|obj
operator|.
name|getIdlType
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//Change this method to access the XmlSchemaCollection.
specifier|public
specifier|static
name|String
name|getNamespaceURI
parameter_list|(
name|ServiceInfo
name|serviceInfo
parameter_list|,
name|QName
name|typeName
parameter_list|)
block|{
name|String
name|nsUri
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|(
name|typeName
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|CorbaUtils
operator|.
name|isElementFormQualified
argument_list|(
name|serviceInfo
argument_list|,
name|typeName
operator|.
name|getNamespaceURI
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|nsUri
operator|=
name|typeName
operator|.
name|getNamespaceURI
argument_list|()
expr_stmt|;
block|}
return|return
name|nsUri
return|;
block|}
specifier|public
specifier|static
name|XmlSchemaElement
name|getXmlSchemaSequenceElement
parameter_list|(
name|XmlSchemaObject
name|schemaType
parameter_list|,
name|ServiceInfo
name|serviceInfo
parameter_list|)
block|{
name|XmlSchemaObject
name|stype
init|=
name|schemaType
decl_stmt|;
name|XmlSchemaElement
name|el
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|schemaType
operator|instanceof
name|XmlSchemaElement
condition|)
block|{
name|stype
operator|=
operator|(
operator|(
name|XmlSchemaElement
operator|)
name|schemaType
operator|)
operator|.
name|getSchemaType
argument_list|()
expr_stmt|;
if|if
condition|(
name|stype
operator|==
literal|null
condition|)
block|{
name|stype
operator|=
name|CorbaUtils
operator|.
name|getXmlSchemaType
argument_list|(
name|serviceInfo
argument_list|,
operator|(
operator|(
name|XmlSchemaElement
operator|)
name|schemaType
operator|)
operator|.
name|getRef
argument_list|()
operator|.
name|getTargetQName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stype
operator|instanceof
name|XmlSchemaComplexType
condition|)
block|{
comment|//only one element inside the XmlSchemaComplexType
name|XmlSchemaComplexType
name|ctype
init|=
operator|(
name|XmlSchemaComplexType
operator|)
name|stype
decl_stmt|;
name|XmlSchemaParticle
name|group
init|=
name|ctype
operator|.
name|getParticle
argument_list|()
decl_stmt|;
comment|/* This code seems to think that we're guaranteed a sequence here */
name|XmlSchemaSequence
name|seq
init|=
operator|(
name|XmlSchemaSequence
operator|)
name|group
decl_stmt|;
comment|/* and an element in it, too */
name|el
operator|=
operator|(
name|XmlSchemaElement
operator|)
name|seq
operator|.
name|getItems
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|el
operator|=
operator|(
name|XmlSchemaElement
operator|)
name|schemaType
expr_stmt|;
block|}
return|return
name|el
return|;
block|}
specifier|public
specifier|static
name|CorbaTypeListener
name|getTypeListener
parameter_list|(
name|QName
name|name
parameter_list|,
name|QName
name|idlType
parameter_list|,
name|CorbaTypeMap
name|typeMap
parameter_list|,
name|ORB
name|orb
parameter_list|,
name|ServiceInfo
name|serviceInfo
parameter_list|)
throws|throws
name|CorbaBindingException
block|{
name|CorbaObjectHandler
name|handler
init|=
literal|null
decl_stmt|;
name|TypeCode
name|tc
init|=
name|CorbaUtils
operator|.
name|getTypeCode
argument_list|(
name|orb
argument_list|,
name|idlType
argument_list|,
name|typeMap
argument_list|)
decl_stmt|;
try|try
block|{
while|while
condition|(
name|tc
operator|.
name|kind
argument_list|()
operator|.
name|value
argument_list|()
operator|==
name|TCKind
operator|.
name|_tk_alias
condition|)
block|{
name|Alias
name|alias
init|=
operator|(
name|Alias
operator|)
name|CorbaUtils
operator|.
name|getCorbaType
argument_list|(
name|idlType
argument_list|,
name|typeMap
argument_list|)
decl_stmt|;
if|if
condition|(
name|alias
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CorbaBindingException
argument_list|(
literal|"Couldn't find corba alias type: "
operator|+
name|idlType
argument_list|)
throw|;
block|}
name|tc
operator|=
name|tc
operator|.
name|content_type
argument_list|()
expr_stmt|;
name|idlType
operator|=
name|alias
operator|.
name|getBasetype
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|CorbaBindingException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
name|CorbaTypeListener
name|result
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|CorbaUtils
operator|.
name|isPrimitiveIdlType
argument_list|(
name|idlType
argument_list|)
condition|)
block|{
name|handler
operator|=
operator|new
name|CorbaPrimitiveHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|result
operator|=
operator|new
name|CorbaPrimitiveListener
argument_list|(
name|handler
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CorbaType
name|type
init|=
name|CorbaUtils
operator|.
name|getCorbaType
argument_list|(
name|idlType
argument_list|,
name|typeMap
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|tc
operator|.
name|kind
argument_list|()
operator|.
name|value
argument_list|()
condition|)
block|{
case|case
name|TCKind
operator|.
name|_tk_any
case|:
name|handler
operator|=
operator|new
name|CorbaAnyHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
operator|(
operator|(
name|CorbaAnyHandler
operator|)
name|handler
operator|)
operator|.
name|setTypeMap
argument_list|(
name|typeMap
argument_list|)
expr_stmt|;
name|result
operator|=
operator|new
name|CorbaAnyListener
argument_list|(
name|handler
argument_list|,
name|typeMap
argument_list|,
name|orb
argument_list|,
name|serviceInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_array
case|:
name|handler
operator|=
operator|new
name|CorbaArrayHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
operator|new
name|CorbaArrayListener
argument_list|(
name|handler
argument_list|,
name|typeMap
argument_list|,
name|orb
argument_list|,
name|serviceInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_enum
case|:
name|handler
operator|=
operator|new
name|CorbaEnumHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
operator|new
name|CorbaEnumListener
argument_list|(
name|handler
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_except
case|:
name|handler
operator|=
operator|new
name|CorbaExceptionHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
operator|new
name|CorbaExceptionListener
argument_list|(
name|handler
argument_list|,
name|typeMap
argument_list|,
name|orb
argument_list|,
name|serviceInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_fixed
case|:
name|handler
operator|=
operator|new
name|CorbaFixedHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
operator|new
name|CorbaFixedListener
argument_list|(
name|handler
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_sequence
case|:
if|if
condition|(
name|isOctets
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|handler
operator|=
operator|new
name|CorbaOctetSequenceHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
operator|new
name|CorbaOctetSequenceListener
argument_list|(
name|handler
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|handler
operator|=
operator|new
name|CorbaSequenceHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
operator|new
name|CorbaSequenceListener
argument_list|(
name|handler
argument_list|,
name|typeMap
argument_list|,
name|orb
argument_list|,
name|serviceInfo
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TCKind
operator|.
name|_tk_string
case|:
case|case
name|TCKind
operator|.
name|_tk_wstring
case|:
comment|// These can be handled just like regular strings
name|handler
operator|=
operator|new
name|CorbaPrimitiveHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
operator|new
name|CorbaPrimitiveListener
argument_list|(
name|handler
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_struct
case|:
name|handler
operator|=
operator|new
name|CorbaStructHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
operator|new
name|CorbaStructListener
argument_list|(
name|handler
argument_list|,
name|typeMap
argument_list|,
name|orb
argument_list|,
name|serviceInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_union
case|:
name|handler
operator|=
operator|new
name|CorbaUnionHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
operator|new
name|CorbaUnionListener
argument_list|(
name|handler
argument_list|,
name|typeMap
argument_list|,
name|orb
argument_list|,
name|serviceInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_objref
case|:
name|handler
operator|=
operator|new
name|CorbaObjectReferenceHandler
argument_list|(
name|name
argument_list|,
name|idlType
argument_list|,
name|tc
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
operator|new
name|CorbaObjectReferenceListener
argument_list|(
name|handler
argument_list|,
name|orb
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|CorbaBindingException
argument_list|(
literal|"Unsupported complex type "
operator|+
name|idlType
argument_list|)
throw|;
block|}
block|}
return|return
name|result
return|;
block|}
specifier|public
specifier|static
name|CorbaTypeEventProducer
name|getTypeEventProducer
parameter_list|(
name|CorbaObjectHandler
name|handler
parameter_list|,
name|ServiceInfo
name|serviceInfo
parameter_list|,
name|ORB
name|orb
parameter_list|)
throws|throws
name|CorbaBindingException
block|{
name|QName
name|idlType
init|=
name|handler
operator|.
name|getIdlType
argument_list|()
decl_stmt|;
name|TypeCode
name|tc
init|=
name|handler
operator|.
name|getTypeCode
argument_list|()
decl_stmt|;
name|CorbaTypeEventProducer
name|result
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|CorbaUtils
operator|.
name|isPrimitiveIdlType
argument_list|(
name|idlType
argument_list|)
condition|)
block|{
name|result
operator|=
operator|new
name|CorbaPrimitiveTypeEventProducer
argument_list|(
name|handler
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|tc
operator|.
name|kind
argument_list|()
operator|.
name|value
argument_list|()
condition|)
block|{
case|case
name|TCKind
operator|.
name|_tk_any
case|:
name|result
operator|=
operator|new
name|CorbaAnyEventProducer
argument_list|(
name|handler
argument_list|,
name|serviceInfo
argument_list|,
name|orb
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_array
case|:
name|result
operator|=
operator|new
name|CorbaArrayEventProducer
argument_list|(
name|handler
argument_list|,
name|serviceInfo
argument_list|,
name|orb
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_enum
case|:
name|result
operator|=
operator|new
name|CorbaEnumEventProducer
argument_list|(
name|handler
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_except
case|:
name|result
operator|=
operator|new
name|CorbaExceptionEventProducer
argument_list|(
name|handler
argument_list|,
name|serviceInfo
argument_list|,
name|orb
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_fixed
case|:
name|result
operator|=
operator|new
name|CorbaFixedEventProducer
argument_list|(
name|handler
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_sequence
case|:
if|if
condition|(
name|isOctets
argument_list|(
name|handler
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|result
operator|=
operator|new
name|CorbaOctetSequenceEventProducer
argument_list|(
name|handler
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
operator|new
name|CorbaSequenceEventProducer
argument_list|(
name|handler
argument_list|,
name|serviceInfo
argument_list|,
name|orb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TCKind
operator|.
name|_tk_string
case|:
case|case
name|TCKind
operator|.
name|_tk_wstring
case|:
comment|// These can be handled just like regular strings
name|result
operator|=
operator|new
name|CorbaPrimitiveTypeEventProducer
argument_list|(
name|handler
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_struct
case|:
if|if
condition|(
name|handler
operator|.
name|isAnonymousType
argument_list|()
condition|)
block|{
name|result
operator|=
operator|new
name|CorbaAnonStructEventProducer
argument_list|(
name|handler
argument_list|,
name|serviceInfo
argument_list|,
name|orb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
operator|new
name|CorbaStructEventProducer
argument_list|(
name|handler
argument_list|,
name|serviceInfo
argument_list|,
name|orb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TCKind
operator|.
name|_tk_union
case|:
name|result
operator|=
operator|new
name|CorbaUnionEventProducer
argument_list|(
name|handler
argument_list|,
name|serviceInfo
argument_list|,
name|orb
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCKind
operator|.
name|_tk_objref
case|:
name|result
operator|=
operator|new
name|CorbaObjectReferenceEventProducer
argument_list|(
name|handler
argument_list|,
name|serviceInfo
argument_list|,
name|orb
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|CorbaBindingException
argument_list|(
literal|"Unsupported complex type "
operator|+
name|idlType
argument_list|)
throw|;
block|}
block|}
return|return
name|result
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isPrimitiveIDLTypeSequence
parameter_list|(
name|CorbaObjectHandler
name|handler
parameter_list|)
block|{
name|CorbaType
name|seqType
init|=
name|handler
operator|.
name|getType
argument_list|()
decl_stmt|;
name|QName
name|seqElementType
decl_stmt|;
if|if
condition|(
name|seqType
operator|instanceof
name|Anonsequence
condition|)
block|{
name|Anonsequence
name|anonSeqType
init|=
operator|(
name|Anonsequence
operator|)
name|seqType
decl_stmt|;
name|seqElementType
operator|=
name|anonSeqType
operator|.
name|getElemtype
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Sequence
name|type
init|=
operator|(
name|Sequence
operator|)
name|seqType
decl_stmt|;
name|seqElementType
operator|=
name|type
operator|.
name|getElemtype
argument_list|()
expr_stmt|;
block|}
return|return
name|CorbaUtils
operator|.
name|isPrimitiveIdlType
argument_list|(
name|seqElementType
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isAnonType
parameter_list|(
name|XmlSchemaObject
name|schemaObj
parameter_list|)
block|{
name|boolean
name|result
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|schemaObj
operator|!=
literal|null
operator|)
operator|&&
operator|!
operator|(
name|schemaObj
operator|instanceof
name|XmlSchemaElement
operator|)
operator|&&
operator|!
operator|(
name|schemaObj
operator|instanceof
name|XmlSchemaComplexType
operator|)
condition|)
block|{
name|result
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isOctets
parameter_list|(
name|CorbaType
name|baseType
parameter_list|)
block|{
return|return
name|baseType
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|W3CConstants
operator|.
name|NT_SCHEMA_BASE64
argument_list|)
operator|||
name|baseType
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|W3CConstants
operator|.
name|NT_SCHEMA_HBIN
argument_list|)
return|;
block|}
block|}
end_class

end_unit

